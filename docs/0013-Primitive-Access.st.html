<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>Smalltalk76/Primitive-Access.st</title>
	<link rel="stylesheet" type="text/css" href="font.css"/>
  </head>
  <body>
    <div class="line left">
<span class="small">&rsquo;From Smalltalk 5.5k XM November 24 on 22 November 1980 at 2:57:08 am.&rsquo;<br></span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold">"BitBlt"</span></div>
<div class="line left">
<span class="medium bold">Class new title: &rsquo;BitBlt&rsquo;<br></span><span class="tab"></span><span class="medium bold">subclassof: Object<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;function color destbase destraster destx desty<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="medium bold">width height sourcebase sourceraster sourcex sourcey<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="medium bold">sstrike dstrike &rsquo;<br></span><span class="tab"></span><span class="medium bold">declare: &rsquo;pageOneCursor &rsquo;;<br></span><span class="tab"></span><span class="medium bold">asFollows</span></div>
<div class="line left">
<span class="small italic"><br>BitBlt copies bits from one rectangle to another in core.  x, y, width and height are in bits, raster is in words, and base is a core address.  Mode is storing, oring, xoring or erasing.  If source or destination is a Smalltalk object, then you have to lock it, as in copyToString, below.  The primitive does no bounds checking, so watch out.</span></div>
<div class="line left">
<span class="medium bold"><br>Access to Parts</span></div>
<div class="line left">
<span class="small bold">color  </span><span class="small">[⇑color]</span></div>
<div class="line left">
<span class="small bold">color &larr; color</span></div>
<div class="line left">
<span class="small bold">destbase  </span><span class="small">[⇑destbase]</span></div>
<div class="line left">
<span class="small bold">destbase &larr; destbase</span></div>
<div class="line left">
<span class="small bold">destraster  </span><span class="small">[⇑destraster]</span></div>
<div class="line left">
<span class="small bold">destraster &larr; destraster</span></div>
<div class="line left">
<span class="small bold">destx  </span><span class="small">[⇑destx]</span></div>
<div class="line left">
<span class="small bold">destx &larr; destx</span></div>
<div class="line left">
<span class="small bold">desty  </span><span class="small">[⇑desty]</span></div>
<div class="line left">
<span class="small bold">desty &larr; desty</span></div>
<div class="line left">
<span class="small bold">dest &larr; pt </span><span class="small">[destx&larr; pt x.  desty &larr; pt y]</span></div>
<div class="line left">
<span class="small bold">dstrike </span><span class="small">[⇑dstrike]<br></span></div>
<div class="line left">
<span class="small bold">dstrike &larr; dstrike<br></span></div>
<div class="line left">
<span class="small bold">extent &larr; pt </span><span class="small">[width &larr; pt x.  height &larr; pt y]</span></div>
<div class="line left">
<span class="small bold">function  </span><span class="small">[⇑function]</span></div>
<div class="line left">
<span class="small bold">function &larr; function</span></div>
<div class="line left">
<span class="small bold">height  </span><span class="small">[⇑height]</span></div>
<div class="line left">
<span class="small bold">height &larr; height</span></div>
<div class="line left">
<span class="small bold">sourcebase  </span><span class="small">[⇑sourcebase]</span></div>
<div class="line left">
<span class="small bold">sourcebase &larr; sourcebase</span></div>
<div class="line left">
<span class="small bold">sourceraster  </span><span class="small">[⇑sourceraster]</span></div>
<div class="line left">
<span class="small bold">sourceraster &larr; sourceraster</span></div>
<div class="line left">
<span class="small bold">sourcex  </span><span class="small">[⇑sourcex]</span></div>
<div class="line left">
<span class="small bold">sourcex &larr; sourcex</span></div>
<div class="line left">
<span class="small bold">sourcey  </span><span class="small">[⇑sourcey]</span></div>
<div class="line left">
<span class="small bold">sourcey &larr; sourcey</span></div>
<div class="line left">
<span class="small bold">source &larr; pt </span><span class="small">[sourcex&larr; pt x.  sourcey &larr; pt y]</span></div>
<div class="line left">
<span class="small bold">sstrike </span><span class="small">[⇑sstrike]<br></span></div>
<div class="line left">
<span class="small bold">sstrike &larr; sstrike<br></span></div>
<div class="line left">
<span class="small bold">width  </span><span class="small">[⇑width]</span></div>
<div class="line left">
<span class="small bold">width &larr; width</span></div>
<div class="line left">
<span class="medium bold"><br>Setup</span></div>
<div class="line left">
<span class="small bold">classInit <br></span><span class="tab"></span><span class="small">[pageOneCursor &larr; 0431. "location of hardware cursor"<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">forCursor<br></span><span class="tab"></span><span class="small">[function&larr; color&larr; 0.<br></span><span class="tab"></span><span class="small">destbase&larr; sourcebase&larr; 0431.<br></span><span class="tab"></span><span class="small">width&larr; height&larr; 16. destraster&larr; sourceraster&larr; 1.<br></span><span class="tab"></span><span class="small">destx&larr; desty&larr; sourcex&larr; sourcey&larr; 0. sstrike &larr; dstrike &larr; false<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">init <br></span><span class="tab"></span><span class="small">[function &larr; color &larr; destbase &larr; destraster &larr; destx &larr; desty &larr; width &larr;<br></span><span class="tab"></span><span class="small">height &larr; sourcebase &larr; sourceraster &larr; sourcex &larr; sourcey &larr; 0. sstrike &larr; dstrike &larr; false<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="medium bold"><br>Operations</span></div>
<div class="line left">
<span class="small bold">callBLT<br></span><span class="tab"></span><span class="small">[user croak]  primitive: 33</span></div>
<div class="line left">
<span class="small bold">checksandcall </span><span class="small">| destlocked sourcelocked</span><span class="tab"></span><span class="small"><br></span><span class="tab"></span><span class="small">[</span><span class="small italic">"checks if either base a string and/or strike and locks accordingly"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">function &larr; function land: 017.</span><span class="tab"></span><span class="tab"></span><span class="small italic">"set up function to add XM stuff"</span><span class="small"><br></span><span class="tab"></span><span class="small">[destbase class ≡ String ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[destbase◦1 &larr; destbase◦1.  "set the dirty bit"<br></span><span class="tab"></span><span class="tab"></span><span class="small">destlocked &larr; destbase.<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">destbase &larr; ([dstrike ⇒ [((destlocked lock) + 9)]<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">destlocked lock</span><span class="tab"></span><span class="small"> </span><span class="small italic">"strike header"</span><span class="small">])<br></span><span class="tab"></span><span class="tab"></span><span class="small">]<br></span><span class="tab"></span><span class="small">[destbase ≠ pageOneCursor ⇒<br></span><span class="tab"></span><span class="small">[function &larr; function + 020. </span><span class="small italic">"dest not string, then must be in display"</span><span class="small">]</span><span class="small italic"><br></span><span class="tab"></span><span class="tab"></span><span class="small italic">"unless doing cursor work in page one location"</span><span class="small">]<br></span><span class="tab"></span><span class="small">].<br></span><span class="tab"></span><span class="small">[sourcebase class ≡ String ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[sourcelocked &larr; sourcebase.<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">sourcebase &larr; ([sstrike ⇒ [((sourcelocked lock) + 9)]<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">sourcelocked lock</span><span class="tab"></span><span class="small"> </span><span class="small italic">"strike header"</span><span class="small">])<br></span><span class="tab"></span><span class="tab"></span><span class="small">]<br></span><span class="tab"></span><span class="small">[sourcebase ≠ pageOneCursor ⇒<br></span><span class="tab"></span><span class="small">[function &larr; function + 040. </span><span class="small italic">"source not string, then must be in display"</span><span class="small">]</span><span class="small italic"><br></span><span class="tab"></span><span class="tab"></span><span class="small italic">"unless doing cursor work in page one location"</span><span class="small">]<br></span><span class="tab"></span><span class="small">].<br></span><span class="tab"></span><span class="small">self callBLT.<br></span><span class="tab"></span><span class="small">[destlocked ≡ nil ⇒ [] destbase &larr; destlocked unlock].<br></span><span class="tab"></span><span class="small">[sourcelocked ≡ nil ⇒ [] sourcebase &larr; sourcelocked unlock].<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">copy: mode <br></span><span class="tab"></span><span class="small">[function &larr; mode land: 3. self checksandcall]</span></div>
<div class="line left">
<span class="small bold">copycomp: mode <br></span><span class="tab"></span><span class="small">[function &larr; 4 + (mode land: 3). self checksandcall]</span></div>
<div class="line left">
<span class="small bold">fill: mode color: color <br></span><span class="tab"></span><span class="small">[function &larr; 12 + (mode land: 3). self checksandcall]</span></div>
<div class="line left">
<span class="small bold">paint: mode <br></span><span class="tab"></span><span class="small">[function &larr; 8 + (mode land: 3). self checksandcall]</span></div>
<div class="line left">
<span class="small bold">stringCopy: deststring from: start to: stop with: replacement from: rstart to: rstop<br></span><span class="tab"></span><span class="small">["copies equal subranges from one string to another.<br></span><span class="tab"></span><span class="small">works for BitBlt parameters up to 4096. maybe too much set up for short strings.<br></span><span class="tab"></span><span class="small">currently, called by </span><span class="small bold">String copy:to:with:from:to:</span><span class="small">"<br></span><span class="tab"></span><span class="tab"></span><span class="small"><br></span><span class="tab"></span><span class="small">width &larr; 1+stop-start.<br></span><span class="tab"></span><span class="small">width = 0⇒ [⇑deststring]<br><br></span><span class="tab"></span><span class="small">(start &gt; 4096 or⦂ rstart &gt; 4096) or⦂ width ≥ 4096⇒ [⇑false]<br></span><span class="tab"></span><span class="small">(width &lt; 0 or⦂ width ≠ (1+rstop-rstart)) or⦂ (<br></span><span class="tab"></span><span class="tab"></span><span class="small">(start &lt; 1 or⦂ stop &gt; deststring length) or⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">(rstart &lt; 1 or⦂ rstop &gt; replacement length))⇒ [<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">user notify: &rsquo;illegal range or subscript&rsquo;]<br><br></span><span class="tab"></span><span class="small">"self init."<br></span><span class="tab"></span><span class="small">function &larr; color &larr; destraster &larr; desty &larr; sourceraster &larr; sourcey &larr; 0.<br></span><span class="tab"></span><span class="small">sstrike &larr; dstrike &larr; false.<br></span><span class="tab"></span><span class="small">height &larr; 1.<br><br></span><span class="tab"></span><span class="small">width &larr; width*8.<br></span><span class="tab"></span><span class="small">destbase &larr; deststring lock. <br></span><span class="tab"></span><span class="small">destx &larr; (start - 1) * 8.<br></span><span class="tab"></span><span class="small">sourcebase &larr; replacement lock.<br></span><span class="tab"></span><span class="small">sourcex &larr; (rstart - 1) * 8.<br><br></span><span class="tab"></span><span class="small">self callBLT.<br><br></span><span class="tab"></span><span class="small">replacement unlock.<br></span><span class="tab"></span><span class="small">"mark dirty"<br></span><span class="tab"></span><span class="small">deststring◦1 &larr; deststring◦1.<br></span><span class="tab"></span><span class="small">deststring unlock.<br></span><span class="tab"></span><span class="small">⇑deststring<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">stringReplace: deststring with: sourcestring from: start to: stop and: replacement from: rstart to: rstop </span><span class="small">| slock [<br></span><span class="tab"></span><span class="small">"works for BitBlt parameters less than 4096. replaces a subrange of a string.<br></span><span class="tab"></span><span class="small">called only by </span><span class="small bold">String replace:to:by:from:to:</span><span class="small">.  concatenates into deststring:<br></span><span class="tab"></span><span class="tab"></span><span class="small">sourcestring◦(1 to: start-1)<br></span><span class="tab"></span><span class="tab"></span><span class="small">replacement◦(rstart to: rstop)<br></span><span class="tab"></span><span class="tab"></span><span class="small">sourcestring◦(stop+1 to: sourcestring length).<br></span><span class="tab"></span><span class="small">assumes String arguments"<br><br></span><span class="tab"></span><span class="small">deststring length = 0⇒ [⇑deststring]<br><br></span><span class="tab"></span><span class="small">(replacement is: String)≡false⇒[⇑false]<br></span><span class="tab"></span><span class="small">(stop ≥ 4096 or⦂ sourcestring length - stop ≥ 4096) or⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">(start+rstop-rstart ≥ 4096 or⦂ rstart &gt; 4096)⇒ [⇑false]<br><br></span><span class="tab"></span><span class="small">(start &lt; 1 or⦂ stop &gt; sourcestring length) or⦂<br></span><span class="tab"></span><span class="small">(rstart &lt; 1 or⦂ rstop &gt; replacement length)⇒ [user notify: &rsquo;illegal subscript&rsquo;]<br><br></span><span class="tab"></span><span class="small">"self init."<br></span><span class="tab"></span><span class="small">function &larr; color &larr; destraster &larr; desty &larr; sourceraster &larr; sourcey &larr; 0.<br></span><span class="tab"></span><span class="small">sstrike &larr; dstrike &larr; false.<br></span><span class="tab"></span><span class="small">height &larr; 1.<br><br></span><span class="tab"></span><span class="small">destbase &larr; deststring lock. <br></span><span class="tab"></span><span class="small">sourcebase &larr; slock &larr; sourcestring lock.<br></span><span class="tab"></span><span class="small">width &larr; (start - 1) * 8.<br></span><span class="tab"></span><span class="small">[width = 0⇒ []<br></span><span class="tab"></span><span class="small">sourcex &larr; destx &larr; 0.<br></span><span class="tab"></span><span class="small">self callBLT].<br><br></span><span class="tab"></span><span class="small">destx &larr; width.<br></span><span class="tab"></span><span class="small">width &larr; (1+rstop-rstart)*8.<br></span><span class="tab"></span><span class="small">[width = 0⇒ []<br></span><span class="tab"></span><span class="small">sourcex &larr; (rstart - 1) * 8.<br></span><span class="tab"></span><span class="small">sourcebase &larr; replacement lock.<br></span><span class="tab"></span><span class="small">self callBLT.<br></span><span class="tab"></span><span class="small">replacement unlock].<br><br></span><span class="tab"></span><span class="small">destx &larr; destx+ width.<br></span><span class="tab"></span><span class="small">width &larr; (sourcestring length - stop) * 8.<br></span><span class="tab"></span><span class="small">[width = 0⇒ []<br></span><span class="tab"></span><span class="small">sourcebase &larr; slock.<br></span><span class="tab"></span><span class="small">sourcex &larr; stop * 8.<br></span><span class="tab"></span><span class="small">self callBLT].<br><br></span><span class="tab"></span><span class="small">deststring◦1 &larr; deststring◦1.<br></span><span class="tab"></span><span class="small">sourcestring unlock. deststring unlock.<br></span><span class="tab"></span><span class="small">⇑deststring<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="small"></span></div>
<div class="line left">
<span class="small">SystemOrganization classify: ↪BitBlt under: &rsquo;Primitive Access&rsquo;.</span></div>
<div class="line left">
<span class="small">BitBlt classInit</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"CoreLocs"</span></div>
<div class="line left">
<span class="medium bold">Class new title: &rsquo;CoreLocs&rsquo;<br></span><span class="tab"></span><span class="medium bold">subclassof: Array<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;base length&rsquo;<br></span><span class="tab"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab"></span><span class="medium bold">asFollows</span></div>
<div class="line left">
<span class="small italic"><br>I am an array mapping a section of Alto memory</span></div>
<div class="line left">
<span class="medium bold"><br>Initialization</span></div>
<div class="line left">
<span class="small bold">base: base length: length</span></div>
<div class="line left">
<span class="medium bold"><br>Reading and Writing</span></div>
<div class="line left">
<span class="small bold">◦ x </span><span class="small">[x isLarge⇒[⇑self◦(x asSmall)] user croak] primitive: 42</span></div>
<div class="line left">
<span class="small bold">◦ x &larr; val </span><span class="small">[x isLarge⇒[⇑self◦(x asSmall) &larr; val] user croak] primitive: 43</span></div>
<div class="line left">
<span class="small bold">base </span><span class="small">[⇑base]</span></div>
<div class="line left">
<span class="small bold">length </span><span class="small">[⇑length]</span></div>
<div class="line left">
<span class="small"></span></div>
<div class="line left">
<span class="small">SystemOrganization classify: ↪CoreLocs under: &rsquo;Primitive Access&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"VirtualMemory"</span></div>
<div class="line left">
<span class="medium bold">Class new title: &rsquo;VirtualMemory&rsquo;<br></span><span class="tab"></span><span class="medium bold">subclassof: Object<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;map "Pclass Map"<br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">premap "block before map"<br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">FirstContextOop "oop of FirstContext"<br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">SpecialOopsOop "oop of SpecialOops"<br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">zip  "Zone Index of Pages"<br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">prezip  "block before zip"<br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">zadd   "file info"<br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">vmemfile "file for vmem" &rsquo;<br></span><span class="tab"></span><span class="medium bold">declare: &rsquo;ZHB RCI PIN zfused zfree zjmpt pmint num00 pmend ZN zflen pmatm zlong PCL ZVPN CPT BSC ISC ZJMP zend &rsquo;;<br></span><span class="tab"></span><span class="medium bold">asFollows</span></div>
<div class="line left">
<span class="small italic"><br>A model of the OOZE virtual memory</span></div>
<div class="line left">
<span class="medium bold"><br>Pclass Map</span></div>
<div class="line left">
<span class="small bold">CPT: oop </span><span class="small">| poma<br></span><span class="tab"></span><span class="small">[poma &larr; 2*(oop field: PCL) +1.<br></span><span class="tab"></span><span class="small">⇑map◦poma field: CPT]</span></div>
<div class="line left">
<span class="small bold">freelist: object  </span><span class="small">| a<br></span><span class="tab"></span><span class="small">[</span><span class="small italic">"one-order index into freelists."</span><span class="small"><br></span><span class="tab"></span><span class="small">object class is: Class ⇒[⇑1]<br></span><span class="tab"></span><span class="small">a &larr; self ISC: object asOop.<br></span><span class="tab"></span><span class="small">a &lt; 024 ⇒[⇑1+a] ⇑1+ a-013]</span></div>
<div class="line left">
<span class="small bold">freelistOffset: len </span><span class="small italic">"offset of freelist for this length in a variable length class"</span><span class="small"><br></span><span class="tab"></span><span class="small">[⇑Class instsize + [len &lt; 9 ⇒[len] (len-1) log2 + 6]]<br></span></div>
<div class="line left">
<span class="small bold">highpm0: oop gets: val </span><span class="small">| poma<br></span><span class="tab"></span><span class="small">[premap◦pmatm &larr; premap◦pmatm min: (oop field: PIN &larr; 0).<br></span><span class="tab"></span><span class="small">poma &larr; 2*(oop field: PCL) +1.<br></span><span class="tab"></span><span class="small">map◦poma &larr; val]</span></div>
<div class="line left">
<span class="small bold">highPM: oop </span><span class="small">| pcl a<br></span><span class="tab"></span><span class="small">[pcl &larr; oop field: PCL.<br></span><span class="tab"></span><span class="small">a &larr; premap◦pmatm field: PCL.<br></span><span class="tab"></span><span class="small">pcl &lt; a ⇒[⇑false]<br></span><span class="tab"></span><span class="small">⇑map◦(2*pcl +1)]</span></div>
<div class="line left">
<span class="small bold">ISC: oop </span><span class="small">| poma<br></span><span class="tab"></span><span class="small">[poma &larr; 2*(oop field: PCL) +1.<br></span><span class="tab"></span><span class="small">⇑map◦poma field: ISC]</span></div>
<div class="line left">
<span class="small bold">lowPM: oop </span><span class="small">| pcl a<br></span><span class="tab"></span><span class="small">[pcl &larr; oop field: PCL.<br></span><span class="tab"></span><span class="small">a &larr; premap◦pmend field: PCL.<br></span><span class="tab"></span><span class="small">pcl ≥ a ⇒[⇑false]<br></span><span class="tab"></span><span class="small">⇑map◦(2*pcl +1)]</span></div>
<div class="line left">
<span class="small bold">newHighPM&larr; pm0 </span><span class="small">| pcl a<br></span><span class="tab"></span><span class="small">[a &larr; premap◦pmatm.<br></span><span class="tab"></span><span class="small">premap◦pmatm &larr; (a &larr; a-0200).<br></span><span class="tab"></span><span class="small">pcl &larr; a field: PCL.<br></span><span class="tab"></span><span class="small">map◦(2*pcl +1) &larr; pm0.<br></span><span class="tab"></span><span class="small">⇑a]</span></div>
<div class="line left">
<span class="small bold">newLowPM&larr; pm0 </span><span class="small">| poma a<br></span><span class="tab"></span><span class="small">[map◦1 = pm0 ⇒[</span><span class="small italic">"reserved pclasses for Class"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">map◦3 = 0 ⇒[map◦3 &larr; pm0. ⇑0200]<br></span><span class="tab"></span><span class="tab"></span><span class="small">map◦5 = 0 ⇒[map◦5 &larr; pm0. ⇑0400] ]<br></span><span class="tab"></span><span class="small italic">"normal case"</span><span class="small"><br></span><span class="tab"></span><span class="small">a &larr; premap◦pmend.<br></span><span class="tab"></span><span class="small">premap◦pmend &larr; a+0200.<br></span><span class="tab"></span><span class="small">poma &larr; (a field: PCL) *2 +1.<br></span><span class="tab"></span><span class="small">map◦poma ≠ 0 ⇒[</span><span class="small italic">"skip over already filled"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">⇑self newLowPM&larr; pm0]<br></span><span class="tab"></span><span class="small">map◦poma &larr; pm0.<br></span><span class="tab"></span><span class="small">⇑a]</span></div>
<div class="line left">
<span class="small bold">newZN: oop <br></span><span class="tab"></span><span class="small">[self ZN: oop gets: self newZone]</span></div>
<div class="line left">
<span class="small bold">pclassesOf: cls </span><span class="small">| i clsoop n z p </span><span class="small italic">"find pclasses of this class (in order of ZHB)"</span><span class="small"><br></span><span class="tab"></span><span class="small">[</span><span class="small italic">"ignore small integers and nil"</span><span class="small"><br></span><span class="tab"></span><span class="small">p &larr; (Vector new: 1) asStream.<br></span><span class="tab"></span><span class="small">z &larr; (Vector new: 1) asStream.<br></span><span class="tab"></span><span class="small">clsoop &larr; cls asOop.<br></span><span class="tab"></span><span class="small">for⦂ i from: (1 to: 2*(0174000 field: PCL) by: 2) do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[map◦i = 0 ⇒[]<br></span><span class="tab"></span><span class="tab"></span><span class="small">(map◦i field: RCI) = clsoop ⇒[p next&larr; i/2. z next&larr; (map◦(i+1) field: ZHB)]].<br></span><span class="tab"></span><span class="small">p &larr; p contents. z &larr; z contents.<br></span><span class="tab"></span><span class="small">n &larr; p copy.<br></span><span class="tab"></span><span class="small">for⦂ i to: z length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[n◦(z◦i +1) &larr; p◦i].<br></span><span class="tab"></span><span class="small">⇑n]</span></div>
<div class="line left">
<span class="small bold">pclassesOf: cls length: len </span><span class="small">| i clsoop n z p isc pm0 </span><span class="small italic">"find pclasses of this class and length (in order of ZHB)"</span><span class="small"><br></span><span class="tab"></span><span class="small">[</span><span class="small italic">"ignore small integers and nil"</span><span class="small"><br></span><span class="tab"></span><span class="small">p &larr; (Vector new: 1) asStream.<br></span><span class="tab"></span><span class="small">z &larr; (Vector new: 1) asStream.<br></span><span class="tab"></span><span class="small">isc &larr; [len &lt; 9 ⇒[len] (len-1) log2 + 17].<br></span><span class="tab"></span><span class="small">clsoop &larr; cls asOop.<br></span><span class="tab"></span><span class="small">for⦂ i from: (1 to: 2*(0174000 field: PCL) by: 2) do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[(pm0 &larr; map◦i) = 0 ⇒[]<br></span><span class="tab"></span><span class="tab"></span><span class="small">(pm0 field: RCI) ≠ clsoop ⇒[]<br></span><span class="tab"></span><span class="tab"></span><span class="small">(pm0 field: ISC) = isc ⇒[p next&larr; i/2. z next&larr; (map◦(i+1) field: ZHB)]].<br></span><span class="tab"></span><span class="small">p &larr; p contents. z &larr; z contents.<br></span><span class="tab"></span><span class="small">n &larr; p copy.<br></span><span class="tab"></span><span class="small">for⦂ i to: z length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[n◦(z◦i +1) &larr; p◦i].<br></span><span class="tab"></span><span class="small">⇑n]</span></div>
<div class="line left">
<span class="small bold">pmatm </span><span class="small">[⇑premap◦pmatm]</span></div>
<div class="line left">
<span class="small bold">ZHB: oop </span><span class="small">| poma<br></span><span class="tab"></span><span class="small">[poma &larr; 2*(oop field: PCL) +1.<br></span><span class="tab"></span><span class="small">⇑map◦(1+poma) field: ZHB]</span></div>
<div class="line left">
<span class="small bold">ZHB: oop gets: val </span><span class="small">| poma i<br></span><span class="tab"></span><span class="small">[poma &larr; 2*(oop field: PCL) +1.<br></span><span class="tab"></span><span class="small">i &larr; map◦(1+poma).<br></span><span class="tab"></span><span class="small">map◦(1+poma) &larr; (i field: ZHB &larr; val)]</span></div>
<div class="line left">
<span class="small bold">ZN: oop </span><span class="small">| poma<br></span><span class="tab"></span><span class="small">[poma &larr; 2*(oop field: PCL) +1.<br></span><span class="tab"></span><span class="small">⇑map◦(1+poma) field: ZN]</span></div>
<div class="line left">
<span class="small bold">ZN: oop gets: val </span><span class="small">| poma i<br></span><span class="tab"></span><span class="small">[poma &larr; 2*(oop field: PCL) +1.<br></span><span class="tab"></span><span class="small">i &larr; map◦(1+poma).<br></span><span class="tab"></span><span class="small">map◦(1+poma) &larr; (i field: ZN &larr; val)]</span></div>
<div class="line left">
<span class="medium bold"><br>Writing and Reading</span></div>
<div class="line left">
<span class="small bold">obwiz: oop </span><span class="small">| poma pm0 pm1 isc bsc i len zz pin zhb<br></span><span class="tab"></span><span class="small">[</span><span class="small italic">"find (zn, zp, zw, dlen)"</span><span class="small"><br></span><span class="tab"></span><span class="small">zz &larr; Vector new: 4.<br></span><span class="tab"></span><span class="small">poma &larr; (oop field: PCL)*2 +1.<br></span><span class="tab"></span><span class="small">(pm0 &larr; map◦poma) = 0 ⇒ [user notify: &rsquo;bad oop&rsquo;]<br></span><span class="tab"></span><span class="small">pm1 &larr; map◦(1+poma).<br></span><span class="tab"></span><span class="small">isc &larr; pm0 field: ISC.<br></span><span class="tab"></span><span class="small">bsc &larr; pm0 field: BSC.<br></span><span class="tab"></span><span class="small">zhb &larr; pm1 field: ZHB.<br></span><span class="tab"></span><span class="small">[isc &lt; 024 ⇒[len &larr; ((isc max: 1)+ 1-bsc) / (2-bsc)]<br></span><span class="tab"></span><span class="tab"></span><span class="small">len &larr; 8. i &larr; isc+bsc.<br></span><span class="tab"></span><span class="tab"></span><span class="small">until⦂ 024 = i do⦂ [i &larr; i-1. len &larr; len*2]<br></span><span class="tab"></span><span class="tab"></span><span class="small">len &larr; len+1 </span><span class="small italic">"length word"</span><span class="small"> ].<br></span><span class="tab"></span><span class="small">zz◦4 &larr; len &larr; len+1. </span><span class="small italic">"dlen with refct"</span><span class="small"><br></span><span class="tab"></span><span class="small italic">"w &larr; (dlen*128*zhb) +dlen*pin"</span><span class="small"><br></span><span class="tab"></span><span class="small">pin &larr; oop field: PIN.<br></span><span class="tab"></span><span class="small">zz◦2 </span><span class="small italic">"zp"</span><span class="small"> &larr; (zhb/2 *len) +(len/256 *pin).<br></span><span class="tab"></span><span class="small">zz◦3 </span><span class="small italic">"zw"</span><span class="small"> &larr; (zhb\2 *128 *len) +(len\256 *pin).<br></span><span class="tab"></span><span class="small">zhb\2 * len ≥ 512 ⇒[user notify: &rsquo;address overflow&rsquo;]<br></span><span class="tab"></span><span class="small">zz◦2 </span><span class="small italic">"zp"</span><span class="small"> &larr; zz◦2 + (zz◦3 field: 136 </span><span class="small italic">"highbyte"</span><span class="small">).<br></span><span class="tab"></span><span class="small">zz◦3 </span><span class="small italic">"zw"</span><span class="small"> &larr; zz◦3 field: 128 </span><span class="small italic">"lowbyte"</span><span class="small">.<br></span><span class="tab"></span><span class="small">zz◦1 &larr; pm1 field: ZN.<br></span><span class="tab"></span><span class="small">⇑zz]</span></div>
<div class="line left">
<span class="small bold">readin: oop </span><span class="small">| zinfo<br></span><span class="tab"></span><span class="small">[zinfo &larr; self obwiz: oop.<br></span><span class="tab"></span><span class="small">⇑self read: zinfo◦4 at: zinfo]</span></div>
<div class="line left">
<span class="small bold">systemNoHistory </span><span class="small">[] primitive: 82</span></div>
<div class="line left">
<span class="small bold">writeout: oop with: image </span><span class="small">| zinfo<br></span><span class="tab"></span><span class="small">[zinfo &larr; self obwiz: oop.<br></span><span class="tab"></span><span class="small">[zinfo◦4 ≥ (image length /2) ⇒[]<br></span><span class="tab"></span><span class="tab"></span><span class="small">user notify: &rsquo;bad image length&rsquo;].<br></span><span class="tab"></span><span class="small">self write: image at: zinfo<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="medium bold"><br>Init</span></div>
<div class="line left">
<span class="small bold">AComment<br></span><span class="tab"></span><span class="small">[</span><span class="small italic">"VirtualMemory models the Pclass Map of Ooze.<br></span><span class="tab"></span><span class="small italic">Vmem is one with CoreLocs on real system.<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">(VirtualMemory new) thisvmem.<br></span><span class="tab"></span><span class="small italic">Pmap is new one we are building.<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">(VirtualMemory new) fakevmem.<br></span><span class="tab"></span><span class="small italic">map is 1-order addressing.<br></span><span class="tab"></span><span class="small italic">In init, set pmatm by searching PM for<br></span><span class="tab"></span><span class="small italic">highest 0. (No LMAT)<br></span><span class="tab"></span><span class="small italic">map RCI field is old class oop. only convert to <br></span><span class="tab"></span><span class="tab"></span><span class="small italic">new with mapPM at end.<br></span><span class="tab"></span><span class="small italic">Atoms may not cover more than half of the<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">address space. (highpm0:gets:)<br></span><span class="tab"></span><span class="small italic">(VirtualMemory new) giveBirth.<br></span><span class="tab"></span><span class="small italic">Zone Index of Pages. works for both vector zip<br></span><span class="tab"></span><span class="small italic">and corelocs of real zip.<br></span><span class="tab"></span><span class="small italic">zip, zadd are one-order.<br></span><span class="tab"></span><span class="small italic">zfree is 1-order in fake, core addr in this.<br></span><span class="tab"></span><span class="small italic">zlong = 512.<br></span><span class="tab"></span><span class="small italic">zend is not used (0 fake, core addr in this) <br></span><span class="tab"></span><span class="small italic">"</span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">fakevmem: vmemfile<br></span><span class="tab"></span><span class="small">[</span><span class="small italic">"this instance is a model of a new vmem, which is built on another file"</span><span class="small"><br></span><span class="tab"></span><span class="small">self init.<br></span><span class="tab"></span><span class="small">map &larr; Vector new: 1024.<br></span><span class="tab"></span><span class="small">map all &larr; 0.<br></span><span class="tab"></span><span class="small">premap &larr; (0176000, 0174000, 0, 0).<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small italic">"num00, pmint, pmatm, pmend"</span><span class="small"><br></span><span class="tab"></span><span class="small">prezip &larr; (3, 01244, 0). </span><span class="small italic">"zfree, zlong, zend"</span><span class="small"><br></span><span class="tab"></span><span class="small">zip &larr; Vector new: prezip◦zlong.<br></span><span class="tab"></span><span class="small">zip all &larr; 0.<br></span><span class="tab"></span><span class="small">zadd &larr; (1, 1).  </span><span class="small italic">"zfused, zflen"</span><span class="small"><br></span><span class="tab"></span><span class="small">vmemfile readwrite.<br></span><span class="tab"></span><span class="small">Smalltalk define: ↪Pmap as: self]</span></div>
<div class="line left">
<span class="small bold">init  </span><span class="small italic">"common to both real and fake vmem"</span><span class="small bold"><br></span><span class="tab"></span><span class="small">[</span><span class="small italic">"field descriptors and indicies in tables"</span><span class="small"><br></span><span class="tab"></span><span class="small">num00 &larr; 1. pmint &larr; 2. pmatm &larr; 3. pmend &larr; 4.<br></span><span class="tab"></span><span class="small">RCI &larr; 151. CPT &larr; 22. BSC &larr; 21. ISC &larr; 80.<br></span><span class="tab"></span><span class="small">ZHB &larr; 136. ZN &larr; 128. <br></span><span class="tab"></span><span class="small">PCL &larr; 151. PIN &larr; 112.<br></span><span class="tab"></span><span class="small">ZJMP &larr; 76. ZVPN &larr; 16*12.<br></span><span class="tab"></span><span class="small">zfree &larr; 1. zlong &larr; 2. zend &larr; 3.<br></span><span class="tab"></span><span class="small">zfused &larr; 1. zflen &larr; 2.<br></span><span class="tab"></span><span class="small">zjmpt &larr; (603, 570, 471, 410, 353, 300, 253, <br></span><span class="tab"></span><span class="tab"></span><span class="small">210, 169, 132, 101, 72, 49, 30, 13)]</span></div>
<div class="line left">
<span class="small bold">premap </span><span class="small">[⇑premap] </span><span class="small italic">"array of limits in Pclass Map"</span></div>
<div class="line left">
<span class="small bold">thisvmem </span><span class="small">| c m "create Vmem, a VirtualMemory viewing this very system"<br></span><span class="tab"></span><span class="small">[c &larr; self specialLocs.<br></span><span class="tab"></span><span class="small">map &larr; CoreLocs new base: c◦2 -1 length: 1025.<br></span><span class="tab"></span><span class="small">premap &larr; CoreLocs new base: c◦2 -5 length: 5.<br></span><span class="tab"></span><span class="small">Smalltalk define: ↪Vmem  as: self.<br></span><span class="tab"></span><span class="small">self init.<br></span><span class="tab"></span><span class="small">m &larr; 1023.<br></span><span class="tab"></span><span class="small">until⦂ (map◦m = 0) do⦂ [m &larr; m-2].<br></span><span class="tab"></span><span class="small">premap◦pmatm &larr; (0 field: PCL &larr; m/2 +1).<br></span><span class="tab"></span><span class="small">prezip &larr; CoreLocs new base: c◦3 -4 length: 4.<br></span><span class="tab"></span><span class="small">zip &larr; CoreLocs new base: c◦3 -1 length: prezip◦zlong+1.<br></span><span class="tab"></span><span class="small">zadd &larr; CoreLocs new base: c◦12 -3 length: 3.<br></span><span class="tab"></span><span class="small">(vmemfile &larr; dp0 oldFile: &rsquo;small.boot&rsquo;) readonly.<br></span><span class="tab"></span><span class="small">FirstContext &larr; Context new sender: nil <br></span><span class="tab"></span><span class="tab"></span><span class="small">receiver: user<br></span><span class="tab"></span><span class="tab"></span><span class="small">method: (m &larr; UserView md method: ↪restart) <br></span><span class="tab"></span><span class="tab"></span><span class="small">tempframe: (Vector new: (m◦3 max: m◦4)) pc: m◦6<br></span><span class="tab"></span><span class="tab"></span><span class="small">stackptr: m◦5 -1.<br></span><span class="tab"></span><span class="small">SpecialOops◦1 &larr; Object md method: ↪error.<br></span><span class="tab"></span><span class="small">FirstContextOop &larr; FirstContext asOop.<br></span><span class="tab"></span><span class="small">SpecialOopsOop &larr; SpecialOops asOop]</span></div>
<div class="line left">
<span class="medium bold"><br>Vmem Writing</span></div>
<div class="line left">
<span class="small bold">afterBirth </span><span class="small">[MethodKeeperKeeper &larr; nil]</span></div>
<div class="line left">
<span class="small bold">giveBirth </span><span class="small">| pm0 vm </span><span class="small italic">"initialize map for early pclasses"</span><span class="small"><br></span><span class="tab"></span><span class="small">[self preBirth.<br></span><span class="tab"></span><span class="small italic">"small Integer, 16 pclasses, oops 0174000-0177777"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">pm0 &larr; Vmem highPM: 0176000. </span><span class="small italic">"size, class info for Integer"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">until⦂ (Pmap newHighPM&larr; pm0) = 0174000 do⦂ []. <br></span><span class="tab"></span><span class="small italic">"first UniqueString"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">(vm &larr; Vmapper new) object: (0173600 asObject); touchoop.<br></span><span class="tab"></span><span class="small italic">"Class oops 0-0177"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">vm object: Class; touchoop.<br></span><span class="tab"></span><span class="small italic">"more Class oops 0200-0577"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">Pmap newLowPM&larr; 0; newLowPM&larr; 0.<br></span><span class="tab"></span><span class="small italic">"VariableLengthClass oops 0600-0777"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">vm object: Vector; touchoop.<br></span><span class="tab"></span><span class="small italic">"skip over some oops"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">until⦂ (Pmap newLowPM&larr; 0) = 01600 do⦂ [].<br></span><span class="tab"></span><span class="small italic">"Object oops 02000-02177, false=02000"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">(vm object: false) map ≠ 02000 ⇒[user notify: &rsquo;bad false oop&rsquo;]<br></span><span class="tab"></span><span class="small italic">"set pointer back to oops skipped over"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">Pmap premap ◦ pmend &larr; 01000<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">giveBirth2 </span><span class="small">| vm<br></span><span class="tab"></span><span class="small">[vm &larr; Vmapper new.<br></span><span class="tab"></span><span class="small">vm object: (Smalltalk ref: ↪FirstContext).<br></span><span class="tab"></span><span class="small">FirstContextOop &larr; (vm readin word: 2). </span><span class="small italic">"new oop of FirstContext"</span><span class="small"><br></span><span class="tab"></span><span class="small">vm reset; object: (Smalltalk ref: ↪SpecialOops).<br></span><span class="tab"></span><span class="small">SpecialOopsOop &larr; (vm readin word: 2). </span><span class="small italic">"new oop of SpecialOops"</span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">giveBirth3 </span><span class="small">| vm p [</span><span class="small italic">"create a new Small.boot<br></span><span class="tab"></span><span class="small italic">Write out all objects rooted at Smalltalk.<br></span><span class="tab"></span><span class="small italic">Do not write the stack (rooted in R76, the current context).<br></span><span class="tab"></span><span class="tab"></span><span class="small">Pmap file close. Pmap &larr; nil.<br><br></span><span class="tab"></span><span class="small italic">*** Below is the commmand to start a Vmem write on a Dorado<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">(or Alto -- double disk O.S.).  edit and recompile the method if you don&rsquo;t<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">want to use old UniqueStrings, or if newsmall.boot, smalltalk.run,<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">smalltalk.syms, byterp.mb are not located on dp0i,<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">i.e. dp1 oldFile: &rsquo;small.boot&rsquo; instead of dp0 oldFile: &rsquo;newsmall.boot&rsquo;.<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">also delete rename: commands at the end.<br></span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">user displayoffwhile⦂ [(VirtualMemory new) giveBirth3]. user quit.<br><br></span><span class="tab"></span><span class="small">***"<br><br></span><span class="tab"></span><span class="small">user releaseExternalViews.<br></span><span class="tab"></span><span class="small">[E≡nil⇒ [] E kill].<br></span><span class="tab"></span><span class="small">Flushed&larr; false.<br></span><span class="tab"></span><span class="small">(Vmapper new) init; UseOldUniqueStrings: true.<br></span><span class="tab"></span><span class="small">user show: &rsquo;init &rsquo;.<br></span><span class="tab"></span><span class="small">(VirtualMemory new) thisvmem.  </span><span class="small italic">"define Vmem, Pmap"</span><span class="small"><br></span><span class="tab"></span><span class="small">(VirtualMemory new) fakevmem: (dp0 oldFile: &rsquo;newsmall.boot&rsquo;).<br></span><span class="tab"></span><span class="small">self giveBirth.<br></span><span class="tab"></span><span class="small">vm &larr; Vmapper new.<br></span><span class="tab"></span><span class="small">user show: &rsquo;run &rsquo;. vm object: Smalltalk; map.<br></span><span class="tab"></span><span class="small">user show: &rsquo;USTable &rsquo;. vm arefsRectify.<br></span><span class="tab"></span><span class="small">user show: &rsquo;freelist &rsquo;. vm writefreelists.<br></span><span class="tab"></span><span class="small">user show: &rsquo;mrefs &rsquo;. vm mrefsRectify.<br></span><span class="tab"></span><span class="small">user show: &rsquo;PM &rsquo;. Pmap mapPM; giveBirth2.<br><br></span><span class="tab"></span><span class="small">"</span><span class="small italic">These work as many times as needed on dp0 or dp1</span><span class="small">"<br></span><span class="tab"></span><span class="small">user show: &rsquo;surgery &rsquo;.<br></span><span class="tab"></span><span class="small">Pmap surgery: (dp0 oldFile: &rsquo;Smalltalk.Run&rsquo;).<br></span><span class="tab"></span><span class="small">user show: &rsquo;ram &rsquo;.<br></span><span class="tab"></span><span class="small">Pmap ramwrite: (dp0 oldFile: &rsquo;Byterp.Mb&rsquo;).<br><br></span><span class="tab"></span><span class="small">"</span><span class="small italic">adjust size of new file</span><span class="small">"<br></span><span class="tab"></span><span class="small">p &larr; Pmap pagesUsed + 264 "</span><span class="small italic">boot & ram</span><span class="small">" + 250 "</span><span class="small italic">extra</span><span class="small">".<br></span><span class="tab"></span><span class="small">user show: &rsquo;pages reclaimed &rsquo;; print: (Pmap file) file lastPage - p.<br></span><span class="tab"></span><span class="small">(Pmap file) readwriteshorten; settopage: p char: 0; close; readwrite.<br><br></span><span class="tab"></span><span class="small">"rename files so that new file is small.boot"<br></span><span class="tab"></span><span class="small">(Vmem file) file rename: &rsquo;oldsmall.boot&rsquo;.<br></span><span class="tab"></span><span class="small">(Pmap file) file rename: &rsquo;small.boot&rsquo;.<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">mapPM </span><span class="small">| c i v rci ctrans  </span><span class="small italic">"convert to new RCI"</span><span class="small"><br></span><span class="tab"></span><span class="small">[ctrans &larr; (Vmapper new) classtrans.<br></span><span class="tab"></span><span class="small">for⦂ c from: (1 to: 1023 by: 2) do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[(i &larr; map◦c) = 0 ⇒[]<br></span><span class="tab"></span><span class="tab"></span><span class="small">rci &larr; i field: RCI.<br></span><span class="tab"></span><span class="tab"></span><span class="small">(v &larr; ctrans lookup: rci) ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[map◦c &larr; (i field: RCI &larr; v◦1)]<br></span><span class="tab"></span><span class="tab"></span><span class="small">user notify: &rsquo;class not mapped&rsquo;]<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">preBirth </span><span class="small">| v<br></span><span class="tab"></span><span class="small">[MethodKeeperKeeper &larr; MessageDict new.<br></span><span class="tab"></span><span class="small">MethodKeeperKeeper init: (v &larr; MethodKeeper contents) length *2; holdMethods: v]</span></div>
<div class="line left">
<span class="small bold">ramwrite: source </span><span class="small">| s </span><span class="small italic">"write 8 pages of ram image into small.boot</span><span class="small">" [<br></span><span class="tab"></span><span class="small">s &larr; source name.<br></span><span class="tab"></span><span class="small">source readonly.<br></span><span class="tab"></span><span class="small">[source directory ≡ dp0 ⇒[]<br></span><span class="tab"></span><span class="small">(dp0 file: s) append: source; close "</span><span class="small italic">copy onto dp0</span><span class="small">"].<br></span><span class="tab"></span><span class="small">source close.<br><br></span><span class="tab"></span><span class="small">"</span><span class="small italic">cleanup vmem file before quit</span><span class="small">"<br></span><span class="tab"></span><span class="small">vmemfile close.<br><br></span><span class="tab"></span><span class="small">"</span><span class="small italic">go out to OS, packram, and come back</span><span class="small">"<br></span><span class="tab"></span><span class="small">s &larr; s◦(1 to: s length-4) concat: &rsquo;.br.&rsquo;.<br></span><span class="tab"></span><span class="small">user quitThen: [<br></span><span class="tab"></span><span class="tab"></span><span class="small">(Stream default) append: &rsquo;Packmu &rsquo;;<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">append: source name; space; append: s;<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">append: &rsquo;; Resume &rsquo;; append: Vmem file name;<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">contents].  <br><br></span><span class="tab"></span><span class="small">"</span><span class="small italic">skip .br stuff and constants</span><span class="small">"<br></span><span class="tab"></span><span class="small">(s &larr; dp0 oldFile: s) readonly; skipwords: 0421.<br></span><span class="tab"></span><span class="small">"</span><span class="small italic">now write in ram image (8 pages of 512)</span><span class="small">"<br></span><span class="tab"></span><span class="small">vmemfile settopage: 0400 char: 0; readwrite; next: 4096 from: s.<br></span><span class="tab"></span><span class="small">s close.<br></span><span class="tab"></span><span class="small">self ≡ Vmem ⇒[vmemfile readonly "</span><span class="small italic">does flush</span><span class="small">"]<br></span><span class="tab"></span><span class="small">vmemfile flush]</span></div>
<div class="line left">
<span class="medium bold"><br>Surgery</span></div>
<div class="line left">
<span class="small bold">dynaLocs: guide </span><span class="small">| l locs keys v i "Surgery - add core location and value pairs to guide dictionary to test after flush"<br></span><span class="tab"></span><span class="small">[l &larr; self specialLocs.<br></span><span class="tab"></span><span class="small">locs &larr; (premap base +pmend, (l◦11 -1), (l◦12 -2), (l◦4 +1)).<br></span><span class="tab"></span><span class="small">keys &larr; (↪premaptest, ↪purgetest, ↪zaddtest, ↪loxtest).<br></span><span class="tab"></span><span class="small">for⦂ i from: 1 to: keys length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[v &larr; locs◦i, (mem◦(locs◦i)).<br></span><span class="tab"></span><span class="tab"></span><span class="small">guide insert: keys◦i with: v].<br></span><span class="tab"></span><span class="small">(guide lookup: ↪loxtest)◦2 &larr; ¬1]</span></div>
<div class="line left">
<span class="small bold">runLocs: f </span><span class="small">| guide i v locs keys offsets "Surgery - create dictionary of locations of key system tables in Smalltalk.run"<br></span><span class="tab"></span><span class="small">[i &larr; f name.<br></span><span class="tab"></span><span class="small">(v &larr; f directory oldFile: (i◦(1 to: i length-5) concat: &rsquo;.syms.&rsquo;)) readonly.<br></span><span class="tab"></span><span class="small">locs &larr; self symsFind: (&rsquo;PMBASE&rsquo;, &rsquo;ZIP&rsquo;, &rsquo;ZADD&rsquo;, &rsquo;INITIALIZE&rsquo;, &rsquo;OOZIN&rsquo;, &rsquo;SAFID&rsquo;) on: v.<br></span><span class="tab"></span><span class="small">v close.<br><br></span><span class="tab"></span><span class="small">keys &larr; ↪(maprun ziprun zaddrun initrun zfps safid).<br></span><span class="tab"></span><span class="small">offsets &larr; ↪(¬1 ¬1 ¬3 ¬3 ¬2 ¬1). "words offset"<br></span><span class="tab"></span><span class="small">guide &larr; Dictionary new init: 16.<br></span><span class="tab"></span><span class="small">for⦂ i from: 1 to: locs length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[v &larr; (locs◦i lshift: ¬8), ((locs◦i land: 0377) -19 *2). "page, byte"<br></span><span class="tab"></span><span class="tab"></span><span class="small">"magic fudge factor of 19 words for .run file"<br></span><span class="tab"></span><span class="tab"></span><span class="small">v◦2 &larr; v◦2 +(offsets◦i *2). "bytes offset"<br></span><span class="tab"></span><span class="tab"></span><span class="small">guide insert: keys◦i with: v].<br></span><span class="tab"></span><span class="small">v &larr; (guide lookup: ↪maprun) copy.<br></span><span class="tab"></span><span class="small">v◦2 &larr; v◦2 +(¬4 *2).  "offset ¬5 total"<br></span><span class="tab"></span><span class="small">guide insert: ↪premaprun with: v.<br></span><span class="tab"></span><span class="small">v &larr; (guide lookup: ↪ziprun) copy.<br></span><span class="tab"></span><span class="small">v◦2 &larr; v◦2 +(¬3 *2).  "offset ¬4 total"<br></span><span class="tab"></span><span class="small">guide insert: ↪preziprun with: v.<br></span><span class="tab"></span><span class="small">⇑guide]</span></div>
<div class="line left">
<span class="small bold">specialLocs </span><span class="small">[] primitive: 84<br>"returns a vector containing the core addresses of:<br></span><span class="tab"></span><span class="small">1 ROTBASE (the Resident Object Table)<br></span><span class="tab"></span><span class="small">2 PMBASE (the Pclass Map)<br></span><span class="tab"></span><span class="small">3 ZIP (the Zone Index of Pages)<br></span><span class="tab"></span><span class="small">4 LOX (the table of LOcked objeX)<br></span><span class="tab"></span><span class="small">5 FULL (loc of lowest addr used for resident data)<br></span><span class="tab"></span><span class="small">6 ULIM (loc of highest addr used for resident data)<br></span><span class="tab"></span><span class="small">7 ZFPT (the zone file Page Table)<br></span><span class="tab"></span><span class="small">8 OVTAB (the Table of OVerflow ref counts)<br></span><span class="tab"></span><span class="small">9 PURGE (a code label)<br></span><span class="tab"></span><span class="small">10 DISPGLBS (Table of Display Globals)<br></span><span class="tab"></span><span class="small">11 BACPUR (a code label)<br></span><span class="tab"></span><span class="small">12 ZADD (.-2 has #pages req&rsquo;d, .-1 has #pages in boot file; add 264 for real file length)<br></span><span class="tab"></span><span class="small">13 SAFID (loc of file id (5-word block) for the .boot file)<br>"</span></div>
<div class="line left">
<span class="small bold">staticTest: guide on: f </span><span class="small">| l locs offsets values names i v "Surgery - test known static constants in thisvmem and in smalltalk.run"<br></span><span class="tab"></span><span class="small">[offsets &larr; (pmint, 2, 0, 0).<br></span><span class="tab"></span><span class="small">values &larr; (0174000, 01244, 96, 031415).<br></span><span class="tab"></span><span class="small">names &larr; (↪premaprun, ↪preziprun, ↪zaddrun, ↪initrun).<br></span><span class="tab"></span><span class="small">for⦂ i to: names length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[v &larr; guide lookup: names◦i.<br></span><span class="tab"></span><span class="tab"></span><span class="small">f settopage: v◦1 char: v◦2 +(offsets◦i *2).<br></span><span class="tab"></span><span class="tab"></span><span class="small">f nextword ≠ (values◦i)⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[user notify: &rsquo;bad .run loc&rsquo;]].<br></span><span class="tab"></span><span class="small">self ≡ Vmem ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[l &larr; self specialLocs.<br></span><span class="tab"></span><span class="tab"></span><span class="small">offsets◦4 &larr; 0.  values◦4 &larr; 014764.</span><span class="tab"></span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">locs &larr; (premap base, prezip base, zadd base, (l◦11) "bacpur").<br></span><span class="tab"></span><span class="tab"></span><span class="small">for⦂ i from: 1 to: locs length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[values◦i ≠ (mem◦(locs◦i +(offsets◦i)))⇒<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[user notify: &rsquo;bad system loc&rsquo;]]]<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">surgery: f </span><span class="small">| guide Etemp i v keys [<br></span><span class="tab"></span><span class="small">"</span><span class="small italic">write virtual memory tables into Smalltalk.run using Smalltalk.syms.<br></span><span class="tab"></span><span class="small">user displayoffwhile⦂ [Vmem ramwrite: (dp0 oldFile: &rsquo;byterp.mb&rsquo;)].<br></span><span class="tab"></span><span class="small">user displayoffwhile⦂ [Vmem surgery: (dp0 oldFile: &rsquo;Smalltalk.run&rsquo;)]. "<br><br></span><span class="tab"></span><span class="small">vmemfile close.<br></span><span class="tab"></span><span class="small">user releaseExternalViews.<br></span><span class="tab"></span><span class="small">[E ≡ nil ⇒[] E kill].<br><br></span><span class="tab"></span><span class="small">[self ≡ Vmem ⇒[self thisvmem.<br></span><span class="tab"></span><span class="tab"></span><span class="small">Flushed &larr; true. Etemp &larr; Events]].<br></span><span class="tab"></span><span class="small">f readwrite.<br></span><span class="tab"></span><span class="small">guide &larr; self runLocs: f.<br></span><span class="tab"></span><span class="small">self staticTest: guide on: f.<br></span><span class="tab"></span><span class="small">[self ≡ Vmem ⇒[user clearshow: &rsquo;Wait for the safe light to flash, then hit any key&rsquo;.<br></span><span class="tab"></span><span class="tab"></span><span class="small">until⦂ user kbck do⦂ []. user kbd.<br></span><span class="tab"></span><span class="tab"></span><span class="small">self dynaLocs: guide.<br></span><span class="tab"></span><span class="tab"></span><span class="small">user clearshow: &rsquo;Dont forget user systemStartup. in the new system to enable interrupts and get the display set up. &rsquo;.<br>]].<br></span><span class="tab"></span><span class="small">self tablewrt: guide on: f. "</span><span class="small italic">write in Smalltalk.run</span><span class="small">"<br></span><span class="tab"></span><span class="small">f close.<br><br></span><span class="tab"></span><span class="small">self ≡ Vmem ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[keys &larr; (↪premaptest, ↪purgetest, ↪zaddtest, ↪loxtest).<br></span><span class="tab"></span><span class="tab"></span><span class="small">for⦂ i to: keys length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[v &larr; guide lookup: keys◦i.<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">v◦2 ≠ (mem◦(v◦1))⇒[user notify: &rsquo;please surgery again&rsquo;]].<br></span><span class="tab"></span><span class="tab"></span><span class="small">Events &larr; nil. self systemVmemOut.<br></span><span class="tab"></span><span class="tab"></span><span class="small">Events &larr; Etemp.<br></span><span class="tab"></span><span class="tab"></span><span class="small">vmemfile close.<br></span><span class="tab"></span><span class="tab"></span><span class="small">user quit]<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">symsFind: strs on: f1 </span><span class="small">| f2 S N L offset val str j i "find initial values of SRELs in smalltalk.syms"<br></span><span class="tab"></span><span class="small">["S is start of string space (words)<br></span><span class="tab"></span><span class="small">N is start of symbol table "<br></span><span class="tab"></span><span class="small">(f2 &larr; f1 directory oldFile: f1 name) readonly.<br></span><span class="tab"></span><span class="small">f1 wordposition &larr; 2.<br></span><span class="tab"></span><span class="small">S &larr; f1 nextword.<br></span><span class="tab"></span><span class="small">N &larr; f1 nextword.<br></span><span class="tab"></span><span class="small">f1 wordposition &larr; N.<br></span><span class="tab"></span><span class="small">L &larr; f1 nextword.<br></span><span class="tab"></span><span class="small">for⦂ i to: L do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[offset &larr; f1 nextword. "next offset"<br></span><span class="tab"></span><span class="tab"></span><span class="small">f1 skip: 4.<br></span><span class="tab"></span><span class="tab"></span><span class="small">val &larr; f1 nextword.<br></span><span class="tab"></span><span class="tab"></span><span class="small">f2 wordposition &larr; S+offset.<br></span><span class="tab"></span><span class="tab"></span><span class="small">str &larr; f2 next: f2 next.<br></span><span class="tab"></span><span class="tab"></span><span class="small">for⦂ j to: strs length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[(strs◦j) class ≡ String ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[strs◦j = str ⇒[strs◦j &larr; val]]].<br></span><span class="tab"></span><span class="tab"></span><span class="small">].<br></span><span class="tab"></span><span class="small">f2 close.<br></span><span class="tab"></span><span class="small">for⦂ j to: strs length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[(strs◦j) class ≡ String ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[user notify: &rsquo;symbol not found&rsquo;]].<br></span><span class="tab"></span><span class="small">⇑strs]</span></div>
<div class="line left">
<span class="small bold">systemVmemOut </span><span class="small">[] primitive: 83</span></div>
<div class="line left">
<span class="small bold">tablewrt: guide on: f </span><span class="small">| i v vfile "copy tables from self to .run file"<br></span><span class="tab"></span><span class="small">[v &larr; guide lookup: ↪premaprun.<br></span><span class="tab"></span><span class="small">f settopage: v◦1 char: v◦2 +(2*pmatm).<br></span><span class="tab"></span><span class="small">f nextword&larr; premap◦pmatm.<br></span><span class="tab"></span><span class="small">f nextword&larr; premap◦pmend.<br></span><span class="tab"></span><span class="small">for⦂ i to: 1024 do⦂ [f nextword&larr; map◦i].<br></span><span class="tab"></span><span class="small">v &larr; guide lookup: ↪preziprun.<br></span><span class="tab"></span><span class="small">f settopage: v◦1 char: v◦2 +(2*1 "zfree").<br></span><span class="tab"></span><span class="small">i &larr; [self ≡ Vmem ⇒ [¬1-zip base "relative indexing"]¬1 "</span><span class="small italic">make 0-order"</span><span class="small">] .</span><span class="small italic"><br></span><span class="tab"></span><span class="small">f nextword&larr; prezip ◦1 +i. "zfree"<br></span><span class="tab"></span><span class="small">v &larr; guide lookup: ↪zaddrun.<br></span><span class="tab"></span><span class="small">f settopage: v◦1 char: v◦2 +(2*1 "zfused").<br></span><span class="tab"></span><span class="small">f nextword&larr; zadd ◦1. </span><span class="small italic">" zfused "</span><span class="small"><br></span><span class="tab"></span><span class="small">v &larr; guide lookup: ↪ziprun.<br></span><span class="tab"></span><span class="small">f settopage: v◦1 char: v◦2 +(2*1).<br></span><span class="tab"></span><span class="small">for⦂ i to: prezip◦zlong do⦂ [f nextword&larr; zip◦i]<br></span><span class="tab"></span><span class="small">v &larr; guide lookup: ↪initrun.<br></span><span class="tab"></span><span class="small">f settopage: v◦1 char: v◦2 +(2*1 "SpecialOops").<br></span><span class="tab"></span><span class="small">f nextword&larr; SpecialOopsOop.<br></span><span class="tab"></span><span class="small">f nextword&larr; FirstContextOop.<br><br></span><span class="tab"></span><span class="small">"disk address of start of virtual memory"<br></span><span class="tab"></span><span class="small">vfile &larr; vmemfile file.<br></span><span class="tab"></span><span class="small">v &larr; guide lookup: ↪zfps.<br></span><span class="tab"></span><span class="small">f settopage: v◦1 char: v◦2 +(2*1).<br></span><span class="tab"></span><span class="small">f nextword&larr; (vfile read: 0410) address.<br></span><span class="small bold"><br></span><span class="tab"></span><span class="small">"swat file id of vmem file"<br></span><span class="tab"></span><span class="small">v &larr; guide lookup: ↪safid.<br></span><span class="tab"></span><span class="small">f settopage: v◦1 char: v◦2 + (2*1).<br></span><span class="tab"></span><span class="small">f append: vfile serialNumber; skip: 4; nextword &larr; (vfile read: 1) address.<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="medium bold"><br>Zone Pages</span></div>
<div class="line left">
<span class="small bold">cover: zz </span><span class="small">| pp zrp lpir zjmp vpn olpir<br></span><span class="tab"></span><span class="small">[pp &larr; zz◦2 + 1. "zp 1-order"<br></span><span class="tab"></span><span class="small">lpir &larr; 1. olpir &larr; 0. zrp &larr; zz◦1 *2 +1.<br></span><span class="tab"></span><span class="small">until⦂ lpir ≥ pp do⦂ [<br></span><span class="tab"></span><span class="tab"></span><span class="small">0 = (zjmp &larr; zip◦zrp field: ZJMP) ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[self run: [lpir ≥ 32 ⇒[32] lpir +1] after: zrp.<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">self cover: zz]<br></span><span class="tab"></span><span class="tab"></span><span class="small">zrp &larr; (zjmpt◦zjmp + zrp -1)\ (prezip◦zlong) +1.<br></span><span class="tab"></span><span class="tab"></span><span class="small">olpir &larr; lpir.<br></span><span class="tab"></span><span class="tab"></span><span class="small">lpir &larr; lpir + [lpir ≥ 32 ⇒[32] lpir +1] ].<br></span><span class="tab"></span><span class="small">vpn &larr; (zip◦zrp field: ZVPN) +pp -(olpir +1).<br></span><span class="tab"></span><span class="small">0 = vpn ⇒[user notify: &rsquo;pclass has no zone&rsquo;]<br></span><span class="tab"></span><span class="small">vpn &larr; vpn + 0407.<br></span><span class="tab"></span><span class="small">vmemfile settopage: vpn char: zz◦3 *2]</span></div>
<div class="line left">
<span class="small bold">file </span><span class="small">[⇑vmemfile]</span></div>
<div class="line left">
<span class="small bold">getpages: i </span><span class="small">| vpn<br></span><span class="tab"></span><span class="small">[[zadd◦zflen &lt; (zadd◦zfused + i) ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[zadd◦zflen &larr; zadd◦zflen + (i max: 20).<br></span><span class="tab"></span><span class="tab"></span><span class="small">vmemfile settopage: zadd◦zflen + 0407 char: 0]].<br></span><span class="tab"></span><span class="small">vpn &larr; zadd◦zfused.<br></span><span class="tab"></span><span class="small">zadd◦zfused &larr; vpn+i.<br></span><span class="tab"></span><span class="small">⇑vpn]</span></div>
<div class="line left">
<span class="small bold">newZone </span><span class="small">| zrp<br></span><span class="tab"></span><span class="small">[zip is: Vector ⇒[<br></span><span class="tab"></span><span class="small">zrp &larr; prezip◦zfree.<br></span><span class="tab"></span><span class="small">until⦂ zip◦zrp = 0 do⦂ [zrp &gt; (prezip◦zlong) ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[user notify: &rsquo;zip overflow&rsquo;]<br></span><span class="tab"></span><span class="tab"></span><span class="small">zrp &larr; zrp+2].<br></span><span class="tab"></span><span class="small">prezip◦zfree &larr; 2+zrp.<br></span><span class="tab"></span><span class="small">zip◦zrp &larr; self getpages: 1.<br></span><span class="tab"></span><span class="small">⇑zrp/2]]</span></div>
<div class="line left">
<span class="small bold">pagesUsed </span><span class="small">[⇑zadd◦zfused]</span></div>
<div class="line left">
<span class="small bold">read: len at: zz </span><span class="small">| i str<br></span><span class="tab"></span><span class="small">[i &larr; 256 - (zz◦3) "zw" min: len.<br></span><span class="tab"></span><span class="small">self cover: zz.<br></span><span class="tab"></span><span class="small">str &larr; vmemfile next: 2*i.<br></span><span class="tab"></span><span class="small">i=len ⇒[⇑str]<br></span><span class="tab"></span><span class="small">zz◦2 &larr; zz◦2 +1. "zp"<br></span><span class="tab"></span><span class="small">zz◦3 &larr; 0. "zw"<br></span><span class="tab"></span><span class="small">⇑str concat: (self read: len-i at: zz)]</span></div>
<div class="line left">
<span class="small bold">run: n after: zrp </span><span class="small">| i j<br></span><span class="tab"></span><span class="small">[for⦂ i to: 15 do⦂ <br></span><span class="tab"></span><span class="tab"></span><span class="small">[j &larr; zjmpt◦i +zrp -1 \ (prezip◦zlong) +1.<br></span><span class="tab"></span><span class="tab"></span><span class="small">zip◦j = 0 ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[zip◦zrp &larr; zip◦zrp field: ZJMP &larr; i.<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">zip◦j &larr; self getpages: n. ⇑zrp]<br></span><span class="tab"></span><span class="tab"></span><span class="small">].<br></span><span class="tab"></span><span class="small">user notify: &rsquo;new zip is full&rsquo;]</span></div>
<div class="line left">
<span class="small bold">write: str at: zz </span><span class="small">| i len<br></span><span class="tab"></span><span class="small">[len &larr; str length /2.<br></span><span class="tab"></span><span class="small">i &larr; 256 - (zz◦3) "zw" min: len.<br></span><span class="tab"></span><span class="small">i = len ⇒[<br></span><span class="tab"></span><span class="tab"></span><span class="small">self cover: zz.<br></span><span class="tab"></span><span class="tab"></span><span class="small">vmemfile append: str]<br></span><span class="tab"></span><span class="small">self write: str from: 1 at: zz]</span></div>
<div class="line left">
<span class="small bold">write: str from: pos at: zz </span><span class="small">| i len<br></span><span class="tab"></span><span class="small">[len &larr; str length +1 -pos.  "bytes yet to write"<br></span><span class="tab"></span><span class="small">i &larr; len min: (256 - (zz◦3) "zw")*2.  "bytes in page"<br></span><span class="tab"></span><span class="small">self cover: zz.<br></span><span class="tab"></span><span class="small">vmemfile append: str◦(pos to: i+pos-1).<br></span><span class="tab"></span><span class="small">i=len ⇒[]<br></span><span class="tab"></span><span class="small">zz◦2 &larr; zz◦2 +1. "zp"<br></span><span class="tab"></span><span class="small">zz◦3 &larr; 0. "zw"<br></span><span class="tab"></span><span class="small">self write: str from: i+pos at: zz]</span></div>
<div class="line left">
<span class="small"></span></div>
<div class="line left">
<span class="small">SystemOrganization classify: ↪VirtualMemory under: &rsquo;Primitive Access&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"Vmapper"</span></div>
<div class="line left">
<span class="medium bold">Class new title: &rsquo;Vmapper&rsquo;<br></span><span class="tab"></span><span class="medium bold">subclassof: Object<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;object oop noop image&rsquo;<br></span><span class="tab"></span><span class="medium bold">declare: &rsquo;classtrans PCL mapqueue clamp stopcount USTableOop mrefs arefs count UseOldUniqueStrings &rsquo;;<br></span><span class="tab"></span><span class="medium bold">asFollows</span></div>
<div class="line left">
<span class="small italic"><br>This class has not yet been commented</span></div>
<div class="line left">
<span class="medium bold"><br>Mapping</span></div>
<div class="line left">
<span class="small bold">map </span><span class="small">| i<br></span><span class="tab"></span><span class="small">[(i &larr; mrefs lookup: oop) ⇒[i◦1 &larr; i◦1 -1. ⇑i◦2]<br></span><span class="tab"></span><span class="small">[user kbck ⇒ [user kbd; ev] self bump].<br></span><span class="tab"></span><span class="small">object class = Integer ⇒[⇑self mapInteger];<br></span><span class="tab"></span><span class="small">= UniqueString ⇒[⇑self mapUniqueString];<br></span><span class="tab"></span><span class="small">= Vector ⇒[⇑self mapVector];<br></span><span class="tab"></span><span class="small">= Float ⇒[⇑self mapFloat];<br></span><span class="tab"></span><span class="small">= MessageDict ⇒[⇑self mapMdict]<br></span><span class="tab"></span><span class="small">object Is: HashSet ⇒[⇑self mapHashSet]<br></span><span class="tab"></span><span class="small">object Is: String ⇒[⇑self mapString]<br></span><span class="tab"></span><span class="small">object class = Class ⇒[⇑self mapClass];<br></span><span class="tab"></span><span class="small">= VariableLengthClass ⇒[⇑self mapClass];<br></span><span class="tab"></span><span class="small">= Vmapper ⇒[⇑¬1]; </span><span class="small italic">"avoid recursion in writing"</span><span class="small"><br></span><span class="tab"></span><span class="small">= VirtualMemory ⇒[⇑self mapVmem]; </span><span class="small italic">"avoid recursion in writing"</span><span class="small"><br></span><span class="tab"></span><span class="small italic">"put any fixed octave class here"</span><span class="small"><br></span><span class="tab"></span><span class="small">= Object ⇒[⇑self mapObject]<br></span><span class="tab"></span><span class="small">⇑self mapNormal]</span></div>
<div class="line left">
<span class="small bold">mapClass </span><span class="small">| nlen oadd i refs vm j<br></span><span class="tab"></span><span class="small">[clamp find: object ⇒[⇑¬1 "don&rsquo;t write this class"]<br></span><span class="tab"></span><span class="small">nlen &larr; 1 + object class instsize. </span><span class="small italic">"refct + normal fields"</span><span class="small"><br></span><span class="tab"></span><span class="small">i &larr; [object is: Class ⇒[oadd &larr; 0. 1] oadd &larr; 1. 20].<br></span><span class="tab"></span><span class="small">noop &larr; self newoop.<br></span><span class="tab"></span><span class="small">[(vm &larr; classtrans lookup: oop) ⇒[vm◦1 &larr; noop]<br></span><span class="tab"></span><span class="tab"></span><span class="small">vm &larr; Vector new: i+1. vm◦1 &larr; noop.<br></span><span class="tab"></span><span class="tab"></span><span class="small">classtrans insert: oop with: vm].<br></span><span class="tab"></span><span class="small">nlen &larr; nlen + i + oadd.<br></span><span class="tab"></span><span class="small">image &larr; String new: 2*nlen.<br></span><span class="tab"></span><span class="small">[(refs &larr; object refct) = 2 ⇒[</span><span class="small italic">"exactly one reference"</span><span class="small">]<br></span><span class="tab"></span><span class="tab"></span><span class="small">mrefs insert: oop with: (refs-2, noop)].<br></span><span class="tab"></span><span class="small">image word: 1 &larr; refs -2.<br></span><span class="tab"></span><span class="small">[oadd=1 ⇒[image word: 2 &larr; nlen-2]].<br></span><span class="tab"></span><span class="small">for⦂ j from: (2+oadd to: nlen-i) do⦂ <br></span><span class="tab"></span><span class="tab"></span><span class="small">[vm &larr; Vmapper new object: (object instfield: j-1-oadd).<br></span><span class="tab"></span><span class="tab"></span><span class="small">image word: j &larr; vm map].<br></span><span class="tab"></span><span class="small">self writeout.<br></span><span class="tab"></span><span class="small">⇑noop]</span></div>
<div class="line left">
<span class="small bold">mapFloat </span><span class="small">| refs i<br></span><span class="tab"></span><span class="small">[image &larr; String new: 8.<br></span><span class="tab"></span><span class="small">noop &larr; self newoop.<br></span><span class="tab"></span><span class="small">[(refs &larr; object refct) = 2 ⇒[</span><span class="small italic">"exactly one reference"</span><span class="small">]<br></span><span class="tab"></span><span class="tab"></span><span class="small">mrefs insert: oop with: (refs-2, noop)].<br></span><span class="tab"></span><span class="small">image word: 1 &larr; refs-2.<br></span><span class="tab"></span><span class="small">for⦂ i to: 3 do⦂ [image word: (i+1) &larr; object instfield: i].<br></span><span class="tab"></span><span class="small">self writeout.<br></span><span class="tab"></span><span class="small">⇑noop]</span></div>
<div class="line left">
<span class="small bold">mapHashObs  </span><span class="small">| nlen oadd i refs vm trans ob<br></span><span class="tab"></span><span class="small">[nlen &larr; object length. </span><span class="small italic">"in words"</span><span class="small"><br></span><span class="tab"></span><span class="small">oadd &larr; [nlen≤8⇒[0]1].<br></span><span class="tab"></span><span class="small">nlen &larr; oadd +1 +nlen.<br></span><span class="tab"></span><span class="small">image &larr; String new: 2*nlen.<br></span><span class="tab"></span><span class="small">[(refs &larr; object refct) = 2 </span><span class="small italic">"exactly one ref"</span><span class="small"> ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[noop &larr; self newoop]<br></span><span class="tab"></span><span class="tab"></span><span class="small">(i &larr; mrefs lookup: oop) ⇒[i◦1 &larr; i◦1 -1. noop &larr; i◦2]<br></span><span class="tab"></span><span class="tab"></span><span class="small">noop &larr; self newoop.<br></span><span class="tab"></span><span class="tab"></span><span class="small">mrefs insert: oop with: (refs-2, noop)].<br></span><span class="tab"></span><span class="small">image word: 1 &larr; refs -2.<br></span><span class="tab"></span><span class="small">[oadd=1⇒[image word: 2 &larr; object length]].<br></span><span class="tab"></span><span class="small">ob &larr; (trans &larr; self permHashSet) objects.  </span><span class="small italic">"translation dictionary"</span><span class="small"><br></span><span class="tab"></span><span class="small">for⦂ i from: (2+oadd to: nlen) do⦂ <br></span><span class="tab"></span><span class="tab"></span><span class="small">[vm &larr; ob◦(i-1-oadd).  </span><span class="small italic">"integer noops"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">vm ≡ nil ⇒[] image word: i &larr; vm].<br></span><span class="tab"></span><span class="small">self writeout.<br></span><span class="tab"></span><span class="small">⇑noop, trans values]</span></div>
<div class="line left">
<span class="small bold">mapHashSet </span><span class="small">| nlen i refs vm perm  </span><span class="small italic">"all subclass on HashSet except Mdict"</span><span class="small"><br></span><span class="tab"></span><span class="small">[mrefs asOop = oop ⇒[⇑¬1] </span><span class="small italic">"do not map"</span><span class="small"><br></span><span class="tab"></span><span class="small">arefs asOop = oop ⇒[⇑¬1] </span><span class="small italic">"do not map"</span><span class="small"><br></span><span class="tab"></span><span class="small">nlen &larr; 1 + (object class instsize). </span><span class="small italic">"refct + fields"</span><span class="small"><br></span><span class="tab"></span><span class="small">image &larr; String new: 2*nlen.<br></span><span class="tab"></span><span class="small">noop &larr; self newoop.<br></span><span class="tab"></span><span class="small">[(refs &larr; object refct) = 2 ⇒[</span><span class="small italic">"exactly one reference"</span><span class="small">]<br></span><span class="tab"></span><span class="tab"></span><span class="small">mrefs insert: oop with: (refs-2, noop)].<br></span><span class="tab"></span><span class="small">image word: 1 &larr; refs -2.<br></span><span class="tab"></span><span class="small">vm &larr; Vmapper new object: (object instfield: 1).<br></span><span class="tab"></span><span class="small">i &larr; vm mapHashObs.  </span><span class="small italic">"(oop, perm)"</span><span class="small"><br></span><span class="tab"></span><span class="small">image word: 2 &larr; i◦1.<br></span><span class="tab"></span><span class="small">perm &larr; i◦2.  </span><span class="small italic">"permutation of other parts"</span><span class="small"><br></span><span class="tab"></span><span class="small">for⦂ i from: (3 to: nlen) do⦂ <br></span><span class="tab"></span><span class="tab"></span><span class="small">[vm &larr; Vmapper new object: (object instfield: i-1).<br></span><span class="tab"></span><span class="tab"></span><span class="small">image word: i &larr; (vm mapHashVals: perm)].<br></span><span class="tab"></span><span class="small">self writeout.<br></span><span class="tab"></span><span class="small">⇑noop]</span></div>
<div class="line left">
<span class="small bold">mapHashVals: perm </span><span class="small">| nlen oadd i refs vm  </span><span class="small italic">"values vec of dictionary"</span><span class="small"><br></span><span class="tab"></span><span class="small">[oop = ¬1 ⇒[⇑¬1]<br></span><span class="tab"></span><span class="small">nlen &larr; object length. </span><span class="small italic">"in words"</span><span class="small"><br></span><span class="tab"></span><span class="small">oadd &larr; [nlen≤8⇒[0]1].<br></span><span class="tab"></span><span class="small">nlen &larr; oadd +1 +nlen.<br></span><span class="tab"></span><span class="small">image &larr; String new: 2*nlen.<br></span><span class="tab"></span><span class="small">[(refs &larr; object refct) = 2 </span><span class="small italic">"exactly one ref"</span><span class="small"> ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[noop &larr; self newoop]<br></span><span class="tab"></span><span class="tab"></span><span class="small">(i &larr; mrefs lookup: oop) ⇒[i◦1 &larr; i◦1 -1. noop &larr; i◦2]<br></span><span class="tab"></span><span class="tab"></span><span class="small">noop &larr; self newoop.<br></span><span class="tab"></span><span class="tab"></span><span class="small">mrefs insert: oop with: (refs-2, noop)].<br></span><span class="tab"></span><span class="small">image word: 1 &larr; refs -2.<br></span><span class="tab"></span><span class="small">[oadd=1⇒[image word: 2 &larr; object length]].<br></span><span class="tab"></span><span class="small">object &larr; object◦perm.<br></span><span class="tab"></span><span class="small">for⦂ i from: (2+oadd to: nlen) do⦂ <br></span><span class="tab"></span><span class="tab"></span><span class="small">[(vm &larr; Vmapper new) object: object◦ (i-1-oadd).<br></span><span class="tab"></span><span class="tab"></span><span class="small">image word: i &larr; vm map].<br></span><span class="tab"></span><span class="small">self writeout.<br></span><span class="tab"></span><span class="small">⇑noop]</span></div>
<div class="line left">
<span class="small bold">mapInteger </span><span class="small">| refs<br></span><span class="tab"></span><span class="small">[¬02000 ≤ object and: object &lt; 01777 ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[⇑oop </span><span class="small italic">"small integer"</span><span class="small">]<br></span><span class="tab"></span><span class="small">image &larr; String new: 4.<br></span><span class="tab"></span><span class="small">noop &larr; self newoop.<br></span><span class="tab"></span><span class="small">[(refs &larr; object refct) = 2 ⇒[</span><span class="small italic">"exactly one reference"</span><span class="small">]<br></span><span class="tab"></span><span class="tab"></span><span class="small">mrefs insert: oop with: (refs-2, noop)].<br></span><span class="tab"></span><span class="small">image word: 1 &larr; refs-2.<br></span><span class="tab"></span><span class="small">image word: 2 &larr; object.<br></span><span class="tab"></span><span class="small">self writeout.<br></span><span class="tab"></span><span class="small">⇑noop]</span></div>
<div class="line left">
<span class="small bold">mapMdict </span><span class="small">| i refs vm perm  </span><span class="small italic">" maps MessageDict instance "</span><span class="small"><br></span><span class="tab"></span><span class="small">[image &larr; String new: 12.<br></span><span class="tab"></span><span class="small">noop &larr; self newoop.<br></span><span class="tab"></span><span class="small">[(refs &larr; object refct) = 2 ⇒[</span><span class="small italic">"exactly one reference"</span><span class="small">]<br></span><span class="tab"></span><span class="tab"></span><span class="small">mrefs insert: oop with: (refs-2, noop)].<br></span><span class="tab"></span><span class="small">image word: 1 &larr; refs -2.<br></span><span class="tab"></span><span class="small">(vm &larr; Vmapper new) object: (object instfield: 1).<br></span><span class="tab"></span><span class="small">i &larr; vm mapHashObs.  </span><span class="small italic">"(oop, perm)"</span><span class="small"><br></span><span class="tab"></span><span class="small">image word: 2 &larr; i◦1.<br></span><span class="tab"></span><span class="small">perm &larr; i◦2.  </span><span class="small italic">"permutation of other parts"</span><span class="small"><br></span><span class="tab"></span><span class="small">for⦂ i from: (3 to: 6) do⦂ <br></span><span class="tab"></span><span class="tab"></span><span class="small">[(vm &larr; Vmapper new) object: (object instfield: i-1).<br></span><span class="tab"></span><span class="tab"></span><span class="small">i = 3 ⇒[image word: 3 &larr; (vm mapMethodVec: perm)]<br></span><span class="tab"></span><span class="tab"></span><span class="small">image word: i &larr; (vm mapHashVals: perm)].<br></span><span class="tab"></span><span class="small">self writeout.<br></span><span class="tab"></span><span class="small">⇑noop]</span></div>
<div class="line left">
<span class="small bold">mapMethod </span><span class="small">| nlen oadd refs i a vm b<br></span><span class="tab"></span><span class="small">[oop = ¬1 ⇒[⇑¬1]<br></span><span class="tab"></span><span class="small">nlen &larr; object length. </span><span class="small italic">"in bytes!!"</span><span class="small"><br></span><span class="tab"></span><span class="small">oadd &larr; [nlen≤8⇒[0]1].<br></span><span class="tab"></span><span class="small">nlen &larr; 2*oadd +2 +nlen.<br></span><span class="tab"></span><span class="small">image &larr; String new: nlen+1 |2.<br></span><span class="tab"></span><span class="small">[(refs &larr; object refct) = 2 </span><span class="small italic">"exactly one ref"</span><span class="small"> ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[noop &larr; self newoop]<br></span><span class="tab"></span><span class="tab"></span><span class="small">(i &larr; mrefs lookup: oop) ⇒[i◦1 &larr; i◦1 -1. noop &larr; i◦2]<br></span><span class="tab"></span><span class="tab"></span><span class="small">noop &larr; self newoop.<br></span><span class="tab"></span><span class="tab"></span><span class="small">mrefs insert: oop with: (refs-2, noop)].<br></span><span class="tab"></span><span class="small">image word: 1 &larr; refs -2.<br></span><span class="tab"></span><span class="small">[oadd=1⇒[image word: 2 &larr; object length]].<br></span><span class="tab"></span><span class="small">[nlen ≤ 8 or⦂ object◦6 = 6 ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[image◦(2*oadd +3 to: nlen) &larr; object]<br></span><span class="tab"></span><span class="tab"></span><span class="small">a &larr; 2*oadd +3. b &larr; object◦6.<br></span><span class="tab"></span><span class="tab"></span><span class="small">image◦(a to: a+5) &larr; object◦(1 to: 6).<br></span><span class="tab"></span><span class="tab"></span><span class="small">for⦂ i from: (4 to: b /2) do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[(vm &larr; Vmapper new) object: (object word: i) asObject.<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">image word: (i+1+oadd) &larr; vm map].<br></span><span class="tab"></span><span class="tab"></span><span class="small">image◦(a+b to: nlen) &larr; object◦(b+1 to: object length)].<br></span><span class="tab"></span><span class="small">self writeout.<br></span><span class="tab"></span><span class="small">⇑noop]</span></div>
<div class="line left">
<span class="small bold">mapMethodVec: perm </span><span class="small">| nlen oadd i refs vm<br></span><span class="tab"></span><span class="small">[oop = ¬1 ⇒[⇑¬1]<br></span><span class="tab"></span><span class="small">nlen &larr; object length. </span><span class="small italic">"in words"</span><span class="small"><br></span><span class="tab"></span><span class="small">oadd &larr; [nlen≤8⇒[0]1].<br></span><span class="tab"></span><span class="small">nlen &larr; oadd +1 +nlen.<br></span><span class="tab"></span><span class="small">image &larr; String new: 2*nlen.<br></span><span class="tab"></span><span class="small">[(refs &larr; object refct) = 2 </span><span class="small italic">"exactly one ref"</span><span class="small"> ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[noop &larr; self newoop]<br></span><span class="tab"></span><span class="tab"></span><span class="small">(i &larr; mrefs lookup: oop) ⇒[i◦1 &larr; i◦1 -1. noop &larr; i◦2]<br></span><span class="tab"></span><span class="tab"></span><span class="small">noop &larr; self newoop.<br></span><span class="tab"></span><span class="tab"></span><span class="small">mrefs insert: oop with: (refs-2, noop)].<br></span><span class="tab"></span><span class="small">image word: 1 &larr; refs -2.<br></span><span class="tab"></span><span class="small">[oadd=1⇒[image word: 2 &larr; object length]].<br></span><span class="tab"></span><span class="small">object &larr; object◦perm.<br></span><span class="tab"></span><span class="small">for⦂ i from: (2+oadd to: nlen) do⦂ <br></span><span class="tab"></span><span class="tab"></span><span class="small">[(vm &larr; Vmapper new) object: object◦ (i-1-oadd).<br></span><span class="tab"></span><span class="tab"></span><span class="small">image word: i &larr; vm mapMethod].<br></span><span class="tab"></span><span class="small">self writeout.<br></span><span class="tab"></span><span class="small">⇑noop]</span></div>
<div class="line left">
<span class="small bold">mapNormal </span><span class="small">| nlen i refs vm oadd </span><span class="small italic">"all fixed, pointer type classes"</span><span class="small"><br></span><span class="tab"></span><span class="small">[clamp find: object class ⇒[⇑¬1 "don&rsquo;t write the instance"]<br></span><span class="tab"></span><span class="small">nlen &larr; object class instsize.<br></span><span class="tab"></span><span class="small">oadd &larr; [nlen≤19⇒[0]1].<br></span><span class="tab"></span><span class="small">nlen &larr; oadd+1 +nlen.<br></span><span class="tab"></span><span class="small">image &larr; String new: 2*nlen.<br></span><span class="tab"></span><span class="small">noop &larr; self newoop.<br></span><span class="tab"></span><span class="small">[(refs &larr; object refct) = 2 ⇒[</span><span class="small italic">"exactly one reference"</span><span class="small">]<br></span><span class="tab"></span><span class="tab"></span><span class="small">mrefs insert: oop with: (refs-2, noop)].<br></span><span class="tab"></span><span class="small">image word: 1 &larr; refs-2.<br></span><span class="tab"></span><span class="small">[oadd=1⇒[image word: 2 &larr; nlen-oadd-1]].<br></span><span class="tab"></span><span class="small">for⦂ i from: (2+oadd to: nlen) do⦂ <br></span><span class="tab"></span><span class="tab"></span><span class="small">[vm &larr; Vmapper new object: (object instfield: i-oadd-1).<br></span><span class="tab"></span><span class="tab"></span><span class="small">image word: i &larr; vm map].<br></span><span class="tab"></span><span class="small">self writeout.<br></span><span class="tab"></span><span class="small">⇑noop]</span></div>
<div class="line left">
<span class="small bold">mapObject </span><span class="small">| refs  </span><span class="small italic">"nil, false, true"</span><span class="small"><br></span><span class="tab"></span><span class="small">[object≡nil ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[mrefs insert: ¬1 with: (500, ¬1). </span><span class="small italic">"for speed of<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">catching nil. watch out on cleanup"</span><span class="small"> ⇑¬1]<br></span><span class="tab"></span><span class="small">image &larr; String new: 4.<br></span><span class="tab"></span><span class="small">noop &larr; self newoop.<br></span><span class="tab"></span><span class="small">noop\128&gt;1 ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[user notify: &rsquo;Unidentified flying Object&rsquo;]<br></span><span class="tab"></span><span class="small">[(refs &larr; object refct) = 2 ⇒[</span><span class="small italic">"exactly one reference"</span><span class="small">]<br></span><span class="tab"></span><span class="tab"></span><span class="small">mrefs insert: oop with: (refs-2, noop)].<br></span><span class="tab"></span><span class="small">image word: 1 &larr; refs -2.<br></span><span class="tab"></span><span class="small">self writeout.<br></span><span class="tab"></span><span class="small">⇑noop]</span></div>
<div class="line left">
<span class="small bold">mapString </span><span class="small">| nlen oadd refs<br></span><span class="tab"></span><span class="small">[nlen &larr; object length. </span><span class="small italic">"in bytes!!"</span><span class="small"><br></span><span class="tab"></span><span class="small">oadd &larr; [nlen≤8⇒[0]1].<br></span><span class="tab"></span><span class="small">nlen &larr; 2*oadd +2 +nlen.<br></span><span class="tab"></span><span class="small">image &larr; String new: nlen+1 |2.<br></span><span class="tab"></span><span class="small">noop &larr; self newoop.<br></span><span class="tab"></span><span class="small">[(refs &larr; object refct) = 2 ⇒[</span><span class="small italic">"exactly one reference"</span><span class="small">]<br></span><span class="tab"></span><span class="tab"></span><span class="small">mrefs insert: oop with: (refs-2, noop)].<br></span><span class="tab"></span><span class="small">image word: 1 &larr; refs -2.<br></span><span class="tab"></span><span class="small">[oadd=1⇒[image word: 2 &larr; object length]].<br></span><span class="tab"></span><span class="small">image◦((2*oadd +3) to: nlen) &larr; object.<br></span><span class="tab"></span><span class="small">self writeout.<br></span><span class="tab"></span><span class="small">⇑noop]</span></div>
<div class="line left">
<span class="small bold">mapUniqueString </span><span class="small">| nlen oadd refs<br></span><span class="tab"></span><span class="small">[[UseOldUniqueStrings ⇒[self UniStroop. noop &larr; oop]<br></span><span class="tab"></span><span class="tab"></span><span class="small">(refs &larr; arefs lookup: oop) ⇒[⇑refs]<br></span><span class="tab"></span><span class="tab"></span><span class="small">noop &larr; self newoop.<br></span><span class="tab"></span><span class="tab"></span><span class="small">arefs insert: oop with: noop].<br></span><span class="tab"></span><span class="small">nlen &larr; object length. </span><span class="small italic">"in bytes!!"</span><span class="small"><br></span><span class="tab"></span><span class="small">oadd &larr; [nlen≤8⇒[0]1].<br></span><span class="tab"></span><span class="small">nlen &larr; 2*oadd +2 +nlen.<br></span><span class="tab"></span><span class="small">image &larr; String new: nlen+1 |2.<br></span><span class="tab"></span><span class="small">image word: 1 &larr; 1.<br></span><span class="tab"></span><span class="small">[oadd=1⇒[image word: 2 &larr; object length]].<br></span><span class="tab"></span><span class="small">image◦((2*oadd +3) to: nlen) &larr; object.<br></span><span class="tab"></span><span class="small">self writeout.<br></span><span class="tab"></span><span class="small">⇑noop]</span></div>
<div class="line left">
<span class="small bold">mapVector </span><span class="small">| nlen oadd i refs vm<br></span><span class="tab"></span><span class="small">[[UseOldUniqueStrings ⇒[] USTableOop = oop ⇒[⇑¬1]<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">"do not map since new atom Oops"</span><span class="small">]. <br></span><span class="tab"></span><span class="small">nlen &larr; object length. </span><span class="small italic">"in words"</span><span class="small"><br></span><span class="tab"></span><span class="small">oadd &larr; [nlen≤8⇒[0]1].<br></span><span class="tab"></span><span class="small">nlen &larr; oadd +1 +nlen.<br></span><span class="tab"></span><span class="small">image &larr; String new: 2*nlen.<br></span><span class="tab"></span><span class="small">noop &larr; self newoop.<br></span><span class="tab"></span><span class="small">[(refs &larr; object refct) = 2 ⇒[</span><span class="small italic">"exactly one reference"</span><span class="small">]<br></span><span class="tab"></span><span class="tab"></span><span class="small">mrefs insert: oop with: (refs-2, noop)].<br></span><span class="tab"></span><span class="small">image word: 1 &larr; refs-2.<br></span><span class="tab"></span><span class="small">[oadd=1⇒[image word: 2 &larr; object length]].<br></span><span class="tab"></span><span class="small">for⦂ i from: (2+oadd to: nlen) do⦂ <br></span><span class="tab"></span><span class="tab"></span><span class="small">[vm &larr; Vmapper new object: (object◦ (i-1-oadd)).<br></span><span class="tab"></span><span class="tab"></span><span class="small">image word: i &larr; vm map].<br></span><span class="tab"></span><span class="small">self writeout.<br></span><span class="tab"></span><span class="small">⇑noop]</span></div>
<div class="line left">
<span class="small bold">mapVmem </span><span class="small">| nlen i refs vm  "VirtualMemory, Vmem and Pmap"<br></span><span class="tab"></span><span class="small">[nlen &larr; 1 + (object class instsize). "refct + fields"<br></span><span class="tab"></span><span class="small">image &larr; String new: 2*nlen.<br></span><span class="tab"></span><span class="small">noop &larr; self newoop.<br></span><span class="tab"></span><span class="small">[(refs &larr; object refct) = 2 ⇒["exactly one reference"]<br></span><span class="tab"></span><span class="tab"></span><span class="small">mrefs insert: oop with: (refs-2, noop)].<br></span><span class="tab"></span><span class="small">image word: 1 &larr; refs -2.<br></span><span class="tab"></span><span class="small">for⦂ i from: (2 to: nlen) do⦂ <br></span><span class="tab"></span><span class="tab"></span><span class="small">[image word: i &larr; ¬1]. "Vmem needed for purgealittle"<br></span><span class="tab"></span><span class="small">self writeout.<br></span><span class="tab"></span><span class="small">⇑noop]</span></div>
<div class="line left">
<span class="small bold">permHashSet </span><span class="small">| ob i bb nili vm   </span><span class="small italic">"gets new atoms, returns dict of objects and permutation"</span><span class="small"><br></span><span class="tab"></span><span class="small">[bb &larr; Dictionary new init: object length.<br></span><span class="tab"></span><span class="small">i &larr; 1. while⦂ (object◦i ≡ nil and: i ≠ object length) do⦂ [i &larr; i+1].<br></span><span class="tab"></span><span class="small">[((object◦i) class) ≡ Integer ⇒[false]; ≡ String ⇒[false] true] ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[for⦂ i to: object length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[object◦i ≡ nil ⇒[nili &larr; i]<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">vm &larr; Vmapper new object: object◦i.<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">bb insert: vm map with: i].<br></span><span class="tab"></span><span class="tab"></span><span class="small">ob &larr; bb values.<br></span><span class="tab"></span><span class="tab"></span><span class="small">for⦂ i to: ob length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[ob◦i ≡ nil ⇒[ob◦i &larr; nili] ].<br></span><span class="tab"></span><span class="tab"></span><span class="small">⇑bb]<br></span><span class="tab"></span><span class="small">ob &larr; bb objects.<br></span><span class="tab"></span><span class="small">for⦂ i to: ob length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[vm &larr; Vmapper new object: object◦i.<br></span><span class="tab"></span><span class="tab"></span><span class="small">ob◦i &larr; vm map].<br></span><span class="tab"></span><span class="small">ob &larr; bb values.<br></span><span class="tab"></span><span class="small">for⦂ i to: ob length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[ob◦i &larr; i].<br></span><span class="tab"></span><span class="small">⇑bb]</span></div>
<div class="line left">
<span class="medium bold"><br>Writing Out</span></div>
<div class="line left">
<span class="small bold">method: sel </span><span class="small">| v str a j i   </span><span class="small italic">"object is a class. find this method and construct vmapper"</span><span class="small"><br></span><span class="tab"></span><span class="small">[(v &larr; classtrans lookup: oop) ≡ false ⇒[user notify: &rsquo;object not a class&rsquo;]<br></span><span class="tab"></span><span class="small">str &larr; Pmap readin: v◦1. </span><span class="small italic">"class image"</span><span class="small"><br></span><span class="tab"></span><span class="small">i &larr; Pmap readin: (str word: 1+4+(oop/0200)). </span><span class="small italic">"mdict image"</span><span class="small"><br></span><span class="tab"></span><span class="small">str &larr; Pmap readin: (i word: 1+1). </span><span class="small italic">"objects vector image"</span><span class="small"><br></span><span class="tab"></span><span class="small">a &larr; String new: 2. a word: 1 &larr; sel asOop. </span><span class="small italic">"selector"</span><span class="small"><br></span><span class="tab"></span><span class="small">j &larr; str find: a◦2. <br></span><span class="tab"></span><span class="small">a◦1 ≠ (str◦(j-1)) ⇒[user notify: &rsquo;can not find&rsquo;]<br></span><span class="tab"></span><span class="small">i &larr; Pmap readin: (i word: 1+2). </span><span class="small italic">"methods vector image"</span><span class="small"><br></span><span class="tab"></span><span class="small">v &larr; Vmapper new object: (object md method: sel).<br></span><span class="tab"></span><span class="small">v noop: (i word: (j/2)). v readin.<br></span><span class="tab"></span><span class="small">⇑v]</span></div>
<div class="line left">
<span class="small bold">newoop </span><span class="small">| v a i indx o </span><span class="small italic">"see if classtrans can help find new oop"</span><span class="small"><br></span><span class="tab"></span><span class="small">[(v &larr; classtrans lookup: (i &larr; object class) asOop) ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[indx &larr; 1 + (Vmem freelist: object).<br></span><span class="tab"></span><span class="tab"></span><span class="small"> [i ≡ Class ⇒[oop ≤ 027 ⇒[⇑oop] </span><span class="small italic">"touchoop set it up"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">v◦indx ≤ 027 ⇒[v◦indx &larr; 027+1] ];<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">≡ VariableLengthClass ⇒[o &larr; v◦indx. </span><span class="small italic">"in case pclass changes"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">v◦indx &larr; o max: o|128 +(oop\128) +1. <br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">⇑ o|128 +(oop\128)] ].<br></span><span class="tab"></span><span class="tab"></span><span class="small">a &larr; self nextfree: v◦indx.<br></span><span class="tab"></span><span class="tab"></span><span class="small">v◦indx &larr; a◦2. ⇑a◦1]<br></span><span class="tab"></span><span class="small"> a &larr; [i is: Class ⇒[1] 20].<br></span><span class="tab"></span><span class="small"> v &larr; Vector new: a+1.<br></span><span class="tab"></span><span class="small"> classtrans insert: (object class) asOop with: v.<br></span><span class="tab"></span><span class="small"> ⇑self newoop]</span></div>
<div class="line left">
<span class="small bold">newpcl: n </span><span class="small">| a pm0<br></span><span class="tab"></span><span class="small">[</span><span class="small italic">"object class = Foo ⇒[an exception]"</span><span class="small"><br></span><span class="tab"></span><span class="small">pm0 &larr; Vmem lowPM: oop.<br></span><span class="tab"></span><span class="small">a &larr; [pm0 ⇒[Pmap newLowPM&larr; pm0]<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">Pmap newHighPM&larr; (Vmem highPM: oop)].<br></span><span class="tab"></span><span class="small">n=¬1 ⇒[Pmap newZN: a. Pmap ZHB: a gets: 0. ⇑a]<br></span><span class="tab"></span><span class="small">Pmap ZN: a gets: (Pmap ZN: n).<br></span><span class="tab"></span><span class="small">Pmap ZHB: a gets: 1 + (Pmap ZHB: n).<br></span><span class="tab"></span><span class="small">⇑a]</span></div>
<div class="line left">
<span class="small bold">nextfree: n </span><span class="small">| a<br></span><span class="tab"></span><span class="small">[n≡nil ⇒[n &larr; self newpcl: ¬1.<br></span><span class="tab"></span><span class="tab"></span><span class="small">⇑(n, (n+1))]<br></span><span class="tab"></span><span class="small">n\0200 = 0177 ⇒[a &larr; self newpcl: n.<br></span><span class="tab"></span><span class="tab"></span><span class="small">⇑(n, a)]<br></span><span class="tab"></span><span class="small">⇑(n, (n+1))]</span></div>
<div class="line left">
<span class="small bold">object: object<br></span><span class="tab"></span><span class="small">[oop &larr; object asOop]</span></div>
<div class="line left">
<span class="small bold">readin </span><span class="small">| v  </span><span class="small italic">"read object off vmemfile and return image"</span><span class="small"><br></span><span class="tab"></span><span class="small">[[noop ≡ nil ⇒[(v &larr; mrefs lookup: oop) ⇒[noop &larr; v◦2] <br></span><span class="tab"></span><span class="tab"></span><span class="small">user notify: &rsquo;can not find new oop&rsquo;]].<br></span><span class="tab"></span><span class="small">⇑image &larr; Pmap readin: noop]</span></div>
<div class="line left">
<span class="small bold">writeout<br></span><span class="tab"></span><span class="small">[</span><span class="small italic">"write image of object on file"</span><span class="small"><br></span><span class="tab"></span><span class="small">Pmap writeout: noop with: image]</span></div>
<div class="line left">
<span class="medium bold"><br>Init and Exceptions</span></div>
<div class="line left">
<span class="small bold">Acomment<br></span><span class="tab"></span><span class="small">[</span><span class="small italic">"Vmapper writes objects out.<br></span><span class="tab"></span><span class="small italic">watch out for abnormally high refcts.<br></span><span class="tab"></span><span class="small italic">we trust map to catch all special cases (especially<br></span><span class="tab"></span><span class="small italic">fixed octave classes (VariableLengthClass)).<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">Vmapper edit: ↪mapObject.<br></span><span class="tab"></span><span class="small italic">Vmem is VirtualMemory of this system.<br></span><span class="tab"></span><span class="small italic">Pmap is VirtualMemory of new system.<br></span><span class="tab"></span><span class="small italic">refct in mrefs is 1-order (0 = all done)<br></span><span class="tab"></span><span class="small italic">mrefs - a Dictionary<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">old oop  -&gt;  (remaining refct, new oop)<br></span><span class="tab"></span><span class="small italic">classtrans - a Dictionary<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">old class oop  -&gt;  (new oop, freelist oop)<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small italic">-&gt;  (new oop, 20 freelist oops)<br></span><span class="tab"></span><span class="small italic">sequence of foreign object:<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">map (put in mrefs) <br></span><span class="tab"></span><span class="tab"></span><span class="small italic">newoop (classtrans lookup old class)<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">not there⇒ create pclass, get zone, zip entry<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small italic">enter freelist, no new class in classtrans<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">put nop in mrefs, write object out<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">later: map class, fill in classtrans new class<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">later: pass over PM, convert RCI<br><br></span><span class="tab"></span><span class="small italic">To remap atoms:</span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small italic">To only copy atoms:<br></span><span class="tab"></span><span class="small italic">giveBirth3 - arefsRectify</span><span class="tab"></span><span class="tab"></span><span class="small italic">- don&rsquo;t call<br></span><span class="tab"></span><span class="small italic">mapUniqueString -uniStrOop</span><span class="tab"></span><span class="small italic">-newoop, arefs<br></span><span class="tab"></span><span class="small italic">mapVector - filter USTable</span><span class="tab"></span><span class="small italic">-don&rsquo;t<br></span><span class="tab"></span><span class="small italic">writefreelists - don&rsquo;t freelistRectify</span><span class="tab"></span><span class="tab"></span><span class="small italic">-call it<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">(Speed only below)<br></span><span class="tab"></span><span class="small italic">permHashSet - test objects</span><span class="tab"></span><span class="tab"></span><span class="small italic">-force fail on test<br></span><span class="tab"></span><span class="small italic">Now above done by setting UseOldUniqueStrings in giveBirth3.<br></span><span class="tab"></span><span class="small italic">"</span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">arefsRectify </span><span class="small">| i ustable vm </span><span class="small italic">"create USTable and write out"</span><span class="small"><br></span><span class="tab"></span><span class="small">[UseOldUniqueStrings ⇒[⇑nil </span><span class="small italic">"dont create if using old atoms"</span><span class="small">]<br></span><span class="tab"></span><span class="small">ustable &larr; Vector new: USTable length.<br></span><span class="tab"></span><span class="small">for⦂ i to: ustable length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[ustable◦i &larr; Vector new: 2].<br></span><span class="tab"></span><span class="small">i &larr; ustable.  ustable &larr; USTable. USTable &larr; i.<br></span><span class="tab"></span><span class="small">for⦂ i from: arefs objects do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[i ≡ nil ⇒[]<br></span><span class="tab"></span><span class="tab"></span><span class="small">↪a intern: i asObject].<br></span><span class="tab"></span><span class="small">i &larr; ustable.  ustable &larr; USTable. USTable &larr; i.<br></span><span class="tab"></span><span class="small">vm &larr; Vmapper new.<br></span><span class="tab"></span><span class="small">vm object: ustable.<br></span><span class="tab"></span><span class="small">self reset; object: (Smalltalk ref: ↪USTable); readin.<br></span><span class="tab"></span><span class="small">image word: 2 &larr; vm map. </span><span class="small italic">"ref new table"</span><span class="small"><br></span><span class="tab"></span><span class="small">self writeout; reset]</span></div>
<div class="line left">
<span class="small bold">bump  </span><span class="small italic">"count objects mapped, print"</span><span class="small"><br></span><span class="tab"></span><span class="small">[count &larr; count + 1.<br></span><span class="tab"></span><span class="small">count\ 100 = 0 ⇒[user clearshow: count asString; space;<br></span><span class="tab"></span><span class="tab"></span><span class="small">show: oop base8; cr.<br></span><span class="tab"></span><span class="tab"></span><span class="small">count = stopcount ⇒[user ev; show: stopcount asOop base8]]<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">freelistRectify </span><span class="small">| i v  </span><span class="small italic">"fix bad atom freelist"</span><span class="small"><br></span><span class="tab"></span><span class="small">[[UseOldUniqueStrings ⇒[] ⇑nil].  </span><span class="small italic">"dont rectify if new atom names created"</span><span class="small"><br></span><span class="tab"></span><span class="small">for⦂ i from: (Vmem pmatm to: 0174000 - 0200 by: 0200) do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[(Vmapper new object: i asObject) UniStroop].<br></span><span class="tab"></span><span class="small">v &larr; classtrans lookup: 0602.<br></span><span class="tab"></span><span class="small">for⦂ i from: (2 to: 21) do⦂ [v◦i ≡ nil ⇒[]<br></span><span class="tab"></span><span class="tab"></span><span class="small">v◦i &larr; v◦i + 1]<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">init   </span><span class="small italic">"set up class variables"</span><span class="small"><br></span><span class="tab"></span><span class="small">[PCL &larr; 151.<br></span><span class="tab"></span><span class="small">classtrans &larr; Dictionary new init: 32.<br></span><span class="tab"></span><span class="small">mrefs &larr; Dictionary new init: 64.<br></span><span class="tab"></span><span class="small">arefs &larr; Dictionary new init: 64.<br></span><span class="tab"></span><span class="small">count &larr; 1.<br></span><span class="tab"></span><span class="small">stopcount &larr; 5 </span><span class="small italic">"no stopping"</span><span class="small">.<br></span><span class="tab"></span><span class="small">clamp &larr; HashSet new init: 8. <br></span><span class="tab"></span><span class="small">"clamp insertall: (ClassA, ClassB, ClassC...).""ones to get rid of"<br></span><span class="tab"></span><span class="small">USTableOop &larr; USTable asOop.<br></span><span class="tab"></span><span class="small italic">"override this in VirtualMemory giveBirth3"</span><span class="small"><br></span><span class="tab"></span><span class="small">UseOldUniqueStrings &larr; true]</span></div>
<div class="line left">
<span class="small bold">mrefsRectify </span><span class="small">| v zz<br></span><span class="tab"></span><span class="small">[for⦂ v from: mrefs values do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[v ≡ nil ⇒[]<br></span><span class="tab"></span><span class="tab"></span><span class="small">v◦1 = 0 ⇒[</span><span class="small italic">"refct ok"</span><span class="small">]<br></span><span class="tab"></span><span class="tab"></span><span class="small">v◦2 = ¬1 ⇒[</span><span class="small italic">"nil not on disk"</span><span class="small">]<br></span><span class="tab"></span><span class="tab"></span><span class="small">zz &larr; Pmap obwiz: v◦2.  </span><span class="small italic">"noop"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">image &larr; Pmap read: 2 at: zz.  </span><span class="small italic">"2 words"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">image word: 1 &larr; (image word: 1) - (v◦1).<br></span><span class="tab"></span><span class="tab"></span><span class="small">Pmap writeout: v◦2 with: image.<br></span><span class="tab"></span><span class="tab"></span><span class="small">self reset]<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">noop: noop </span><span class="small italic">"give it noop for readin"</span></div>
<div class="line left">
<span class="small bold">reset </span><span class="small">[noop &larr; image &larr; nil]</span></div>
<div class="line left">
<span class="small bold">touchoop </span><span class="small">| v a i indx </span><span class="small italic">"claim pclass, zone, classtrans"</span><span class="small"><br></span><span class="tab"></span><span class="small">[(v &larr; classtrans lookup: (object class) asOop) ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[indx &larr; 1 +(Vmem freelist: object).<br></span><span class="tab"></span><span class="tab"></span><span class="small">a &larr; self nextfree: v◦indx.<br></span><span class="tab"></span><span class="tab"></span><span class="small">v◦indx &larr; a◦1. </span><span class="small italic">"not take it"</span><span class="small"> ⇑a◦1]<br></span><span class="tab"></span><span class="small"> i &larr; [object class is: Class ⇒[1] 20].<br></span><span class="tab"></span><span class="small"> v &larr; Vector new: i+1.<br></span><span class="tab"></span><span class="small"> classtrans insert: (object class) asOop with: v.<br></span><span class="tab"></span><span class="small"> ⇑self touchoop]</span></div>
<div class="line left">
<span class="small bold">UniStroop </span><span class="small">| pm0 v indx<br></span><span class="tab"></span><span class="small">[</span><span class="small italic">"Unique Strings must get same oop and pclass"</span><span class="small"><br></span><span class="tab"></span><span class="small">v &larr; classtrans lookup: 0602.<br></span><span class="tab"></span><span class="small">indx &larr; 1+ (Vmem freelist: object).<br></span><span class="tab"></span><span class="small">pm0 &larr; Pmap highPM: oop.<br></span><span class="tab"></span><span class="small">pm0 and⦂ 0 ≠ pm0 ⇒[</span><span class="small italic">"test for new max freelist"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">(oop field: PCL) = (v◦indx field: PCL) ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="small">[v◦indx &larr; v◦indx max: oop]] <br></span><span class="tab"></span><span class="small">Pmap highpm0: oop gets: (Vmem highPM: oop).<br></span><span class="tab"></span><span class="small">Pmap ZHB: oop gets: (Vmem ZHB: oop).<br></span><span class="tab"></span><span class="small">v◦indx ≡ nil ⇒[Pmap newZN: oop.<br></span><span class="tab"></span><span class="tab"></span><span class="small">v◦indx &larr; oop]<br></span><span class="tab"></span><span class="small">Pmap ZN: oop gets: (Pmap ZN: v◦indx).<br></span><span class="tab"></span><span class="small">v◦indx &larr; oop min: v◦indx<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="small bold">UseOldUniqueStrings: a </span><span class="small">[UseOldUniqueStrings &larr; a] </span><span class="small italic">"true if do not want atoms remapped"</span></div>
<div class="line left">
<span class="small bold">writefreelists </span><span class="small">| v oadd i nlen str<br></span><span class="tab"></span><span class="small">[self freelistRectify.<br></span><span class="tab"></span><span class="small">nlen &larr; 1 + Class instsize. oadd &larr; 1.<br></span><span class="tab"></span><span class="small">str &larr; String new: 4. <br></span><span class="tab"></span><span class="small">str word: 1 &larr; 1. str word: 2 &larr; ¬1. </span><span class="small italic">"refct=1, link = nil"</span><span class="small"><br></span><span class="tab"></span><span class="small">for⦂ v from: classtrans values do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[v ≡ nil ⇒[]<br></span><span class="tab"></span><span class="tab"></span><span class="small">image &larr; Pmap readin: v◦1.  </span><span class="small italic">"noop"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">[v length = 2 ⇒<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[</span><span class="small italic">"a Class"</span><span class="small"> v◦2 ≡ nil ⇒[]<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">image word: (1+nlen) &larr; v◦2.<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">Pmap writeout: v◦2 with: str]<br></span><span class="tab"></span><span class="tab"></span><span class="small italic">"a Variable Length Class"</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">for⦂ i to: 20 do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[v◦(1+i) ≡ nil ⇒ []<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">image word: (i+nlen+oadd) &larr; v◦(1+i).<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">Pmap writeout: v◦(1+i) with: str] ].<br></span><span class="tab"></span><span class="tab"></span><span class="small">Pmap writeout: v◦1 with: image].<br></span><span class="tab"></span><span class="small">self reset]</span></div>
<div class="line left">
<span class="medium bold"><br>As yet unclassified</span></div>
<div class="line left">
<span class="small bold">Addons<br></span><span class="tab"></span><span class="small">[(dp0 file: &rsquo;VmapperAdd.st&rsquo;) filout: ↪(<br></span><span class="tab"></span><span class="small">)]</span></div>
<div class="line left">
<span class="small bold">arefs  </span><span class="small italic">"dictionary of UniqueString oops and noops"</span><span class="small"><br></span><span class="tab"></span><span class="small">[⇑arefs]</span></div>
<div class="line left">
<span class="small bold">classtrans </span><span class="small">[⇑classtrans]</span></div>
<div class="line left">
<span class="small bold">image </span><span class="small">[⇑image]</span></div>
<div class="line left">
<span class="small bold">mrefs </span><span class="small italic">"dictionary of multiple refct oops"</span><span class="small"><br></span><span class="tab"></span><span class="small">[⇑mrefs]</span></div>
<div class="line left">
<span class="small bold">noop </span><span class="small">[⇑noop]</span></div>
<div class="line left">
<span class="small bold">object </span><span class="small">[⇑object]</span></div>
<div class="line left">
<span class="small bold">oop </span><span class="small">[⇑oop]</span></div>
<div class="line left">
<span class="small bold">printon: strm<br></span><span class="tab"></span><span class="small">[oop ≡ nil ⇒[super printon: strm]<br></span><span class="tab"></span><span class="small">strm append: &rsquo;Vmapper &rsquo;; append: oop base8]</span></div>
<div class="line left">
<span class="small bold">show </span><span class="small">| i  </span><span class="small italic">"show image of object in base8"</span><span class="small"><br></span><span class="tab"></span><span class="small">[for⦂ i to: image length/2 do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[user show: (image base8: i); space.<br></span><span class="tab"></span><span class="tab"></span><span class="small">i\3 = 0 ⇒[user cr]]<br></span><span class="tab"></span><span class="small">]</span></div>
<div class="line left">
<span class="small"></span></div>
<div class="line left">
<span class="small">SystemOrganization classify: ↪Vmapper under: &rsquo;Primitive Access&rsquo;.</span></div>
  </body>
</html>
