<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>Smalltalk76/Compiler.st</title>
	<link rel="stylesheet" type="text/css" href="font.css"/>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">&rsquo;From Smalltalk 5.5k XM November 24 on 22 November 1980 at 2:57:08 am.&rsquo;<br></span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold">"Decompiler"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;Decompiler&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: Object<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;method temps instvars literals stack isReference literalNames&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;breakPC highlight &rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">sharing: ByteCodes;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>This class has not yet been commented</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Initialization</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">decompile: sel class: class </span><span class="small">| strm block ignore p<br></span><span class="tab" val="79"></span><span class="small">[method &larr; class method: sel.<br></span><span class="tab" val="79"></span><span class="small">method length&lt;8⇒[⇑self quickCode: sel class: class]<br></span><span class="tab" val="79"></span><span class="small">self initSymbols: class.<br></span><span class="tab" val="79"></span><span class="small">stack &larr; (Vector new: (method◦3)-(method◦5)) asStream.<br></span><span class="tab" val="79"></span><span class="small">block &larr; self block: method◦6+1 to: method length<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">pc⦂ ignore hasValue⦂ ignore.<br></span><span class="tab" val="79"></span><span class="small">stack empty≡false⇒[user notify: &rsquo;stack not empty&rsquo;]<br></span><span class="tab" val="79"></span><span class="small">self convertMacros: block sel: sel.<br></span><span class="tab" val="79"></span><span class="small">strm &larr; Stream default.<br></span><span class="tab" val="79"></span><span class="small">self printPattern: sel on: strm.<br></span><span class="tab" val="79"></span><span class="small">strm crtab: 1.<br></span><span class="tab" val="79"></span><span class="small">block printon: strm indent: 1 precedence: 0 forValue: false decompiler: self.<br></span><span class="tab" val="79"></span><span class="small">[(p&larr;method word: 1)≠0⇒[strm append: &rsquo; primitive: &rsquo;; print: p]].<br></span><span class="tab" val="79"></span><span class="small">⇑strm contents asParagraph makeBoldPattern]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">findPC: x </span><span class="small">[breakPC&larr; x. highlight&larr; 1 to: 1]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">highlight </span><span class="small">[⇑highlight]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">highlight: x </span><span class="small">[⇑highlight&larr; x]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Symbols</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">initSymbols: class </span><span class="small">| i lit env<br></span><span class="tab" val="79"></span><span class="small">["</span><span class="small italic">Init temps with made-up names</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">temps &larr; Vector new: method◦5.<br></span><span class="tab" val="79"></span><span class="small">for⦂ i to: temps length do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[temps◦i &larr; &rsquo;t&rsquo; + i asString].<br></span><span class="tab" val="79"></span><span class="small">instvars &larr; class instvars.<br></span><span class="tab" val="79"></span><span class="small">literals &larr; MessageDict new literalsIn: method.<br></span><span class="tab" val="79"></span><span class="small">literalNames &larr; Vector new: literals length.<br></span><span class="tab" val="79"></span><span class="small">env &larr; class wholeEnvironment, Smalltalk, Undeclared.<br></span><span class="tab" val="79"></span><span class="small">for⦂ i to: literals length do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[lit &larr; literals◦i.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">literalNames◦i &larr;<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[lit is: UniqueString⇒[lit]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">lit is: ObjectReference⇒[self invertRef: lit environment: env]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">lit≡FieldReference⇒[&rsquo;&rsquo;]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">lit asString]]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">instvar: i<br></span><span class="tab" val="79"></span><span class="small">[⇑instvars◦(i-codeLoadField+1)]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">invertRef: ref environment: env </span><span class="small">| table n<br></span><span class="tab" val="79"></span><span class="small">[for⦂ table from: env do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[n&larr;table invertRef: ref⇒[⇑n]].<br></span><span class="tab" val="79"></span><span class="small">⇑&rsquo;unknown&rsquo;]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">literal: i </span><span class="small">| index lit str<br></span><span class="tab" val="79"></span><span class="small">[index &larr; i-codeLoadLit+1.<br></span><span class="tab" val="79"></span><span class="small">lit &larr; literals◦index.  str &larr; literalNames◦index.<br></span><span class="tab" val="79"></span><span class="small">lit is: ObjectReference⇒[⇑str]<br></span><span class="tab" val="79"></span><span class="small">(lit is: UniqueString) or⦂ (lit is: Vector)⇒[⇑&rsquo;↪&rsquo; + str]<br></span><span class="tab" val="79"></span><span class="small">⇑str]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">literalIndirect: i<br></span><span class="tab" val="79"></span><span class="small">[⇑literalNames◦(i-codeLoadLitInd+1)]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">selector: i <br></span><span class="tab" val="79"></span><span class="small">[i&gt;166 and⦂ i&lt;208⇒[⇑SpecialOops◦(i-166)]<br></span><span class="tab" val="79"></span><span class="small">⇑literalNames◦(i-codeSendLit+1)]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">temp: i<br></span><span class="tab" val="79"></span><span class="small">[⇑temps◦(i-codeLoadTemp+1)]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Byte Interpretation</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">block: start to: end pc⦂ pc hasValue⦂ v<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| block code byte j stackPos t<br></span><span class="tab" val="79"></span><span class="small">["Decompile the method from start to end into a ParsedBlock and return the<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">instance of ParsedBlock.  Assign to pc the value of the pc after leaving<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">the block.  If at run time this block will leave a value on the stack,<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">set hasValue to true."<br></span><span class="tab" val="79"></span><span class="small">block &larr; ParsedBlock default. pc value&larr; end+1.<br></span><span class="tab" val="79"></span><span class="small">stackPos &larr; stack position.<br></span><span class="tab" val="79"></span><span class="small">code &larr; Stream new of: method from: start to: end.<br></span><span class="tab" val="79"></span><span class="small">for⦂ byte from: code do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[byte&lt;0200⇒[self loadByte: byte code: code]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">byte&lt;0210⇒[self controlByte: byte code: code block: block]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">byte&lt;0214⇒[self loadByte: byte code: code  "extended loads"]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">byte=0214⇒[self selectorByte: byte code: code at: code position  "extended selector"]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">byte&lt;0260⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[j&larr;self jumpByte: byte code: code block: block.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">code end⇒[pc value&larr;j]]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">self selectorByte: byte code: code at: code position]<br></span><span class="tab" val="79"></span><span class="small">"If there is an additional item on the stack, it will be the value<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">of this block"<br></span><span class="tab" val="79"></span><span class="small">stack position&gt;stackPos⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[t&larr;stack pop.  v value&larr;true.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">block empty and⦂ (t is: ParsedBlock)⇒[⇑t]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">block next&larr; t.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">⇑block]<br></span><span class="tab" val="79"></span><span class="small">v value&larr;false.<br></span><span class="tab" val="79"></span><span class="small">[block empty⇒[block next&larr; nil]].<br></span><span class="tab" val="79"></span><span class="small">"pretend that returns jump to end of method"<br></span><span class="tab" val="79"></span><span class="small">[block returns or⦂ (block◦block position) returns⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[pc value&larr; method length+1]].<br></span><span class="tab" val="79"></span><span class="small">⇑block]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">checkForRemoteCode: jump code: code block: block </span><span class="small">| m ignore t j b<br>"</span><span class="small italic">Check if this is a jump around remote code.</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">[jump&gt;code limit⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">remote code should terminate with a </span><span class="small italic underline">toEnd</span><span class="small italic">, and then a jump back</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">method◦(jump-3)≠toEnd⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">t &larr; method◦(jump-2).<br></span><span class="tab" val="79"></span><span class="small">t&lt;0240 or⦂ t&gt;0243⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">j &larr; t-0244*256+(method◦(jump-1)).<br></span><span class="tab" val="79"></span><span class="small">jump+j ≠ (code position+1) ⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">m &larr; stack pop.<br></span><span class="tab" val="79"></span><span class="small">((m isnt: ParsedMessage) or⦂ m rcvr≡toLoadThisCtxt≡false) or⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">(self selector: m op)≠↪remoteCopy⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[stack next&larr; m.  ⇑false]<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">it&rsquo;s a piece of remote code</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">b &larr; self block: code position+1 to: jump-4<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">pc⦂ ignore hasValue⦂ ignore.<br></span><span class="tab" val="79"></span><span class="small">stack next&larr; ParsedRemote new expr: b.<br></span><span class="tab" val="79"></span><span class="small">code position&larr; jump-1]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">conditionalJump: elseStart code: code block: block<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| cond ifExpr thenExpr elseExpr thenJump elseJump ignore newBlock<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">hasValue last<br></span><span class="tab" val="79"></span><span class="small">[ifExpr &larr; stack pop.<br></span><span class="tab" val="79"></span><span class="small">thenExpr &larr; self block: code position+1 to: elseStart-1<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">pc⦂ thenJump hasValue⦂ hasValue.<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">ensure jump is within block (in case thenExpr returns)</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">thenJump &larr; thenJump min: code limit+1.<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">if jump goes back, then it&rsquo;s a loop</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">thenJump&lt;elseStart⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[self loop: thenJump whileExpr: ifExpr doExpr: thenExpr<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">code: code block: block doSize: elseStart-code position-1.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">code position&larr; elseStart-1]<br></span><span class="tab" val="79"></span><span class="small">elseExpr &larr; self block: elseStart to: thenJump-1<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">pc⦂ elseJump hasValue⦂ ignore.<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">if </span><span class="small italic underline">elseJump</span><span class="small italic"> is backwards, it is not part of the elseExpr</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">[elseJump&lt;code position⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[code position&larr; thenJump-3.  last&larr;true] <br></span><span class="tab" val="79"></span><span class="small">code position&larr; thenJump-1].<br></span><span class="tab" val="79"></span><span class="small">[thenJump+1=code limit  "</span><span class="small italic">still might be last</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">and⦂ (method◦thenJump≥0240 and⦂ method◦thenJump≤0247)⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[last&larr;true]].<br></span><span class="tab" val="79"></span><span class="small">[thenJump=code limit<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">and⦂ (method◦thenJump≥0220 and⦂ method◦thenJump≤0227)⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[last&larr;true]].<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">check for and⦂ or or⦂</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">hasValue and⦂ (thenExpr position=1 and⦂ thenExpr◦1≡toLoadTrue)⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[stack next&larr; ParsedDisjunct new left: ifExpr right:<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[elseExpr position=1⇒[elseExpr◦1] elseExpr] ]<br></span><span class="tab" val="79"></span><span class="small">hasValue and⦂ (elseExpr position=1 and⦂ elseExpr◦1≡toLoadFalse)⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[stack next&larr; ParsedConjunct new left: ifExpr right:<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[thenExpr position=1⇒[thenExpr◦1] thenExpr] ]<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">it&rsquo;s an if statement</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">cond &larr; ParsedConditional new<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">ifExpr: ifExpr thenExpr: thenExpr elseExpr: elseExpr.<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">If the then part has a value, put the conditional in a block, and put the<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic">block on the stack.  (If the compiler is working right the else part will<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic">leave a value, too ... this is not checked).</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">hasValue⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[newBlock&larr;ParsedBlock default.  newBlock next&larr; cond.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">stack next&larr; newBlock]<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">If the thenExpr jumps to the end of the current block,<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic">or to a jump backwards at the end of the current block,<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic">or to a ⇑self at the end of the method,<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic">append the cond<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic">to the current block.  Otherwise, embed it in a new block.</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">(code end or⦂ last≡true) or⦂<br></span><span class="tab" val="79"></span><span class="small">(thenJump+1=method length and⦂ method◦thenJump=toLoadSelf)⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[block next&larr; cond]<br></span><span class="tab" val="79"></span><span class="small">newBlock&larr;ParsedBlock default.  newBlock next&larr; cond.<br></span><span class="tab" val="79"></span><span class="small">block next&larr; newBlock]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">controlByte: byte code: code block: block </span><span class="small">| var t strm<br></span><span class="tab" val="79"></span><span class="small">[byte=toSmashPop⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[var &larr; self makeLoad: code next code: code.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">block next&larr; ParsedAssignment new var: var expr: stack pop]<br></span><span class="tab" val="79"></span><span class="small">byte=toSmash⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">["</span><span class="small italic">smash no pop at the end of a block will require the next byte<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic">to be fetched from after the limit of the block</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">code end⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[strm &larr; Stream new of: method from: code limit+1 to: method length.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">var &larr; self makeLoad: strm next code: strm.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">block next&larr; ParsedAssignment new var: var expr: stack pop]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">var &larr; self makeLoad: code next code: code.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">block next&larr; ParsedAssignment new var: var expr: stack pop.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">uncascade assignment statements</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">stack next&larr; var]<br></span><span class="tab" val="79"></span><span class="small">byte=toPop⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[block next&larr; stack pop]<br></span><span class="tab" val="79"></span><span class="small">byte=toReturn⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[t &larr; stack pop.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">stack empty≡false⇒[user notify: &rsquo;stack not empty&rsquo;]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">elide final ⇑self</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">t≡toLoadSelf and⦂ code position=method length⇒[]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">block doesReturn.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">block next&larr; t]<br></span><span class="tab" val="79"></span><span class="small">byte=toEnd⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[user notify: &rsquo;unexpected&rsquo;]<br></span><span class="tab" val="79"></span><span class="small">byte=toLoadThisCtxt⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[stack next&larr; byte]<br></span><span class="tab" val="79"></span><span class="small">byte=toSuper⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[stack pop.  "</span><span class="small italic">delete ref to self</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">stack next&larr; byte]<br></span><span class="tab" val="79"></span><span class="small">user notify: &rsquo;unknown control byte&rsquo;]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">jumpByte: byte code: code block: block </span><span class="small">| offset j<br>"</span><span class="small italic">If this is an unconditional jump, return the position in the method to which it jumps.  If this is a conditional jump forward, parse a conditional statement.  Conditional jumps backward are not produced by the current compiler.</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">[byte&lt;0230⇒["</span><span class="small italic">short unconditional jump forward</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">⇑byte-0220+code position+2]<br></span><span class="tab" val="79"></span><span class="small">byte&lt;0240⇒["</span><span class="small italic">short conditional jump forward</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">self conditionalJump: byte-0230+code position+2 code: code block: block.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">⇑code position+1]<br></span><span class="tab" val="79"></span><span class="small">byte&lt;0250⇒["</span><span class="small italic">long unconditional jump</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">offset &larr;  code next.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">j &larr; byte-0244*256+offset+code position+1.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">self checkForRemoteCode: j code: code block: block.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">⇑j]<br></span><span class="tab" val="79"></span><span class="small">byte&lt;0254⇒[code skip: 1.  "long conditional jump backward"<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">user notify: &rsquo;conditional jump backward not expected&rsquo;]<br></span><span class="tab" val="79"></span><span class="small">byte&lt;0260⇒["</span><span class="small italic">long conditional jump forward</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">offset &larr; code next.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">self conditionalJump: byte-0254*256+offset+code position+1<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">code: code block: block.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">⇑code position+1]<br></span><span class="tab" val="79"></span><span class="small">user notify: &rsquo;not a jump byte&rsquo;]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">loadByte: byte code: code </span><span class="small">| t lit<br></span><span class="tab" val="79"></span><span class="small">[t &larr; self makeLoad: byte code: code.<br></span><span class="tab" val="79"></span><span class="small">t≥codeLoadLit and⦂ t&lt;codeLoadLitInd⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[lit &larr; literals◦(t-codeLoadLit+1).<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">lit≡FieldReference⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[self remoteReference: code]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">lit is: ObjectReference⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[stack next&larr; ParsedObjectReference new var: t]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">stack next&larr; t]<br></span><span class="tab" val="79"></span><span class="small">stack next&larr; t]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">loop: jumpBack whileExpr: whileExpr doExpr: doExpr code: code block: block<br>doSize: doSize<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| n b ignore<br></span><span class="tab" val="79"></span><span class="small">["</span><span class="small italic">jumpBack will jump to the beginning of whileExpr.  In the case of for statements or while&rsquo;s with a block in the condition, the whileExpr should include more than just the last expression.  Kludge: find all the statements needed by re-decompiling.</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">n &larr; code position-doSize jmpSize.<br></span><span class="tab" val="79"></span><span class="small">b &larr; self block: jumpBack to: n pc⦂ ignore hasValue⦂ ignore.<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">discard unwanted statements from block</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">block skip: 1-b position.<br></span><span class="tab" val="79"></span><span class="small">block next&larr; ParsedLoop new <br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">whileExpr: [b position=1⇒[whileExpr] b] doExpr: doExpr]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">makeLoad: byte code: code </span><span class="small">| offset<br></span><span class="tab" val="79"></span><span class="small">["</span><span class="small italic">check for extended loads</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">byte≥0210 and⦂ byte≤0213⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">["</span><span class="small italic">extended reference codes:<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic">0210 - extended inst<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic">0211 - extended temp<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic">0212 - extended literal<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic">0213 - extended literal indirect"<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">offset&larr;256*(byte-0207).<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">⇑code next+offset]<br></span><span class="tab" val="79"></span><span class="small"> ⇑byte asCompilerCode]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">remoteReference: code </span><span class="small">| i obj offset var<br></span><span class="tab" val="79"></span><span class="small">[i &larr; stack pop.<br></span><span class="tab" val="79"></span><span class="small">offset &larr; [i≤124⇒[↪(0 1 2 10)◦(i-120)] literals◦(i-codeLoadLit+1)].<br></span><span class="tab" val="79"></span><span class="small">obj &larr; stack pop.<br></span><span class="tab" val="79"></span><span class="small">code skip: 2.  "</span><span class="small italic">skip </span><span class="small italic underline">new</span><span class="small italic"> </span><span class="small italic underline">object:offset:</span><span class="small italic"> </span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">var &larr; [obj=toLoadTempframe⇒[codeLoadTemp+offset-1]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">obj=toLoadSelf⇒[codeLoadField+offset-1]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">user notify: &rsquo;bad remote reference&rsquo;].<br></span><span class="tab" val="79"></span><span class="small">stack next&larr; ParsedFieldReference new var: var]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">selectorByte: byte code: code at: p </span><span class="small">| op sel i nArgs args rcvr<br></span><span class="tab" val="79"></span><span class="small">["check for extended selector codes"<br></span><span class="tab" val="79"></span><span class="small">op &larr; [byte=toSendLitLong⇒[code next+codeSendLit] byte asCompilerCode].<br></span><span class="tab" val="79"></span><span class="small">"find the corresponding selector and the number of args it expects"<br></span><span class="tab" val="79"></span><span class="small">sel &larr; self selector: op.<br></span><span class="tab" val="79"></span><span class="small">nArgs &larr; sel numArgs.<br></span><span class="tab" val="79"></span><span class="small">rcvr &larr; stack pop.<br></span><span class="tab" val="79"></span><span class="small">[nArgs=0⇒[args&larr;false]<br></span><span class="tab" val="79"></span><span class="small"> nArgs=1⇒[args&larr;stack pop]<br></span><span class="tab" val="79"></span><span class="small"> args &larr; Vector new: nArgs.<br></span><span class="tab" val="79"></span><span class="small"> for⦂ i from: nArgs to: 1 by: ¬1 do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[args◦i &larr; stack pop]].<br></span><span class="tab" val="79"></span><span class="small">stack next&larr; ParsedMessage new rcvr: rcvr op: op args: args.<br></span><span class="tab" val="79"></span><span class="small">p=breakPC⇒[stack last hasPC]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Macros</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">convertMacros: block sel: sel </span><span class="small">| macros compilerTemps vec loc i<br></span><span class="tab" val="79"></span><span class="small">["</span><span class="small italic">replace statement patterns with corresponding macros when possible</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">macros &larr; (Vector new: 10) asStream.<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">for each temp, compilerTemps is false if it is a user temp, true if it is a<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic">compiler temp, and nil if not yet known</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">compilerTemps &larr; Vector new: temps length.<br></span><span class="tab" val="79"></span><span class="small">for⦂ i to: sel numArgs do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[compilerTemps◦i &larr; false].<br></span><span class="tab" val="79"></span><span class="small">block findMacros: macros compilerTemps: compilerTemps.<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">insert macros in reverse order to keep indices from being messed up</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">vec &larr; macros contents.<br></span><span class="tab" val="79"></span><span class="small">for⦂ i from: vec length-1 to: 1 by: ¬2 do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[vec◦i≡nil⇒[]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">vec◦i insertMacro: vec◦(i+1) decompiler: self].<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">set names of compiler temps to empty string</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">for⦂ i to: temps length do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[compilerTemps◦i≡true⇒[temps◦i &larr; &rsquo;&rsquo;]]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Printing</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printPattern: sel on: strm </span><span class="small">| i n keywords<br></span><span class="tab" val="79"></span><span class="small">[n&larr;sel numArgs.<br></span><span class="tab" val="79"></span><span class="small">[n=0⇒[strm append: sel; space  "</span><span class="small italic">unary</span><span class="small">"]<br></span><span class="tab" val="79"></span><span class="small"> keywords&larr;sel keywords.<br></span><span class="tab" val="79"></span><span class="small"> for⦂ i to: keywords length do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[strm append: keywords◦i; space; append: temps◦i; space]].<br></span><span class="tab" val="79"></span><span class="small">n=(method◦5)⇒[]<br></span><span class="tab" val="79"></span><span class="small">strm append: &rsquo;| &rsquo;.   "</span><span class="small italic">temps beyond args</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">for⦂ i from: n+1 to: method◦5 do⦂ [strm append: temps◦i; space]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">quickCode: sel class: class </span><span class="small">| t strm<br></span><span class="tab" val="79"></span><span class="small">[method length=2⇒[⇑sel asParagraph makeBoldPattern]<br></span><span class="tab" val="79"></span><span class="small">method length=5⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[t &larr; method◦5.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">strm &larr; Stream default.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">strm append: sel; append: &rsquo; [⇑&rsquo;; append: class instvars◦(t+1); append: &rsquo;]&rsquo;.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">⇑strm contents asParagraph makeBoldPattern]<br></span><span class="tab" val="79"></span><span class="small">⇑&rsquo;undeciperable method&rsquo; asParagraph]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪Decompiler under: &rsquo;Compiler&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"Generator"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;Generator&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: Object<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;literals nTemps maxTemp local environment parser supered root requestor sourceStream sourceParagraph&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">sharing: ByteCodes;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>I generate code parsed by parser.  The symbol tables I use are local and environment.  The run-time needs of the code are recorded in literals, nTemps, and maxTemp.  If a message was passed to super, then supered is true.  I remember my root context to abort in case of error.</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Services</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">compile: sourceParagraph in: class under: category notifying: requestor </span><span class="small">| selector<br></span><span class="tab" val="79"></span><span class="small">[user displayoffwhile⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[sourceStream &larr; sourceParagraph asStream.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">selector &larr; self compileIn: class⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[class organization classify: selector under: category]].<br></span><span class="tab" val="79"></span><span class="small">⇑selector]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">evaluate: sourceStream in: context to: receiver notifying: requestor<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| method nvars value tframe<br></span><span class="tab" val="79"></span><span class="small">[method &larr; user displayoffwhile⦂ [self evaluateIn: context to: receiver].<br></span><span class="tab" val="79"></span><span class="small">root≡true≡false⇒ [⇑method] </span><span class="small italic">"compilation failed, return false or corrected value"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="small">nvars &larr; nTemps.<br></span><span class="tab" val="79"></span><span class="small">context⇒ </span><span class="small italic">"frame copy here because interpret loses control"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[tframe &larr; context tempframe◦(1 to: nvars) copyto: (Vector new: method◦3).<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">value &larr; context interpret: method with: tframe.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">tframe◦(1 to: nvars) copyto: context tempframe.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">⇑value]<br></span><span class="tab" val="79"></span><span class="small">⇑Context new have: receiver interpret: method]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Errors</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">abortWith: errorString </span><span class="small">| mySender<br></span><span class="tab" val="79"></span><span class="small">[[WhatFlag⇒ [user notify: errorString]].<br></span><span class="tab" val="79"></span><span class="small">mySender &larr; thisContext swapSender: root sender.<br></span><span class="tab" val="79"></span><span class="small">root sender &larr; nil. root &larr; nil. parser terminate.<br></span><span class="tab" val="79"></span><span class="small">mySender release. mySender &larr; nil.<br></span><span class="tab" val="79"></span><span class="small">user restoredisplay.<br></span><span class="tab" val="79"></span><span class="small">⇑requestor notify: errorString at: sourceStream position in: sourceStream]<br></span><span class="small italic">"Parser notify"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">notify: errorString<br></span><span class="tab" val="79"></span><span class="small">[parser notify: errorString]<br></span><span class="small italic">"ParsedObjectReference remote"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">terminate<br></span><span class="tab" val="79"></span><span class="small">[root &larr; nil]<br></span><span class="small italic">"Parser terminate"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Code generation</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">compileIn: class<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| block method nargs selector primitive<br></span><span class="tab" val="79"></span><span class="small">[parser &larr; Parser new. root &larr; thisContext. parser from: sourceStream to: self.<br></span><span class="tab" val="79"></span><span class="small">self initSymbols: class.<br></span><span class="tab" val="79"></span><span class="small">block &larr; ParsedBlock default.<br></span><span class="tab" val="79"></span><span class="small">selector &larr; parser pattern: block. nargs &larr; nTemps.<br></span><span class="tab" val="79"></span><span class="small">parser temporaries: block. primitive &larr; parser body: block.<br></span><span class="tab" val="79"></span><span class="small">parser mustBeDone. parser &larr; nil.<br></span><span class="tab" val="79"></span><span class="small">block mustReturn: true </span><span class="small italic">"defaults to ⇑self"</span><span class="small">.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[method &larr; [primitive=0 and⦂ nargs=0⇒ [block quickCode] false]⇒ []<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">method &larr; self generate: block in: class.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">method◦2 &larr; primitive; ◦4 &larr; nargs].<br></span><span class="tab" val="79"></span><span class="small">class install: selector method: method literals: literals<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">code: [sourceParagraph is: Paragraph⇒ [sourceParagraph]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">sourceStream asArray] backpointers: nil.<br></span><span class="tab" val="79"></span><span class="small">[HuhFlag⇒ [Huh&larr;nil. Huh &larr; (self decompile: method onto: Stream default) contents. HuhFlag&larr;false]].<br></span><span class="tab" val="79"></span><span class="small">⇑selector]<br></span><span class="small italic">"compile"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">decompile: method onto: s<br></span><span class="tab" val="79"></span><span class="small">[method length&lt;6⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[s append: &rsquo;Quick code: &rsquo;; append: method asBytes. ⇑s]<br></span><span class="tab" val="79"></span><span class="small">s print: method◦4; append: &rsquo; args; &rsquo;;<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">print: method◦5; append: &rsquo; temps; &rsquo;;<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">print: (method◦3) - (method◦5); append: &rsquo; stack; &rsquo;;<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">print: (method◦6) -6 /2; append: &rsquo; literals; &rsquo;.<br></span><span class="tab" val="79"></span><span class="small">[(method◦2) &gt; 0⇒ [s append: &rsquo; primitive: &rsquo;; print: method◦2; append: &rsquo;;&rsquo;]].<br></span><span class="tab" val="79"></span><span class="small">s print: method length; append: &rsquo; bytes total.&rsquo;; cr.<br></span><span class="tab" val="79"></span><span class="small">method◦2 = 40⇒ [⇑s]<br></span><span class="tab" val="79"></span><span class="small">⇑self decompileBytes: method onto: s]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">decompileBytes: method onto: s<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| dict x i c m t<br></span><span class="tab" val="79"></span><span class="small">[dict &larr; Dictionary new init: 64.<br></span><span class="tab" val="79"></span><span class="small">dict insertall: ((128 to: 131) copy, 125 concat: (144 to: 175) copy)<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">with: ↪(<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">&rsquo;&larr;&uarr;&rsquo; &rsquo;&larr;&rsquo; &rsquo;&uarr;&rsquo; &rsquo;⇑&rsquo; &rsquo;end&rsquo;<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">&rsquo;jmp1&rsquo; &rsquo;jmp2&rsquo; &rsquo;jmp3 &rsquo; &rsquo;jmp4&rsquo; &rsquo;jmp5&rsquo; &rsquo;jmp6&rsquo; &rsquo;jmp7&rsquo; &rsquo;jmp8&rsquo;<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">&rsquo;bfp1&rsquo; &rsquo;bfp2&rsquo; &rsquo;bfp3 &rsquo; &rsquo;bfp4&rsquo; &rsquo;bfp5&rsquo; &rsquo;bfp6&rsquo; &rsquo;bfp7&rsquo; &rsquo;bfp8&rsquo;<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">&rsquo;jmp&rsquo; &rsquo;jmp&rsquo; &rsquo;jmp&rsquo; &rsquo;jmp&rsquo; &rsquo;jmp&rsquo; &rsquo;jmp&rsquo; &rsquo;jmp&rsquo; &rsquo;jmp&rsquo;<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">&rsquo;bfp&rsquo; &rsquo;bfp&rsquo; &rsquo;bfp&rsquo; &rsquo;bfp&rsquo; &rsquo;bfp&rsquo; &rsquo;bfp&rsquo; &rsquo;bfp&rsquo; &rsquo;bfp&rsquo;).<br></span><span class="tab" val="79"></span><span class="small">for⦂ x from: local contents do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[i&larr;local◦x. t &larr; i land: 255.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[i&gt;255 and⦂ t&lt;16⇒ [i&larr;((i lshift: ¬8)-1 lshift: 4) + t]].<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">dict insert: i with: x].<br></span><span class="tab" val="79"></span><span class="small">for⦂ x from: stdSelectors contents do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[dict insert: stdSelectors◦x with: [x is: Integer⇒ [x inString] x]].<br></span><span class="tab" val="79"></span><span class="small">for⦂ i to: 5 do⦂ [dict insert: toLoadConst+i-1 with: ↪(&rsquo;¬1&rsquo; &rsquo;0&rsquo; &rsquo;1&rsquo; &rsquo;2&rsquo; &rsquo;10&rsquo;)◦i].<br></span><span class="tab" val="79"></span><span class="small">for⦂ t from: (m &larr; (method◦(method◦6 +1 to: method length)) asStream) do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[[t≥toLoadFieldLong and⦂ t≤toSendLitLong⇒ [t&larr;((t-0207) lshift: 8)+ m next]].<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small"> [c &larr; dict lookup: t⇒ [s append: c] s append: &rsquo;#&rsquo;. s append: t base8].<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small"> s space.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small"> t &lt; toLongJmp⇒ [] t ≥ 0260⇒ []<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small"> s print: t\8 -4 *256 + m next; space].<br></span><span class="tab" val="79"></span><span class="small">s cr.<br></span><span class="tab" val="79"></span><span class="small">⇑s]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">evaluateIn: context to: receiver<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| block method class nvars<br></span><span class="tab" val="79"></span><span class="small">[ </span><span class="small italic">"If context is false, receiver will evaluate in top level"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="small">block &larr; ParsedBlock default.<br></span><span class="tab" val="79"></span><span class="small">parser &larr; Parser new. root &larr; thisContext.<br></span><span class="tab" val="79"></span><span class="small">parser from: sourceStream to: self.<br></span><span class="tab" val="79"></span><span class="small">[context⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[self initSymbols: (class &larr; context mclass).<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">context variableNamesInto: self with: ParsedBlock default.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">nvars &larr; nTemps.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">root &larr; thisContext. </span><span class="small italic">"because variableNamesInto nil&rsquo;ed it"</span><span class="small">]<br></span><span class="tab" val="79"></span><span class="small"> self initSymbols: (class &larr; receiver class)].<br></span><span class="tab" val="79"></span><span class="small">parser temporaries: block; statements: block; mustBeDone. parser &larr; nil.<br></span><span class="tab" val="79"></span><span class="small">block mustReturn: false </span><span class="small italic">"returns last value"</span><span class="small">.<br></span><span class="tab" val="79"></span><span class="small">method &larr; self generate: block in: class.<br></span><span class="tab" val="79"></span><span class="small">[HuhFlag⇒ [Huh&larr;nil. Huh &larr; (self decompile: method onto: Stream default) contents. HuhFlag&larr;false]].<br></span><span class="tab" val="79"></span><span class="small">root &larr; true. </span><span class="small italic">"to signify success"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="small">nTemps &larr; nvars.<br></span><span class="tab" val="79"></span><span class="small">⇑method]<br></span><span class="small italic">"evaluate"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">generate: block in: class<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| header method code lit stack<br></span><span class="tab" val="79"></span><span class="small">[[(lit &larr; literals find: nil)&gt;0⇒ [literals &larr; (literals◦(1 to: lit-1)) copy]].<br></span><span class="tab" val="79"></span><span class="small">[supered⇒ [literals &larr; literals, (Smalltalk ref: class title unique)]].<br></span><span class="tab" val="79"></span><span class="small">header &larr; 6 + (2* literals length).<br></span><span class="tab" val="79"></span><span class="small">code &larr; (method &larr; String new: header + block sizeForValue) asStream.<br></span><span class="tab" val="79"></span><span class="small">code<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">next &larr; 0; next &larr; 0; next &larr; 0;<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">next &larr; 0; next &larr; maxTemp; next &larr; header.<br></span><span class="tab" val="79"></span><span class="small">for⦂ lit from: literals do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[code next &larr; lit PTR lshift: ¬8; next &larr; lit PTR land: 0377].<br></span><span class="tab" val="79"></span><span class="small">stack &larr; ParseStack init.<br></span><span class="tab" val="79"></span><span class="small">block emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">[stack position≠1⇒ [user notify: &rsquo;Compiler stack discrepancy&rsquo;]].<br></span><span class="tab" val="79"></span><span class="small">[code position≠method length⇒ [user notify: &rsquo;Compiler code size discrepancy&rsquo;]].<br></span><span class="tab" val="79"></span><span class="small">method◦3 &larr; maxTemp + stack length.<br></span><span class="tab" val="79"></span><span class="small">⇑method] </span><span class="small italic">"compile|evaluate"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Parse tree</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">assignment: var expr: expr<br></span><span class="tab" val="79"></span><span class="small">[⇑ParsedAssignment new var: var expr: expr]<br></span><span class="small italic">"Parser expression"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">block<br></span><span class="tab" val="79"></span><span class="small">[⇑ParsedBlock default]<br></span><span class="small italic">"Parser primary|Parser alternatives"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">evalKeyword: arg<br></span><span class="tab" val="79"></span><span class="small">[⇑arg]<br></span><span class="small italic">"Parser keywordMessage"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">ifExpr: ifExpr thenExpr: thenExpr elseExpr: elseExpr<br></span><span class="tab" val="79"></span><span class="small">[⇑ParsedConditional new ifExpr: ifExpr thenExpr: thenExpr elseExpr: elseExpr]<br></span><span class="small italic">"ifthen...|Parser alternatives"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">keywordMessage: rcvr selector: sel args: args<br></span><span class="tab" val="79"></span><span class="small">[sel=&rsquo;and⦂&rsquo;⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[⇑ParsedConjunct new left: rcvr right: args local];<br></span><span class="tab" val="79"></span><span class="small">  = &rsquo;or⦂&rsquo;⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[⇑ParsedDisjunct new left: rcvr right: args local]<br></span><span class="tab" val="79"></span><span class="small">⇑self rcvr: rcvr selector: sel args: (args remote: self)]<br></span><span class="small italic">"Parser keywordMessage"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">noEvalKeyword: arg<br></span><span class="tab" val="79"></span><span class="small">[⇑arg asRemoteCode: self]<br></span><span class="small italic">"Parser keywordMessage"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">nullStatement: block<br></span><span class="tab" val="79"></span><span class="small">[block next &larr; toLoadNil. ⇑block]<br></span><span class="small italic">"ifthen|Parser statements"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">rcvr: rcvr selector: sel args: args<br></span><span class="tab" val="79"></span><span class="small">[[rcvr≡toSuper⇒ [supered&larr;true]].<br></span><span class="tab" val="79"></span><span class="small">⇑ParsedMessage new rcvr: rcvr op: (self encodeSel: sel) args: args]<br></span><span class="small italic">"loop|keywordMessage|Parser binaryMessage|Parser unaryMessage"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">receivingVar: expr </span><span class="small">| rcvr var </span><span class="small italic">"who in expr is cascade recipient"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="small">[rcvr &larr; expr emittedReceiver⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[var &larr; rcvr emittedVariable⇒ [⇑var]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">var &larr; self newTemp. </span><span class="small italic">"if a non-variable, compute it just once"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">expr emittedReceiver &larr; ParsedAssignment new var: var expr: rcvr.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">⇑var]<br></span><span class="tab" val="79"></span><span class="small">parser notify: &rsquo;MAY ONLY FOLLOW A MESSAGE&rsquo;]<br></span><span class="small italic">"Parser cascade"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">variable: name<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| var global ref unq<br></span><span class="tab" val="79"></span><span class="small">[var &larr; local lookup: name⇒ [⇑var]<br></span><span class="tab" val="79"></span><span class="small">[unq &larr; name hasBeenUniqued⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[for⦂ global from: environment do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[ref &larr; global lookupRef: unq⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[⇑codeLoadLitInd + (self litIndex: ref)]]]].<br></span><span class="tab" val="79"></span><span class="small">requestor interactive⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[parser notify: &rsquo;➲Smalltalk declare: ↪&rsquo; + name + &rsquo; as: nil➲TO DECLARE GLOBAL&rsquo;]<br></span><span class="tab" val="79"></span><span class="small">user show: &rsquo; (&rsquo; + name + &rsquo; is Undeclared) &rsquo;.<br></span><span class="tab" val="79"></span><span class="small">unq &larr; name unique.<br></span><span class="tab" val="79"></span><span class="small">Undeclared declare: unq.<br></span><span class="tab" val="79"></span><span class="small">⇑codeLoadLitInd + (self litIndex: (Undeclared ref: unq))]<br></span><span class="small italic">"Parser expression|Parser primary"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Macros</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">for: var from: startMinus1 to: stop do: ritual on: block </span><span class="small">| temp<br></span><span class="tab" val="79"></span><span class="small">[temp &larr; self newTempForMacro.<br></span><span class="tab" val="79"></span><span class="small italic">"temp&larr;stop. var&larr;startMinus1. while⦂ temp≥(var &larr; 1+var) do⦂ ritual"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="small">block next &larr; ParsedAssignment new var: temp expr: stop;<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">next &larr; ParsedAssignment new var: var expr: startMinus1;<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">next &larr; ParsedLoop new<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">whileExpr:<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">(ParsedMessage new rcvr: temp op: toGeq args:<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">(ParsedAssignment new var: var<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">expr: (ParsedMessage new rcvr: toLoad1 op: toPlus args: var)))<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">doExpr: ritual]<br></span><span class="small italic">"for...todoargs"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">forfromdo: block args: args </span><span class="small">| var sequence ritual strm<br></span><span class="tab" val="79"></span><span class="small">[var &larr; (args◦1) local. sequence &larr; args◦2. ritual &larr; (args◦3) local.<br></span><span class="tab" val="79"></span><span class="small">strm &larr; self newTempForMacro.<br></span><span class="tab" val="79"></span><span class="small italic">"strm &larr; sequence asStream. while⦂ (var &larr; strm next) do⦂ ritual"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="small">block next &larr; ParsedAssignment new var: strm<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">expr: (ParsedMessage new rcvr: sequence op: toAsStream args: false);<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">next &larr; ParsedLoop new<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">whileExpr:<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">(ParsedAssignment new var: var<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">expr: (ParsedMessage new rcvr: strm op: toNext args: false))<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">doExpr: ritual]<br></span><span class="small italic">"macro (perform)"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">forfromtobydo: block args: args<br></span><span class="tab" val="79"></span><span class="small">[</span><span class="small italic">"for⦂ var from: (start to: stop by: step) do⦂ ritual"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="small">args◦2 &larr; self rcvr: args◦2 selector: &rsquo;to:by:&rsquo; args: (args◦(3 to: 4)) copy.<br></span><span class="tab" val="79"></span><span class="small">self forfromdo: block args: (args◦↪(1 2 5)) copy]<br></span><span class="small italic">"macro (perform)"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">forfromtodo: block args: args<br></span><span class="tab" val="79"></span><span class="small">[self for: (args◦1) local<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">from: (ParsedMessage new rcvr: args◦2 op: toMinus args: toLoad1)<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">to: args◦3<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">do: (args◦4) local<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">on: block]<br></span><span class="small italic">"macro (perform)"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">fortodo: block args: args<br></span><span class="tab" val="79"></span><span class="small">[self for: (args◦1) local<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">from: toLoad0<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">to: args◦2<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">do: (args◦3) local<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">on: block]<br></span><span class="small italic">"macro (perform)"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">ifthen: block args: args<br></span><span class="tab" val="79"></span><span class="small">[block next &larr; self ifExpr: (args◦1) local thenExpr: (args◦2) local elseExpr: (self nullStatement: ParsedBlock default)]<br></span><span class="small italic">"macro (perform)"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">ifthenelse: block args: args<br></span><span class="tab" val="79"></span><span class="small">[block next &larr; self ifExpr: (args◦1) local thenExpr: (args◦2) local elseExpr: (args◦3) local]<br></span><span class="small italic">"macro (perform)"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">macro: block selector: sel args: args<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| special<br></span><span class="tab" val="79"></span><span class="small">[special &larr; inLineMsgs lookup: sel⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[self perform: special with: block with: args]<br></span><span class="tab" val="79"></span><span class="small">Context canunderstand: sel unique⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[block next &larr; self rcvr: toLoadThisCtxt selector: sel args: (args remote: self)]<br></span><span class="tab" val="79"></span><span class="small">⇑false]<br></span><span class="small italic">"Parser keywordMessage"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">untildo: block args: args<br></span><span class="tab" val="79"></span><span class="small">[block next &larr; ParsedLoop new whileExpr: (ParsedNegation new rcvr: (args◦1) local op: toEq args: toLoadFalse) doExpr: (args◦2) local]<br></span><span class="small italic">"macro (perform)"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">whiledo: block args: args<br></span><span class="tab" val="79"></span><span class="small">[block next &larr; ParsedLoop new whileExpr: (args◦1) local doExpr: (args◦2) local]<br></span><span class="small italic">"macro (perform)"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Table maintenance</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">balance<br></span><span class="tab" val="79"></span><span class="small">[⇑nTemps]<br></span><span class="small italic">"Parser cascade"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">comment: s<br></span><span class="small italic">"Class fieldNamesInto"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">contents<br></span><span class="small italic">"Class fieldNamesInto"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">declaration: block name: name asArg: asArg<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| permVar tempVar<br></span><span class="tab" val="79"></span><span class="small">[tempVar &larr; self newTemp.<br></span><span class="tab" val="79"></span><span class="small">permVar &larr; local lookup: name ⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[asArg and⦂ permVar isField⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[block next &larr; ParsedAssignment new var: permVar expr: tempVar]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">parser notify: &rsquo;NAME ALREADY IN USE&rsquo;]<br></span><span class="tab" val="79"></span><span class="small">local insert: name with: tempVar]<br></span><span class="small italic">"Parser declaration|temporaries"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">encodeSel: sel<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| code<br></span><span class="tab" val="79"></span><span class="small">[code &larr; stdSelectors lookup: sel⇒ [⇑code]<br></span><span class="tab" val="79"></span><span class="small">⇑codeSendLit+ (self litIndex: [sel class≡Integer⇒ [UST1◦(sel+1)] sel unique])]<br></span><span class="small italic">"rcvr|ParsedFieldReference remote|ParsedRemote remote"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">identifier: s<br></span><span class="tab" val="79"></span><span class="small">[local insert: s with: (nTemps &larr; nTemps + 1)]<br></span><span class="small italic">"Class fieldNamesInto"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">initSymbols: class | s<br></span><span class="tab" val="79"></span><span class="small">[environment &larr; class wholeEnvironment, Smalltalk.<br></span><span class="tab" val="79"></span><span class="small">local &larr; Dictionary new copyfrom: stdPrimaries.<br></span><span class="tab" val="79"></span><span class="small">nTemps &larr; codeLoadField-1.<br></span><span class="tab" val="79"></span><span class="small">for⦂ s from: class instvars do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[local insert: s with: (nTemps &larr; nTemps + 1)].<br></span><span class="tab" val="79"></span><span class="small">nTemps &larr; maxTemp &larr; 0. literals &larr; Vector new: 123. supered &larr; false]<br></span><span class="small italic">"compile|evaluate"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">juggle </span><span class="small">| oldTemps<br></span><span class="tab" val="79"></span><span class="small">[oldTemps &larr; maxTemp. maxTemp &larr; nTemps. ⇑oldTemps]<br></span><span class="small italic">"Parser macro"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">literal: x  </span><span class="small">| i<br></span><span class="tab" val="79"></span><span class="small">[[x class≡Integer⇒ [0≠(i&larr;↪(¬1 0 1 2 10) find: x)⇒ [⇑toLoadConst+i-1]]].<br></span><span class="tab" val="79"></span><span class="small">⇑codeLoadLit + (self litIndex: x)]<br></span><span class="small italic">"Parser primary|ParsedFieldReference remote"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">litIndex: oop  </span><span class="small">| i t<br></span><span class="tab" val="79"></span><span class="small">[for⦂ i to: 123 do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[(t &larr; literals◦i)≡nil⇒ [literals◦i&larr;oop. ⇑i-1]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">t class≡oop class⇒ [t sameAs: oop⇒ [⇑i-1]]].<br></span><span class="tab" val="79"></span><span class="small">parser notify: &rsquo;MORE THAN 123 LITERALS REFERENCED&rsquo;]<br></span><span class="small italic">"encodeSel|literal"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">newTemp<br></span><span class="tab" val="79"></span><span class="small">[(nTemps &larr; nTemps+1) &gt; maxTemp and⦂ (maxTemp &larr; nTemps) &gt; 256⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[parser notify: &rsquo;MORE THAN 256 TEMPS REQUIRED&rsquo;]<br></span><span class="tab" val="79"></span><span class="small">⇑codeLoadTemp + nTemps-1]<br></span><span class="small italic">"receivingVar|declaration"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">newTempForMacro </span><span class="small italic">"juggle arranged that maxTemp are needed by args of macro"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="small">[nTemps &larr; maxTemp. ⇑self newTemp]<br></span><span class="small italic">"forfromdo|forfromtodo"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">separator: c<br></span><span class="small italic">"Class fieldNamesInto"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">trailer: s<br></span><span class="small italic">"Class fieldNamesInto"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">unbalance: nTemps<br></span><span class="small italic">"Parser cascade"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">unjuggle: oldTemps<br></span><span class="tab" val="79"></span><span class="small">[maxTemp &larr; oldTemps max: maxTemp]<br></span><span class="small italic">"Parser macro"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪Generator under: &rsquo;Compiler&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"ParsedAssignment"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;ParsedAssignment&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: Object<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;var expr elide&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">sharing: ByteCodes;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>I am a node in a compiler parse tree.  I represent an assignment of an expression to a variable.</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Initialization</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">var: var expr: expr</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Code generation</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForEffect: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[expr emitForValue: code on: stack. stack pop: 1.<br></span><span class="tab" val="79"></span><span class="small">elide⇒ [</span><span class="small italic">"var begins the next statement"</span><span class="small"> code next &larr; toSmash]<br></span><span class="tab" val="79"></span><span class="small">code next &larr; toSmashPop.<br></span><span class="tab" val="79"></span><span class="small">var emitBytes: code]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForValue: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[expr emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">code next &larr; toSmash.<br></span><span class="tab" val="79"></span><span class="small">var emitBytes: code]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emittedVariable<br></span><span class="tab" val="79"></span><span class="small">[⇑var]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">firstPush<br></span><span class="tab" val="79"></span><span class="small">[⇑expr firstPush]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForEffect: nextPush<br></span><span class="tab" val="79"></span><span class="small">[⇑expr sizeForValue + 1 + [elide &larr; nextPush≡var⇒ [0] var sizeForValue]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForValue<br></span><span class="tab" val="79"></span><span class="small">[⇑expr sizeForValue + 1 + var sizeForValue]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Miscellaneous</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: s<br></span><span class="tab" val="79"></span><span class="small">[s append: &rsquo;(&rsquo;; print: var; append: &rsquo;&larr;&rsquo;; print: expr; append: &rsquo;)&rsquo;]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Decompiling</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">expr </span><span class="small">[⇑expr]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">findMacros: macros compilerTemps: compilerTemps<br></span><span class="tab" val="79"></span><span class="small">[var findMacros: macros compilerTemps: compilerTemps.<br></span><span class="tab" val="79"></span><span class="small">expr findMacros: macros compilerTemps: compilerTemps]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">isForFromInit: loop </span><span class="small">| cond b nextMess<br></span><span class="tab" val="79"></span><span class="small">["</span><span class="small italic">return true if I could be the first initialization statement for a <br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic underline">for⦂ from:</span><span class="small italic"> loop.</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">(expr isnt: ParsedMessage) or⦂ expr op≠toAsStream⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">loop isnt: ParsedLoop⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">b &larr; loop whileExpr.<br></span><span class="tab" val="79"></span><span class="small">(b isnt: ParsedBlock) or⦂ b position≠2⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">b◦1 isnt: ParsedAssignment⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">nextMess &larr; (b◦1) expr.<br></span><span class="tab" val="79"></span><span class="small">nextMess isnt: ParsedMessage⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">nextMess rcvr≠var or⦂ nextMess op≠toNext⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">⇑true]</span><span class="tab" val="79"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">isForFromToInit: start loop: loop </span><span class="small">| b incr test<br></span><span class="tab" val="79"></span><span class="small">["</span><span class="small italic">return true if I could be the first initialization statement for a <br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic underline">for⦂ to: do⦂</span><span class="small italic"> or a </span><span class="small italic underline">for⦂ from: to: do⦂</span><span class="small italic"> loop</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">I should set the upper bound, start should set the var to start-1</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">(start isnt: ParsedAssignment) or⦂ (loop isnt: ParsedLoop)⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small"> [start expr≡toLoad0⇒[]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">start expr isnt: ParsedMessage⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">start expr op≠toMinus or⦂ start expr args≠toLoad1⇒[⇑false]].<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">the loop condition should increment the var and compare it with the <br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic">upper bound</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">b &larr; loop whileExpr.<br></span><span class="tab" val="79"></span><span class="small">(b isnt: ParsedBlock) or⦂ b position≠2⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">incr &larr; b◦1.<br></span><span class="tab" val="79"></span><span class="small">incr isnt: ParsedAssignment⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">incr var≠start var⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">(incr expr isnt: ParsedMessage) or⦂ incr expr op≠toPlus⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">incr expr rcvr≠toLoad1 or⦂ incr expr args≠start var⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">test &larr; b◦2.<br></span><span class="tab" val="79"></span><span class="small">test isnt: ParsedMessage⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">(test rcvr≠var or⦂ test op≠toGeq) or⦂ test args≠incr var⇒[⇑false]<br></span><span class="tab" val="79"></span><span class="small">⇑true]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: strm indent: level precedence: p forValue: v decompiler: decompiler<br></span><span class="tab" val="79"></span><span class="small">[ [p&gt;1⇒[strm append: &rsquo;(&rsquo;]].<br></span><span class="tab" val="79"></span><span class="small">var printon: strm indent: level precedence: 1<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="small">strm append: &rsquo; &larr; &rsquo;.<br></span><span class="tab" val="79"></span><span class="small">expr printon: strm indent: level+2 precedence: 1<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="small">p&gt;1⇒[strm append: &rsquo;)&rsquo;]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">var </span><span class="small">[⇑var]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪ParsedAssignment under: &rsquo;Compiler&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"ParsedBlock"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;ParsedBlock&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: Stream<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;returns&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">sharing: ByteCodes;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>I am a stream to collect the statements of a block and then to become a node in a compiler parse tree.</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Initialization</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">default<br></span><span class="tab" val="79"></span><span class="small">[limit &larr; 1. array &larr; Vector new: 1. position &larr; 0. returns &larr; false]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">doesReturn<br></span><span class="tab" val="79"></span><span class="small">[returns &larr; true]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">mustReturn: fromMethod<br></span><span class="tab" val="79"></span><span class="small">[returns⇒ []<br></span><span class="tab" val="79"></span><span class="small">[fromMethod⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[position&gt;0 and⦂ (array◦position) emitsLoad⇒ [array◦position &larr; toLoadSelf] self next &larr; toLoadSelf]].<br></span><span class="tab" val="79"></span><span class="small">self doesReturn]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Code generation</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForEffect: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[returns⇒ [self emitForValue: code on: stack. stack pop: 1]<br></span><span class="tab" val="79"></span><span class="small">self emitExceptLast: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">(array◦position) emitForEffect: code on: stack]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForValue: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[self emitExceptLast: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">(array◦position) emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">returns⇒ [code next &larr; toReturn]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">firstPush<br></span><span class="tab" val="79"></span><span class="small">[⇑(array◦1) firstPush]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForEffect: nextPush<br></span><span class="tab" val="79"></span><span class="small">[returns⇒ [⇑self sizeForValue]<br></span><span class="tab" val="79"></span><span class="small">⇑self sizeExceptLast + ((array◦position) sizeForEffect: nextPush)]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForTruth: trueSkip falsity: falseSkip<br></span><span class="tab" val="79"></span><span class="small">[returns⇒ [⇑self sizeForValue]<br></span><span class="tab" val="79"></span><span class="small">⇑self sizeExceptLast + (array◦position sizeForTruth: trueSkip falsity: falseSkip)]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForValue<br></span><span class="tab" val="79"></span><span class="small">[⇑self sizeExceptLast + (array◦position) sizeForValue + [returns⇒ [1] 0]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Miscellaneous</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: s </span><span class="small">| i<br></span><span class="tab" val="79"></span><span class="small">[s append: &rsquo;[&rsquo;.<br></span><span class="tab" val="79"></span><span class="small">for⦂ i to: position-1 do⦂ [s print: (array◦i); append: &rsquo;. &rsquo;].<br></span><span class="tab" val="79"></span><span class="small">[returns⇒ [s append: &rsquo;⇑&rsquo;]].<br></span><span class="tab" val="79"></span><span class="small">[position&gt;0⇒ [s print: (array◦position)]].<br></span><span class="tab" val="79"></span><span class="small">s append: &rsquo;]&rsquo;]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">quickCode </span><span class="small">| t v<br></span><span class="tab" val="79"></span><span class="small">[position=1 and⦂ (returns and⦂ (v&larr;array◦1) emitsLoad)⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[v=toLoadSelf⇒ [t &larr; String new: 2. t◦1&larr;0; ◦2&larr;1. ⇑t]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">v isField⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[t &larr; String new: 5. t◦1&larr;0; ◦2&larr;40; ◦3&larr;0; ◦4&larr;0; ◦5&larr;v. ⇑t]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">⇑false]<br></span><span class="tab" val="79"></span><span class="small">⇑false]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">returns<br></span><span class="tab" val="79"></span><span class="small">[⇑returns]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Private</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitExceptLast: code on: stack<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| i<br></span><span class="tab" val="79"></span><span class="small">[for⦂ i to: position-1 do⦂ [(array◦i) emitForEffect: code on: stack]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeExceptLast<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| i next nextPush size<br></span><span class="tab" val="79"></span><span class="small">[size &larr; 0. next &larr; array◦position.<br></span><span class="tab" val="79"></span><span class="small">for⦂ i to: position-1 do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[nextPush &larr; next firstPush. next &larr; array◦(position-i).<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">size &larr; size + (next sizeForEffect: nextPush)].<br></span><span class="tab" val="79"></span><span class="small">⇑size]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Decompiling</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">findMacros: macros compilerTemps: compilerTemps </span><span class="small">| i s t<br>"</span><span class="small italic">Look for </span><span class="small italic underline">for</span><span class="small italic"> statements.  If one of my statements is the init statement for a </span><span class="small italic underline">for</span><span class="small italic">, append myself and the index of that statement to the stream </span><span class="small italic underline">macros</span><span class="small italic">.  Mark its compiler-generated temp.  If the temp is subsequently used before being re-assigned, the pattern can&rsquo;t be a </span><span class="small italic underline">for</span><span class="small italic"> after all, and will be deleted from </span><span class="small italic underline">macros</span><span class="small italic">.</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">[for⦂ i to: position do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[s &larr; array◦i.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">(s isnt: ParsedAssignment) or⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">(s var&lt;codeLoadTemp or⦂ s var&gt;(codeLoadTemp+255))⇒  "</span><span class="small italic">not a </span><span class="small italic underline">for</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[s findMacros: macros compilerTemps: compilerTemps]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">t &larr; s var-codeLoadTemp+1.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">i≤(position-2) and⦂ (s isForFromToInit: array◦(i+1) loop: array◦(i+2))⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[macros next&larr; self; next&larr; i.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">compilerTemps◦t &larr; true.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">check other parts of the for</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">s expr findMacros: macros compilerTemps: compilerTemps.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">array◦(i+1) findMacros: macros compilerTemps: compilerTemps.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">(array◦(i+2)) doExpr findMacros: macros compilerTemps: compilerTemps.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">i &larr; i+2]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">i≤(position-1) and⦂ (array◦i isForFromInit: array◦(i+1))⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[macros next&larr; self; next&larr; i.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">compilerTemps◦t &larr; true.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">s expr findMacros: macros compilerTemps: compilerTemps.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">(array◦(i+1)) doExpr findMacros: macros compilerTemps: compilerTemps.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">i &larr; i+1]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">s findMacros: macros compilerTemps: compilerTemps]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">insertMacro: loc decompiler: decompiler </span><span class="small">| macro n i<br></span><span class="tab" val="79"></span><span class="small">["</span><span class="small italic">create a parsed for loop, and replace the old statements by it</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">macro &larr; ParsedForLoop new block: self loc: loc decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="small">array◦loc &larr; macro.<br></span><span class="tab" val="79"></span><span class="small">n &larr; macro nStatements.<br></span><span class="tab" val="79"></span><span class="small">for⦂ i from: loc+n to: position do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[array◦(i-n+1) &larr; array◦i].<br></span><span class="tab" val="79"></span><span class="small">position &larr; position-n+1]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: strm indent: level precedence: p forValue: v decompiler: decompiler </span><span class="small">| i<br></span><span class="tab" val="79"></span><span class="small">["</span><span class="small italic">ignore precedence, since the block is enclosed in brackets</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">position=0⇒[strm append: &rsquo;[]&rsquo; ]<br></span><span class="tab" val="79"></span><span class="small">strm append: &rsquo;[&rsquo;.<br></span><span class="tab" val="79"></span><span class="small">for⦂ i to: position-1 do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[array◦i printon: strm indent: level precedence: 0<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: false decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">strm append: &rsquo;.&rsquo;; crtab: level].<br></span><span class="tab" val="79"></span><span class="small"> [returns⇒[strm append: &rsquo;⇑&rsquo;]].<br></span><span class="tab" val="79"></span><span class="small">array◦position printon: strm indent: level precedence: 0<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: (returns or⦂ v) decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="small">strm append: &rsquo;]&rsquo; ]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>As yet unclassified</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForTruth: trueSkip falsity: falseSkip into: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[returns⇒ [self emitForValue: code on: stack]<br></span><span class="tab" val="79"></span><span class="small">self emitExceptLast: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">(array◦position) emitForTruth: trueSkip falsity: falseSkip into: code on: stack]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪ParsedBlock under: &rsquo;Compiler&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"ParsedConditional"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;ParsedConditional&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: Object<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;ifExpr thenExpr elseExpr thenSize elseSize jmpSize&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>I am a node in a compiler parse tree.  I represent a condition and two alternatives.</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Initialization</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">ifExpr: ifExpr thenExpr: thenExpr elseExpr: elseExpr</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Code generation</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForEffect: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[ifExpr emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">thenSize emitBfp: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">thenExpr emitForEffect: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">[jmpSize&gt;0⇒ [elseSize emitJmp: code on: stack]].<br></span><span class="tab" val="79"></span><span class="small">elseExpr emitForEffect: code on: stack]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForValue: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[ifExpr emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">thenSize emitBfp: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">thenExpr emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">stack pop: 1.<br></span><span class="tab" val="79"></span><span class="small">[jmpSize&gt;0⇒ [elseSize emitJmp: code on: stack]].<br></span><span class="tab" val="79"></span><span class="small">elseExpr emitForValue: code on: stack]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">firstPush<br></span><span class="tab" val="79"></span><span class="small">[⇑ifExpr firstPush]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForEffect: nextPush<br></span><span class="tab" val="79"></span><span class="small">[elseSize &larr; elseExpr sizeForEffect: nextPush.<br></span><span class="tab" val="79"></span><span class="small">jmpSize &larr; [thenExpr returns⇒ [0] elseSize jmpSize].<br></span><span class="tab" val="79"></span><span class="small">thenSize &larr; (thenExpr sizeForEffect: ¬1) + jmpSize.<br></span><span class="tab" val="79"></span><span class="small">⇑ifExpr sizeForValue + thenSize bfpSize + thenSize + elseSize]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForValue<br></span><span class="tab" val="79"></span><span class="small">[elseSize &larr; elseExpr sizeForValue.<br></span><span class="tab" val="79"></span><span class="small">jmpSize &larr; [thenExpr returns⇒ [0] elseSize jmpSize].<br></span><span class="tab" val="79"></span><span class="small">thenSize &larr; thenExpr sizeForValue + jmpSize.<br></span><span class="tab" val="79"></span><span class="small">⇑ifExpr sizeForValue + thenSize bfpSize + thenSize + elseSize]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Miscellaneous</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: s<br></span><span class="tab" val="79"></span><span class="small">[s append: &rsquo;if⦂ &rsquo;; print: ifExpr; append: &rsquo;then⦂ &rsquo;; print: thenExpr; append: &rsquo;else⦂ &rsquo;; print: elseExpr]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">returns<br></span><span class="tab" val="79"></span><span class="small">[⇑thenExpr returns and⦂ elseExpr returns]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Decompiling</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">findMacros: macros compilerTemps: compilerTemps<br></span><span class="tab" val="79"></span><span class="small">[ifExpr findMacros: macros compilerTemps: compilerTemps.<br></span><span class="tab" val="79"></span><span class="small">thenExpr findMacros: macros compilerTemps: compilerTemps.<br></span><span class="tab" val="79"></span><span class="small">elseExpr findMacros: macros compilerTemps: compilerTemps]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: strm indent: level precedence: p forValue: v decompiler: decompiler<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| pos char<br></span><span class="tab" val="79"></span><span class="small">[ifExpr printon: strm indent: level precedence: 0 <br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="small">strm append: &rsquo; ⇒&rsquo;.<br></span><span class="tab" val="79"></span><span class="small">[thenExpr position&gt;1 or⦂ (thenExpr◦1 is: ParsedConditional)⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[strm crtab: level+1] strm space].<br></span><span class="tab" val="79"></span><span class="small">thenExpr printon: strm indent: level+1 precedence: 0 <br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: v decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="small">elseExpr position=1 and⦂ elseExpr last≡nil⇒[]<br></span><span class="tab" val="79"></span><span class="small">strm crtab: level.<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">Kludge!! Delete brackets around else block</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">pos&larr;strm position.  char&larr;strm pop.<br></span><span class="tab" val="79"></span><span class="small">elseExpr printon: strm indent: level precedence: 0 <br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: v decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="small">strm skip: ¬1.  strm◦pos&larr;char]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪ParsedConditional under: &rsquo;Compiler&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"ParsedConjunct"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;ParsedConjunct&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: Object<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;left right rightSize&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">sharing: ByteCodes;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>I am a node in a compiler parse tree.  I represent (left and⦂ right) and try to optimize the code generation thereof.</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Initialization</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">left: left right: right</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Code generation</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForEffect: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[left emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">rightSize emitBfp: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">right emitForEffect: code on: stack]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForTruth: trueSkip falsity: falseSkip into: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[left emitForTruth: 0 falsity: rightSize+falseSkip into: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">right emitForTruth: trueSkip falsity: falseSkip into: code on: stack]<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForValue: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[left emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">rightSize emitBfp: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">right emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">1 emitJmp: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">code next &larr; toLoadFalse]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">firstPush<br></span><span class="tab" val="79"></span><span class="small">[⇑left firstPush]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForEffect: nextPush<br></span><span class="tab" val="79"></span><span class="small">[rightSize &larr; right sizeForEffect: ¬1.<br></span><span class="tab" val="79"></span><span class="small">⇑left sizeForValue + rightSize bfpSize + rightSize]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForTruth: trueSkip falsity: falseSkip<br></span><span class="tab" val="79"></span><span class="small">[rightSize &larr; right sizeForTruth: trueSkip falsity: falseSkip.<br></span><span class="tab" val="79"></span><span class="small">⇑(left sizeForTruth: 0 falsity: rightSize+falseSkip) + rightSize]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForValue<br></span><span class="tab" val="79"></span><span class="small">[rightSize &larr; right sizeForValue + 1.<br></span><span class="tab" val="79"></span><span class="small">⇑left sizeForValue + rightSize bfpSize + rightSize + 1]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Miscellaneous</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emittedReceiver<br></span><span class="tab" val="79"></span><span class="small">[⇑left]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emittedReceiver &larr; left</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: s<br></span><span class="tab" val="79"></span><span class="small">[s append: &rsquo;(&rsquo;; print: left; append:  &rsquo; and⦂ &rsquo;; print: right; append: &rsquo;)&rsquo;]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Decompiling</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">findMacros: macros compilerTemps: compilerTemps<br></span><span class="tab" val="79"></span><span class="small">[left findMacros: macros compilerTemps: compilerTemps.<br></span><span class="tab" val="79"></span><span class="small">right findMacros: macros compilerTemps: compilerTemps]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: strm indent: level precedence: p forValue: v decompiler: decompiler<br></span><span class="tab" val="79"></span><span class="small">[ [p≥2⇒[strm append: &rsquo;(&rsquo;]].<br></span><span class="tab" val="79"></span><span class="small">left printon: strm indent: level precedence: 2<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="small">strm append: &rsquo; and⦂ &rsquo;.<br></span><span class="tab" val="79"></span><span class="small">right printon: strm indent: level precedence: 2<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: v decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="small">p≥2⇒[strm append: &rsquo;)&rsquo;]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪ParsedConjunct under: &rsquo;Compiler&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"ParsedDisjunct"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;ParsedDisjunct&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: Object<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;left right rightSize&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">sharing: ByteCodes;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>I am a node in a compiler parse tree.  I represent (left or⦂ right) and try to optimize the code generation thereof.</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Initialization</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">left: left right: right</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Code generation</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForEffect: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[left emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">rightSize jmpSize emitBfp: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">rightSize emitJmp: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">right emitForEffect: code on: stack]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForTruth: trueSkip falsity: falseSkip into: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[left emitForTruth: rightSize+trueSkip falsity: 0 into: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">right emitForTruth: trueSkip falsity: falseSkip into: code on: stack]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForValue: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[left emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">(1 + rightSize jmpSize) emitBfp: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">code next &larr; toLoadTrue.<br></span><span class="tab" val="79"></span><span class="small">rightSize emitJmp: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">right emitForValue: code on: stack]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">firstPush<br></span><span class="tab" val="79"></span><span class="small">[⇑left firstPush]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForEffect: nextPush<br></span><span class="tab" val="79"></span><span class="small">[rightSize &larr; right sizeForEffect: ¬1.<br></span><span class="tab" val="79"></span><span class="small">⇑left sizeForValue + 1 + rightSize jmpSize + rightSize]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForTruth: trueSkip falsity: falseSkip<br></span><span class="tab" val="79"></span><span class="small">[rightSize &larr; right sizeForTruth: trueSkip falsity: falseSkip.<br></span><span class="tab" val="79"></span><span class="small">⇑(left sizeForTruth: rightSize+trueSkip falsity: 0) + rightSize]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForValue<br></span><span class="tab" val="79"></span><span class="small">[rightSize &larr; right sizeForValue.<br></span><span class="tab" val="79"></span><span class="small">⇑left sizeForValue + 2 + rightSize jmpSize + rightSize]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Miscellaneous</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emittedReceiver<br></span><span class="tab" val="79"></span><span class="small">[⇑left]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emittedReceiver &larr; left</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: s<br></span><span class="tab" val="79"></span><span class="small">[s append: &rsquo;(&rsquo;; print: left; append: &rsquo; or⦂ &rsquo;; print: right; append: &rsquo;)&rsquo;]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Decompiling</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">findMacros: macros compilerTemps: compilerTemps<br></span><span class="tab" val="79"></span><span class="small">[left findMacros: macros compilerTemps: compilerTemps.<br></span><span class="tab" val="79"></span><span class="small">right findMacros: macros compilerTemps: compilerTemps]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: strm indent: level precedence: p forValue: v decompiler: decompiler<br></span><span class="tab" val="79"></span><span class="small">[ [p≥2⇒[strm append: &rsquo;(&rsquo;]].<br></span><span class="tab" val="79"></span><span class="small">left printon: strm indent: level precedence: 2<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="small">strm append: &rsquo; or⦂ &rsquo;.<br></span><span class="tab" val="79"></span><span class="small">right printon: strm indent: level precedence: 2<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: v decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="small">p≥2⇒[strm append: &rsquo;)&rsquo;]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪ParsedDisjunct under: &rsquo;Compiler&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"ParsedFieldReference"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;ParsedFieldReference&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: Object<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;var toLoadVar toLoadFieldReference toObjectOffset&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">sharing: ByteCodes;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>I am a node in a compiler parse tree.  I represent a remote argument which is a reference to a method or instance variable.</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Initialization</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">var: var</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Code generation</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForValue: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[([var isField⇒ [toLoadSelf] toLoadTempframe]) emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">toLoadVar emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">toLoadFieldReference emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">code next &larr; toNew. toObjectOffset emitBytes: code..<br></span><span class="tab" val="79"></span><span class="small">stack pop: 2]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">local<br></span><span class="tab" val="79"></span><span class="small">[⇑var]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">remote: generator<br></span><span class="tab" val="79"></span><span class="small">[toLoadVar &larr; generator literal: (var land: 0177)+1.<br></span><span class="tab" val="79"></span><span class="small">toLoadFieldReference &larr; generator literal: FieldReference.<br></span><span class="tab" val="79"></span><span class="small">toObjectOffset &larr; generator encodeSel: ↪object:offset:]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForValue<br></span><span class="tab" val="79"></span><span class="small">[⇑ 2 + toLoadVar sizeForValue +<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">toLoadFieldReference sizeForValue + toObjectOffset sizeForValue]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Miscellaneous</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: s<br></span><span class="tab" val="79"></span><span class="small">[s append: &rsquo;FLD=&gt; &rsquo;; print: var]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Decompiling</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">findMacros: macros compilerTemps: compilerTemps<br></span><span class="tab" val="79"></span><span class="small">[var findMacros: macros compilerTemps: compilerTemps]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: strm indent: level precedence: p forValue: v decompiler: decompiler<br></span><span class="tab" val="79"></span><span class="small">[var printon: strm indent: level precedence: p<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪ParsedFieldReference under: &rsquo;Compiler&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"ParsedForLoop"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;ParsedForLoop&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: Object<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;var source start stop step doExpr nStatements&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">sharing: ByteCodes;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>I represent a for loop.  I am used only by the decompiler, not the compiler.</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Decompiling</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">block: block loc: loc decompiler: decompiler </span><span class="small">| init1 init2 loop s<br></span><span class="tab" val="79"></span><span class="small">["</span><span class="small italic">loc should point to the initialization statement for a </span><span class="small italic underline">for</span><span class="small italic"> loop in block</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">init1 &larr; block◦loc.<br></span><span class="tab" val="79"></span><span class="small">block◦(loc+1) is: ParsedLoop⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[nStatements &larr; 2.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">loop &larr; block◦(loc+1).<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">var &larr; loop whileExpr◦2.  doExpr &larr; loop doExpr.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">init statement creates a stream ... see if its an interval</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">s &larr; init1 expr rcvr.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">(s is: ParsedMessage) and⦂ (decompiler selector: s op)≡↪to:by: ⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[start &larr; s rcvr.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">stop &larr; s args◦1.  step &larr; s args◦2]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">source &larr; s]<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">must be a for⦂from:to:do⦂.  </span><span class="small italic underline">init1</span><span class="small italic"> will set up the limit, and </span><span class="small italic underline">init2</span><span class="small italic"> will<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small italic">initialize </span><span class="small italic underline">var</span><span class="small italic"> to start-1</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">nStatements &larr; 3.<br></span><span class="tab" val="79"></span><span class="small">init2 &larr; block◦(loc+1).  loop &larr; block◦(loc+2).<br></span><span class="tab" val="79"></span><span class="small">var &larr; init2 var.<br></span><span class="tab" val="79"></span><span class="small">start &larr; [init2 expr≡toLoad0</span><span class="tab" val="79"></span><span class="small">⇒[toLoad1] init2 expr rcvr].<br></span><span class="tab" val="79"></span><span class="small">stop &larr; init1 expr.  step &larr; toLoad1.<br></span><span class="tab" val="79"></span><span class="small">doExpr &larr; loop doExpr]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">nStatements<br></span><span class="tab" val="79"></span><span class="small">["</span><span class="small italic">return the number of statements in my expanded form</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">⇑nStatements]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: strm indent: level precedence: p forValue: v decompiler: decompiler<br></span><span class="tab" val="79"></span><span class="small">[source≡nil⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[strm append: &rsquo;for⦂ &rsquo;.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">var printon: strm indent: level precedence: 2<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small"> [start≡toLoad1⇒[] strm append: &rsquo; from: &rsquo;.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">start printon: strm indent: level precedence: 2<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler].<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">strm append: &rsquo; to: &rsquo;.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">stop printon: strm indent: level precedence: 2<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small"> [step≡toLoad1⇒[] strm append: &rsquo; by: &rsquo;.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">step printon: strm indent: level precedence: 2<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler].<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">strm append: &rsquo; do⦂&rsquo;; crtab: level+1.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">doExpr printon: strm indent: level+1 precedence: 0 <br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: false decompiler: decompiler]<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">source is a stream</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">strm append: &rsquo;for⦂ &rsquo;.<br></span><span class="tab" val="79"></span><span class="small">var printon: strm indent: level precedence: 2<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="small">strm append: &rsquo; from: &rsquo;.<br></span><span class="tab" val="79"></span><span class="small">source printon: strm indent: level precedence: 2<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="small">strm append: &rsquo; do⦂&rsquo;; crtab: level+1.<br></span><span class="tab" val="79"></span><span class="small">doExpr printon: strm indent: level+1 precedence: 0 <br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: false decompiler: decompiler]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪ParsedForLoop under: &rsquo;Compiler&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"ParsedLoop"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;ParsedLoop&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: Object<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;whileExpr doExpr whileSize doSize&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">sharing: ByteCodes;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>I am a node in a compiler parse tree.  I represent that part of an in-line loop statement that can be expressed in the while-do form.</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Initialization</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">whileExpr: whileExpr doExpr: doExpr</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Code generation</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForEffect: code on: stack<br></span><span class="tab" val="79"></span><span class="small">["</span><span class="small italic">optimization removed to make things easier for decompiler --<br></span><span class="tab" val="79"></span><span class="small italic">whileExpr emitForTruth: 0 falsity: doSize into: code on: stack.</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">whileExpr emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">doSize emitBfp: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">doExpr emitForEffect: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">0 - doSize - whileSize - doSize jmpSize emitJmp: code on: stack]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForValue: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[self emitForEffect: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">toLoadNil emitForValue: code on: stack]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">firstPush<br></span><span class="tab" val="79"></span><span class="small">[⇑whileExpr firstPush]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForEffect: nextPush<br></span><span class="tab" val="79"></span><span class="small">[doSize &larr; (doExpr sizeForEffect: ¬1) + 2.<br></span><span class="tab" val="79"></span><span class="small">"</span><span class="small italic">whileSize &larr; whileExpr sizeForTruth: 0 falsity: doSize.</span><span class="small">"<br></span><span class="tab" val="79"></span><span class="small">whileSize &larr; whileExpr  sizeForValue.<br></span><span class="tab" val="79"></span><span class="small">⇑whileSize + doSize + doSize jmpSize]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForValue<br></span><span class="tab" val="79"></span><span class="small">[⇑(self sizeForEffect: ¬1) + 1]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Miscellaneous</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: s<br></span><span class="tab" val="79"></span><span class="small">[s append: &rsquo;while⦂ &rsquo;; print: whileExpr; append: &rsquo;do⦂ &rsquo;; print: doExpr]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Decompiling</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">doExpr </span><span class="small">[⇑doExpr]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">findMacros: macros compilerTemps: compilerTemps<br></span><span class="tab" val="79"></span><span class="small">[whileExpr findMacros: macros compilerTemps: compilerTemps.<br></span><span class="tab" val="79"></span><span class="small">doExpr findMacros: macros compilerTemps: compilerTemps]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: strm indent: level precedence: p forValue: v decompiler: decompiler<br></span><span class="tab" val="79"></span><span class="small">[[whileExpr is: ParsedNegation⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[strm append: &rsquo;until⦂ &rsquo;.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">whileExpr negated printon: strm indent: level precedence: 2<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler]<br></span><span class="tab" val="79"></span><span class="small"> strm append: &rsquo;while⦂ &rsquo;.<br></span><span class="tab" val="79"></span><span class="small"> whileExpr printon: strm indent: level precedence: 2<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler].<br></span><span class="tab" val="79"></span><span class="small">strm append: &rsquo; do⦂&rsquo;; crtab: level+1.<br></span><span class="tab" val="79"></span><span class="small">doExpr printon: strm indent: level+1 precedence: 0 <br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: false decompiler: decompiler]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">whileExpr </span><span class="small">[⇑whileExpr]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪ParsedLoop under: &rsquo;Compiler&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"ParsedMessage"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;ParsedMessage&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: Object<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;rcvr op args "false if no args, Vector if many args" hasPC&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">sharing: ByteCodes;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>I am a node in a compiler parse tree.  I represent an expression consisting of a receiver (rcvr), a selector byte code (op), and an argument list (args) which is false for no arguments, a vector of parse trees for 2 or more arguments, or the argument parse tree for one argument.</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Initialization</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">hasPC </span><span class="small">[hasPC&larr; true]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">rcvr: rcvr op: op args: args<br></span><span class="tab" val="79"></span><span class="small">[hasPC&larr; false.<br></span><span class="tab" val="79"></span><span class="small">op=toEq and⦂ ((toLoadFalse≡rcvr) or⦂ (toLoadFalse≡args))⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[⇑ParsedNegation new rcvr: rcvr op: op args: args]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Code generation</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForEffect: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[self emitForValue: code on: stack. code next &larr; toPop. stack pop: 1]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForValue: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[args emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">rcvr emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">[rcvr≡toSuper⇒ [code next&larr;rcvr]].<br></span><span class="tab" val="79"></span><span class="small">op emitBytes: code. args argsOff: stack]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">firstPush<br></span><span class="tab" val="79"></span><span class="small">[⇑([args⇒ [args] rcvr]) firstPush]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForEffect: nextPush<br></span><span class="tab" val="79"></span><span class="small">[⇑self sizeForValue+1]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForValue<br></span><span class="tab" val="79"></span><span class="small">[⇑args sizeForValue + rcvr sizeForValue + op sizeForValue + [rcvr≡toSuper⇒ [1] 0]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Miscellaneous</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">args </span><span class="small">[⇑args]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">args&larr;args</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emittedReceiver<br></span><span class="tab" val="79"></span><span class="small">[⇑rcvr]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emittedReceiver &larr; rcvr</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">op </span><span class="small">[⇑op]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: s<br></span><span class="tab" val="79"></span><span class="small">[s append: &rsquo;(&rsquo;; print: rcvr; space; print: op.<br></span><span class="tab" val="79"></span><span class="small">[args⇒ [s space; print: args]].<br></span><span class="tab" val="79"></span><span class="small">s append: &rsquo;)&rsquo;]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">rcvr </span><span class="small">[⇑rcvr]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Decompiling</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">findMacros: macros compilerTemps: compilerTemps </span><span class="small">| vec a<br></span><span class="tab" val="79"></span><span class="small">[vec &larr; [args≡nil⇒[↪()] args is: Vector⇒[args] args inVector].<br></span><span class="tab" val="79"></span><span class="small">for⦂ a from: vec do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[a findMacros: macros compilerTemps: compilerTemps].<br></span><span class="tab" val="79"></span><span class="small">rcvr findMacros: macros compilerTemps: compilerTemps]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: strm indent: level precedence: p forValue: v decompiler: decompiler<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| sel keywords i parens myP vec char1<br></span><span class="tab" val="79"></span><span class="small">[sel &larr; decompiler selector: op.<br></span><span class="tab" val="79"></span><span class="small">myP &larr; [sel isinfix⇒[3]; iskeyword⇒[2]; isarrow⇒[1] 4].<br></span><span class="tab" val="79"></span><span class="small">"check if parens are needed"<br></span><span class="tab" val="79"></span><span class="small">parens &larr; [myP&lt;p or⦂ (p=2 and⦂ myP=2)].<br></span><span class="tab" val="79"></span><span class="small"> [parens⇒[strm append: &rsquo;(&rsquo;]].<br></span><span class="tab" val="79"></span><span class="small">char1&larr; strm position.<br></span><span class="tab" val="79"></span><span class="small">rcvr printon: strm indent: level precedence: myP<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler.<br></span><span class="tab" val="79"></span><span class="small"> [myP=4⇒[strm space; append: sel  "unary selector"]<br></span><span class="tab" val="79"></span><span class="small"> keywords &larr; sel keywords.<br></span><span class="tab" val="79"></span><span class="small">vec &larr; [args≡nil⇒[↪()] args is: Vector⇒[args] args inVector].<br></span><span class="tab" val="79"></span><span class="small"> for⦂ i to: keywords length do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[strm space; append: keywords◦i; space.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">vec◦i printon: strm indent: level <br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">precedence: [myP=3⇒[4] myP]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler]].<br></span><span class="tab" val="79"></span><span class="small">[hasPC⇒[decompiler highlight: (char1+1 to: strm position+1)]].<br></span><span class="tab" val="79"></span><span class="small">parens⇒[strm append: &rsquo;)&rsquo;]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪ParsedMessage under: &rsquo;Compiler&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"ParsedNegation"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;ParsedNegation&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: ParsedMessage<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">sharing: ByteCodes;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>I am a node in a compiler parse tree.  I am a parsed messsage in which the selector is ≡ and one of the participants is false.</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Initialization</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">rcvr: rcvr op: op args: args</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Code generation</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForTruth: trueSkip falsity: falseSkip into: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[([toLoadFalse≡rcvr⇒ [args] rcvr]) emitForTruth: falseSkip falsity: trueSkip into: code on: stack]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForTruth: trueSkip falsity: falseSkip<br></span><span class="tab" val="79"></span><span class="small">[⇑([toLoadFalse≡rcvr⇒ [args] rcvr]) sizeForTruth: falseSkip falsity: trueSkip]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Miscellaneous</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">negated </span><span class="small">[toLoadFalse≡rcvr⇒[⇑args] ⇑rcvr]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: s<br></span><span class="tab" val="79"></span><span class="small">[s append: &rsquo;(negation)&rsquo;. super printon: s]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪ParsedNegation under: &rsquo;Compiler&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"ParsedObjectReference"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;ParsedObjectReference&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: Object<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;var&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">sharing: ByteCodes;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>I am a node in a compiler parse tree.  I represent a remote argument which is a reference to a class or pool variable.</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Initialization</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">var: var</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Code generation</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForValue: code on: stack  </span><span class="small italic">"Turn literal indirect into literal direct"</span><span class="small bold"><br></span><span class="tab" val="79"></span><span class="small">[(var-256) emitForValue: code on: stack]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">local<br></span><span class="tab" val="79"></span><span class="small">[⇑var]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">remote: generator</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForValue<br></span><span class="tab" val="79"></span><span class="small">[⇑(var-256) sizeForValue]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Miscellaneous</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: s<br></span><span class="tab" val="79"></span><span class="small">[s append: &rsquo;OBJ=&gt; &rsquo;; print: var]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Decompiling</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">findMacros: macros compilerTemps: compilerTemps<br></span><span class="tab" val="79"></span><span class="small">[var findMacros: macros compilerTemps: compilerTemps]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: strm indent: level precedence: p forValue: v decompiler: decompiler<br></span><span class="tab" val="79"></span><span class="small">[strm append: (decompiler literal: var)]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪ParsedObjectReference under: &rsquo;Compiler&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"ParsedRemote"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;ParsedRemote&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: Object<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;expr esize toRemoteCopy&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">sharing: ByteCodes;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>I am a node in a compiler parse tree.  I represent an argument that is to be passed unevaluated.</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Initialization</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">expr: expr</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Code generation</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">emitForValue: code on: stack<br></span><span class="tab" val="79"></span><span class="small">[toLoadThisCtxt emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">toRemoteCopy emitBytes: code.<br></span><span class="tab" val="79"></span><span class="small">code emitLong: toLongJmp by: esize.<br></span><span class="tab" val="79"></span><span class="small">expr emitForValue: code on: stack.<br></span><span class="tab" val="79"></span><span class="small">code next &larr; toEnd. stack pop: 1.<br></span><span class="tab" val="79"></span><span class="small">(0-esize) emitJmp: code on: stack]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">local<br></span><span class="tab" val="79"></span><span class="small">[⇑expr]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">remote: generator<br></span><span class="tab" val="79"></span><span class="small">[toRemoteCopy &larr; generator encodeSel: ↪remoteCopy]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">sizeForValue<br></span><span class="tab" val="79"></span><span class="small">[esize &larr; expr sizeForValue + 3.<br></span><span class="tab" val="79"></span><span class="small">⇑esize + toRemoteCopy sizeForValue + 3]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Miscellaneous</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: s<br></span><span class="tab" val="79"></span><span class="small">[s append: &rsquo;⦂&rsquo;; print: expr]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Decompiling</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">findMacros: macros compilerTemps: compilerTemps<br></span><span class="tab" val="79"></span><span class="small">[expr findMacros: macros compilerTemps: compilerTemps]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">printon: strm indent: level precedence: p forValue: v decompiler: decompiler<br></span><span class="tab" val="79"></span><span class="small">[[(expr is: ParsedBlock) and⦂ <br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">(expr position&gt;1 or⦂ (expr◦1 is: ParsedConditional))⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[strm crtab: level+1]].<br></span><span class="tab" val="79"></span><span class="small">expr printon: strm indent: level+1 precedence: p<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">forValue: true decompiler: decompiler]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪ParsedRemote under: &rsquo;Compiler&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"Parser"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;Parser&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: Object<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;source dest oppositeCourt type token mark keep&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">sharing: TokenCodes;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>I parse tokens from source (a stream).  I report each parse node to dest (e.g., a code generator).  When an error occurs, I back up source to mark and notify dest.  I have two kinds of methods, token suppliers and token consumers, which coroutine with each other.  The coroutine that is not in control is suspended in the context, oppositeCourt.  Token suppliers are driven by an instance of class Reader that scans source and classifies each token by type.  Token consumers analyze the syntax and report it to dest.  The variable "keep" is no longer used.</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Initialization</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">from: source to: dest<br></span><span class="tab" val="79"></span><span class="small">[oppositeCourt &larr; thisContext.<br></span><span class="tab" val="79"></span><span class="small">mark &larr; source position. type &larr; 1.<br></span><span class="tab" val="79"></span><span class="small">(Reader new of: source) readInto: self]<br></span><span class="small italic">"Generator compile|Generator evaluate"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Token suppliers</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">comment: s<br></span><span class="tab" val="79"></span><span class="small">[mark &larr; source position]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">contents<br></span><span class="tab" val="79"></span><span class="small">[type &larr; 0. mark &larr; source position + 1.<br></span><span class="tab" val="79"></span><span class="small">thisContext sender &larr; nil.<br></span><span class="tab" val="79"></span><span class="small">while⦂ true do⦂ [self resume. self notify: &rsquo;MORE EXPECTED&rsquo;]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">float: i fraction: f exp: e<br></span><span class="tab" val="79"></span><span class="small">[token &larr; (i+&rsquo;.&rsquo;+f+&rsquo;e&rsquo;+e) asFloat.<br></span><span class="tab" val="79"></span><span class="small">type &larr; aNumber. self resume]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">identifier: token<br></span><span class="tab" val="79"></span><span class="small">[type &larr; aWord. self resume]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">integer: s<br></span><span class="tab" val="79"></span><span class="small">[token &larr; s asInteger.<br></span><span class="tab" val="79"></span><span class="small">type &larr; aNumber. self resume]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">keyword: token<br></span><span class="tab" val="79"></span><span class="small">[type &larr; aKeyword. self resume]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">leftparen<br></span><span class="tab" val="79"></span><span class="small">[type &larr; aLeftPar. self resume]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">onechar: token<br></span><span class="tab" val="79"></span><span class="small">[type &larr;<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[token=056⇒ [aPeriod];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">=0133⇒ [aLeftBrack];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">=0135⇒ [aRightBrack];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">=033⇒ [aCondArrow];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">=0137⇒ [aLeftArrow];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">=021⇒ [aReturnArrow];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">=073⇒ [aSemicolon];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">=017⇒ [aHand]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">aBinary].<br></span><span class="tab" val="79"></span><span class="small">self resume]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">otheratom: token<br></span><span class="tab" val="79"></span><span class="small">[type &larr; aGibberish. self resume]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">rightparen<br></span><span class="tab" val="79"></span><span class="small">[type &larr; aRightPar. self resume]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">separator: c</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">string: token<br></span><span class="tab" val="79"></span><span class="small">[type &larr; aString. self resume]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">trailer: s<br></span><span class="tab" val="79"></span><span class="small">[mark &larr; source position]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Method syntax</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">body: block  </span><span class="small">| p  </span><span class="small italic">"return the primitive number, or 0"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="small">[type=aLeftBrack⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[self block: block.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">type=aKeyword and⦂ token=&rsquo;primitive:&rsquo;⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[self advance. type=aNumber⇒ [p &larr; token. self advance. ⇑p]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">self notify: &rsquo;EXPECTED A NUMBER&rsquo;]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">⇑0]<br></span><span class="tab" val="79"></span><span class="small">⇑0]<br></span><span class="small italic">"Generator compile"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">declaration: block<br></span><span class="tab" val="79"></span><span class="small">[type≠aWord⇒ [self notify: &rsquo;EXPECTED AN ARGUMENT NAME&rsquo;]<br></span><span class="tab" val="79"></span><span class="small">dest declaration: block name: token asArg: true.<br></span><span class="tab" val="79"></span><span class="small">self advance]<br></span><span class="small italic">"pattern"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">pattern: block<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| selector<br></span><span class="tab" val="79"></span><span class="small">[selector &larr; Stream default.<br></span><span class="tab" val="79"></span><span class="small">[type=aWord⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[selector append: token. self advance];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">=aBinary⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[selector append: (UST1◦(token+1)). self advance; declaration: block]<br></span><span class="tab" val="79"></span><span class="small">while⦂ type = aKeyword do⦂ [selector append: token. self advance; declaration: block].<br></span><span class="tab" val="79"></span><span class="small">selector empty⇒ [self notify: &rsquo;EXPECTED A SELECTOR&rsquo;]].<br></span><span class="tab" val="79"></span><span class="small">[type=aLeftArrow⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[selector append: &rsquo;&larr;&rsquo;. self advance; declaration: block]].<br></span><span class="tab" val="79"></span><span class="small">⇑selector contents unique]<br></span><span class="small italic">"Generator compile|Context variableNamesInto"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">temporaries: block<br></span><span class="tab" val="79"></span><span class="small">[type=aBinary and⦂ token=0174⇒ </span><span class="small italic">"|"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[self advance.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">while⦂ type=aWord do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[dest declaration: block name: token asArg: false. self advance]]]<br></span><span class="small italic">"Generator compile|Context variableNamesInto"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Statement syntax</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">alternatives: ifExpr </span><span class="small italic">"⇒ [..] ..."</span><span class="small"><br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| thenExpr elseExpr<br></span><span class="tab" val="79"></span><span class="small">[self advance.<br></span><span class="tab" val="79"></span><span class="small">type≠aLeftBrack⇒ [self notify: &rsquo;EXPECTED A [BLOCK]&rsquo;]<br></span><span class="tab" val="79"></span><span class="small">thenExpr &larr; self block: dest block. elseExpr &larr; dest block.<br></span><span class="tab" val="79"></span><span class="small">[type=aSemicolon⇒ [self cascade: elseExpr after: ifExpr] self statements: elseExpr].<br></span><span class="tab" val="79"></span><span class="small">⇑dest ifExpr: ifExpr thenExpr: thenExpr elseExpr: elseExpr]<br></span><span class="small italic">"cascade"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">block: block<br></span><span class="tab" val="79"></span><span class="small">[self advance; statements: block.<br></span><span class="tab" val="79"></span><span class="small">type=aRightBrack⇒ [self advance. ⇑block]<br></span><span class="tab" val="79"></span><span class="small">self notify: &rsquo;PERIOD OR RIGHT BRACKET WAS EXPECTED&rsquo;]<br></span><span class="small italic">"body|alternatives|expression|keywordMessage|binaryMessage"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">cascade: block after: expr  </span><span class="small">| val var oldTemps<br></span><span class="tab" val="79"></span><span class="small">[var &larr; dest receivingVar: expr.<br></span><span class="tab" val="79"></span><span class="small">oldTemps &larr; dest balance.<br></span><span class="tab" val="79"></span><span class="small">while⦂ type=aSemicolon do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[self advance.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">(val &larr; self messageChain: var)≡var⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[self notify: &rsquo;MESSAGE EXPECTED&rsquo;].<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">type=aCondArrow⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[block next &larr; self alternatives: val. dest unbalance: oldTemps. ⇑self]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">block next &larr; val].<br></span><span class="tab" val="79"></span><span class="small">dest unbalance: oldTemps]<br></span><span class="small italic">"statement|alternatives"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">loopStmt: block  </span><span class="small">| oldMark<br></span><span class="tab" val="79"></span><span class="small">[oldMark &larr; mark. self keywordMessage: false loop: block⇒ [⇑self]<br></span><span class="tab" val="79"></span><span class="small">mark &larr; oldMark. self notify: &rsquo;UNKNOWN CONTROL MESSAGE&rsquo;]<br></span><span class="small italic">"statement"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">macro: block  </span><span class="small">| oldMark oldTemps val<br></span><span class="tab" val="79"></span><span class="small">[oldMark &larr; mark. oldTemps &larr; dest juggle.<br></span><span class="tab" val="79"></span><span class="small">val &larr; self keywordMessage: false macro: block.<br></span><span class="tab" val="79"></span><span class="small">dest unjuggle: oldTemps.<br></span><span class="tab" val="79"></span><span class="small">val⇒ [⇑block]<br></span><span class="tab" val="79"></span><span class="small">mark &larr; oldMark. self notify: &rsquo;UNKNOWN CONTROL MESSAGE&rsquo;]<br></span><span class="small italic">"statement"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">statement: block </span><span class="small">| expr<br></span><span class="tab" val="79"></span><span class="small">[type=aReturnArrow⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[self advance. block next &larr; self expression. block doesReturn.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[type=aPeriod⇒ [self advance]].<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">type≠aRightBrack⇒ [self notify:&rsquo;SHOULDN&rsquo;&rsquo;T FOLLOW RETURN&rsquo;]];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">= aKeyword⇒ [self macro: block. type&gt;aPeriod⇒ [self statement: block]];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">≤aPeriod⇒ [dest nullStatement: block] </span><span class="small italic">"doit eof aRightBrack aPeriod"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="small">expr &larr; self expression.<br></span><span class="tab" val="79"></span><span class="small">type=aCondArrow⇒ [block next &larr; self alternatives: expr]<br></span><span class="tab" val="79"></span><span class="small">block next &larr; expr.<br></span><span class="tab" val="79"></span><span class="small">type=aSemicolon⇒ [self cascade: block after: expr]]<br></span><span class="small italic">"statements"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">statements: block<br></span><span class="tab" val="79"></span><span class="small">[self statement: block.<br></span><span class="tab" val="79"></span><span class="small">while⦂ type=aPeriod do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[self advance. self statement: block]]<br></span><span class="small italic">"alternatives|block|Generator evaluate"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Expression syntax</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">binaryMessage: rcvr assign: assign </span><span class="small italic">"binarySelector ..."</span><span class="small"><br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| sel args<br></span><span class="tab" val="79"></span><span class="small">[sel &larr; token. self advance.<br></span><span class="tab" val="79"></span><span class="small">args &larr; [type=aLeftBrack⇒ [self block: dest block] self factor].<br></span><span class="tab" val="79"></span><span class="small">[assign and⦂ type=aLeftArrow⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[self advance.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">args &larr; [(Vector new: 2)◦1&larr;args; ◦2&larr;self expression; itself].<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">sel &larr; [(String new: 2)◦1&larr;sel; ◦2&larr;0137</span><span class="small italic">"&larr;"</span><span class="small">; itself]]].<br></span><span class="tab" val="79"></span><span class="small">⇑dest rcvr: rcvr selector: sel args: args]<br></span><span class="small italic">"term|messageChain"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">expression<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| var<br></span><span class="tab" val="79"></span><span class="small">[type=aLeftBrack⇒ [⇑self block: dest block];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">=aKeyword⇒ [⇑self macro: dest block];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">≠aWord⇒ [⇑self messageChain: self primary]<br></span><span class="tab" val="79"></span><span class="small italic">"It begins with a variable name"</span><span class="small"> var &larr; dest variable: token. self advance.<br></span><span class="tab" val="79"></span><span class="small">type≠aLeftArrow⇒ [⇑self messageChain: var]<br></span><span class="tab" val="79"></span><span class="small italic">"It is a variable assignment"</span><span class="small"> self advance.<br></span><span class="tab" val="79"></span><span class="small">⇑dest assignment: var expr: self expression]<br></span><span class="small italic">"unaryMessage|binaryMessage|keywordMessage|statement|subExpression"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">factor<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| expr<br></span><span class="tab" val="79"></span><span class="small">[expr &larr; self primary.<br></span><span class="tab" val="79"></span><span class="small">while⦂ type=aWord do⦂ [expr &larr; self unaryMessage: expr assign: false].<br></span><span class="tab" val="79"></span><span class="small">⇑expr]<br></span><span class="small italic">"term|binaryMessage"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">keywordMessage: rcvr macro: block </span><span class="small italic">"keyword ..."</span><span class="small"><br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| sel args arg<br></span><span class="tab" val="79"></span><span class="small">[sel &larr; Stream default. args &larr; (Vector new: 4) asStream.<br></span><span class="tab" val="79"></span><span class="small">while⦂ type = aKeyword do⦂<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[sel append: token. self advance.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">arg &larr; [type=aLeftBrack⇒ [self block: dest block] self term].<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">args next &larr; [sel last=03⇒ [dest noEvalKeyword: arg] dest evalKeyword: arg]].<br></span><span class="tab" val="79"></span><span class="small">[type=aLeftArrow⇒ [sel append: &rsquo;&larr;&rsquo;. args next &larr; [self advance; expression]]].<br></span><span class="tab" val="79"></span><span class="small">sel &larr; sel contents. args &larr; [args position=1⇒ [args last] args contents].<br></span><span class="tab" val="79"></span><span class="small">block⇒ [⇑dest macro: block selector: sel args: args]<br></span><span class="tab" val="79"></span><span class="small">⇑dest keywordMessage: rcvr selector: sel args: args]<br></span><span class="small italic">"macro|messageChain"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">messageChain: rcvr<br></span><span class="tab" val="79"></span><span class="small">[while⦂ type=aWord do⦂ [rcvr &larr; self unaryMessage: rcvr assign: true].<br></span><span class="tab" val="79"></span><span class="small">while⦂ type=aBinary do⦂ [rcvr &larr; self binaryMessage: rcvr assign: true].<br></span><span class="tab" val="79"></span><span class="small">[type = aKeyword⇒ [rcvr &larr; self keywordMessage: rcvr macro: false]].<br></span><span class="tab" val="79"></span><span class="small">⇑rcvr]<br></span><span class="small italic">"cascade|expression"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">term  </span><span class="small">| rcvr<br></span><span class="tab" val="79"></span><span class="small">[rcvr &larr; self factor.<br></span><span class="tab" val="79"></span><span class="small">while⦂ type=aBinary do⦂ [rcvr &larr; self binaryMessage: rcvr assign: false].<br></span><span class="tab" val="79"></span><span class="small">⇑rcvr]<br></span><span class="small italic">"keywordMessage"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">unaryMessage: rcvr assign: assign </span><span class="small italic">"word ..."</span><span class="small"><br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| sel args<br></span><span class="tab" val="79"></span><span class="small">[sel &larr; token. self advance.<br></span><span class="tab" val="79"></span><span class="small">args &larr;</span><span class="tab" val="79"></span><span class="small">[assign and⦂ type=aLeftArrow⇒ [sel &larr; sel + &rsquo;&larr;&rsquo;. self advance; expression] false].<br></span><span class="tab" val="79"></span><span class="small">⇑dest rcvr: rcvr selector: sel args: args]<br></span><span class="small italic">"factor|messageChain"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Primary syntax</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">literal </span><span class="small italic">"A Vector, UniqueString, String, or Number"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| t oldMark<br></span><span class="tab" val="79"></span><span class="small">[type<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">=aLeftPar⇒<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">[oldMark &larr; mark. self advance.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">t &larr; self read. type=aRightPar⇒ [self advance. ⇑t]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">mark &larr; oldMark. self notify: &rsquo;UNMATCHED&rsquo;]<br></span><span class="tab" val="79"></span><span class="small">t &larr; [type≥aKeyword⇒ [token unique]; ≤aBinary⇒ [UST1◦(token+1)] token].<br></span><span class="tab" val="79"></span><span class="small">self advance. ⇑t]<br></span><span class="small italic">"primary|read"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">primary<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| t<br></span><span class="tab" val="79"></span><span class="small">[type<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">=aWord⇒ [t &larr; dest variable: token. self advance. ⇑t];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">=aLeftPar⇒ [⇑self subExpression];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">=aNumber⇒ [t &larr; dest literal: token. self advance. ⇑t];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">=aString⇒ [t &larr; dest literal: token. self advance. ⇑t];<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">=aHand⇒ [self advance.<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">type=aRightPar or⦂ type=0⇒ [self notify: &rsquo;EXPECTED LITERAL&rsquo;]<br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">⇑dest literal: self literal]<br></span><span class="tab" val="79"></span><span class="small">self notify: &rsquo;OBJECT EXPECTED&rsquo;]<br></span><span class="small italic">"factor|expression"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">read </span><span class="small italic">"A sequence of literals"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| s<br></span><span class="tab" val="79"></span><span class="small">[s &larr; (Vector new: 10) asStream.<br></span><span class="tab" val="79"></span><span class="small">until⦂ (type=aRightPar or⦂ type=0) do⦂ [s next &larr; self literal].<br></span><span class="tab" val="79"></span><span class="small">⇑s contents]<br></span><span class="small italic">"literal"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">subExpression </span><span class="small italic">"(...)"</span><span class="small"><br></span><span class="tab" val="79"></span><span class="tab" val="79"></span><span class="small">| expr<br></span><span class="tab" val="79"></span><span class="small">[self advance. expr &larr; self expression.<br></span><span class="tab" val="79"></span><span class="small">type=aRightPar⇒ [self advance. ⇑expr]<br></span><span class="tab" val="79"></span><span class="small">self notify: &rsquo;NOT EXPECTED IN A (SUBEXPRESSION)&rsquo;]<br></span><span class="small italic">"primary"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Suspension</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">advance </span><span class="small italic">"Switch from the parser to the reader to obtain another token."</span><span class="small"><br></span><span class="tab" val="79"></span><span class="small">[mark &larr; source position- [type&gt;aBinary⇒ [1] 0].<br></span><span class="tab" val="79"></span><span class="small">oppositeCourt &larr; thisContext swapSender: oppositeCourt]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">mustBeDone<br></span><span class="tab" val="79"></span><span class="small">[type=0⇒ [self terminate] self notify: &rsquo;UNEXPECTED CONSTRUCT&rsquo;]<br></span><span class="small italic">"Generator compile|Generator evaluate"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">notify: errorString </span><span class="small">| delims<br></span><span class="tab" val="79"></span><span class="small">[source skip: mark - source position.<br></span><span class="tab" val="79"></span><span class="small">delims &larr; ↪(011 012  014 015 040).<br></span><span class="tab" val="79"></span><span class="small">while⦂ (delims has: source peek) do⦂ [source next].<br></span><span class="tab" val="79"></span><span class="small">[source myend≡false⇒ [source skip: 1]].<br></span><span class="tab" val="79"></span><span class="small">dest abortWith: errorString]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">resume </span><span class="small italic">"The reader has supplied another token; resume the parser."</span><span class="small"><br></span><span class="tab" val="79"></span><span class="small">[oppositeCourt &larr; thisContext swapSender: oppositeCourt]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">terminate<br></span><span class="tab" val="79"></span><span class="small">[[dest≡nil⇒ [] dest terminate. dest &larr; nil].<br></span><span class="tab" val="79"></span><span class="small">[oppositeCourt≡nil⇒ [] oppositeCourt release. oppositeCourt &larr; nil]]<br></span><span class="small italic">"mustBeDone|Generator abortWith|Context variableNamesInto"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪Parser under: &rsquo;Compiler&rsquo;.</span></div>
<div style="width: 141pt; margin-left: 425pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>"ParseStack"</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold">Class new title: &rsquo;ParseStack&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">subclassof: Object<br></span><span class="tab" val="79"></span><span class="medium bold">fields: &rsquo;position length&rsquo;<br></span><span class="tab" val="79"></span><span class="medium bold">declare: &rsquo;&rsquo;;<br></span><span class="tab" val="79"></span><span class="medium bold">asFollows</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small italic"><br>I keep track of the current and high position of the stack that will be needed by code being compiled.</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Initialization</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">init<br></span><span class="tab" val="79"></span><span class="small">[length &larr; position &larr; 0]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Changes</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">pop: n<br></span><span class="tab" val="79"></span><span class="small">[(position &larr; position - n) &lt; 0⇒ [user notify: &rsquo;Parse stack underflow&rsquo;]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">push: n<br></span><span class="tab" val="79"></span><span class="small">[(position &larr; position + n) &gt; length⇒ [length &larr; position]]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="medium bold"><br>Results</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">length<br></span><span class="tab" val="79"></span><span class="small">[⇑length]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small bold">position<br></span><span class="tab" val="79"></span><span class="small">[⇑position]</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small"></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="small">SystemOrganization classify: ↪ParseStack under: &rsquo;Compiler&rsquo;.</span></div>
  </body>
</html>
