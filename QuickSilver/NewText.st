'From Smalltalk 5.5k XM November 24 on 4 October 1990 at 11:42:27 pm.'\g"CharLine"l15000z20000\gbf5 Class new title: 'CharLine'	subclassof: Object	fields: '	starti "index of first character"				stopi		"index of last character"				spaces 	"# of ascii spaces in line"				inset		"relative inset from normal line start"				width	"line width, assuming some space width"				measure	" max allowed line width" '	declare: '';	asFollows\gbf5 A CharLine specifies the parameters of a measured line of text.  The text, and its default spacing and alignment, etc. is contained in the TextBox (and the latters stylesheet)\giInit/Access\gbf5 inset [inset]\gb6Binset: inset\gbspaces [spaces]\gb7Bstarti [starti]\gb7Bstarti: starti\gbstopi [stopi]\gb6Bstopi: stopi spaces: spaces width: width\gbwidth [width]\gb6BMeasure info\gbf5 measure [measure]\gb8Bmeasure: measure\gbpad	[measure-width/(spaces max: 1)]\gb5B1b30Bwhite	[measure-width]\gb7B\gSystemOrganization classify: CharLine under: 'NewText'.\g"Font"l15000z20000\gbf5 Class new title: 'Font'	subclassof: Object	fields: 'family pointsize minascii maxascii maxwidth length ascent descent xoffset raster glyphs xtable'	declare: '';	asFollows\gbf5 This class models the strike format for fonts.\giInitialization\gbf5 fromStrike: name | strike i split	"Build instance from strike file."	[name_name asUppercase.	split_name length-1. [(namesplit) isdigit[split_split-1]].	family_name copy: 1 to: split.	pointsize_(name copy: split+1 to: name length) asInteger.	strike _ (dp0 oldFile: name + '.strike.').	strike nextword.	"skip header"	minascii _ strike nextword. maxascii _ strike nextword.	maxwidth _ strike nextword. length _ strike nextword.	ascent _ strike nextword. descent _ strike nextword.	xoffset _ strike nextword.	"If (horrors!) we should ever kern."	raster _ strike nextword. glyphs _ strike next: self byteraster * self height.	xtable _ (Vector new: maxascii + 3) all_ 0.	for i from: (minascii + 1 to: maxascii + 3) do [xtablei _ strike nextword]]\gb17B17i34I241i13I195i36IAccess to Parts\gbf5 ascent [ascent]\gb7Bbyteraster [raster * 2]\gb11BcharForm: ascii ["should return a Form copied out of glyphs"]\gb16B1i43Idescent [descent]\gb8Bfamily [family]\gb7Bglyphs [glyphs]\gb7Bheight [ascent + descent]  "height of font"\gb7B19b2Bi1b6Bmaxascii [maxascii]\gb9Bmaxwidth [maxwidth]\gb9Bminascii [minascii]\gb9Bpointsize [pointsize]\gb10Braster [raster]\gb7Bspacewidth | w	[w _ self widthof: 040.	w = 0  [4] w]\gb16Bwidthof: glyph [(xtable(glyph + 2)) - (xtable(glyph + 1))]\gb15Bxtable [xtable]\gb7B\gSystemOrganization classify: Font under: 'NewText'.\g"FontSet"l15000z20000\gbf5 Class new title: 'FontSet'	subclassof: Object	fields: 'fonts'	declare: '';	asFollows\gbf5 Structure for holding a set of fonts.\giInit/Access\gbf5 font: n	[n>fonts length or n<1[user notify: 'font index out of range'] fontsn]\gb9B65b8Bfontfamily: f 	[(self font: f) family]\gb16B1b22Bfonts [fonts]\gb6Bfontsize: f 	[(self font: f) pointsize]\gb14B1b25BfromVector: v | n 	[v length>16[user notify: 'font vector too long']	fonts_Vector new: v length.	for n to: v length do [fontsn_Font new fromStrike: vn]]"DefaultFontSet_FontSet new fromVector: ('timesroman12', 'helvetica10', 'helvetica12', 'oldenglish18')."\gb14B4b2B\gSystemOrganization classify: FontSet under: 'NewText'.\g"ScreenPress"l15000z20000\gbf5 Class new title: 'ScreenPress'	subclassof: BitBlt	fields: '	x "position in micas"				y "position in micas"				spwidth "mica value for a space"				fontcode "ffff00ib: font number/bold/italic for current font"				font "the current strike Font"				widths "the current width table"				fonttab	"a vector (16) of fontcodes"				fontindex "so that fonttabfontindex=fontcode"				style "the current style (1 per press file)" '	declare: '';	asFollows\gbf5 I imitate a PressFile object, routing my output to the display. I currently understand text and rules (matching Spruce). The mica to point conversion factor, 2540/72 (~35.3), we approximate in tight loops by P=[M-(3M/32)]/32, because 29/1024=35.3 to 0.1%\giInit/Access\gbf5 fontindex: fontcode style: newstyle | n	[newstylestyle and stylenil[user notify: 'invalid style']	style_newstyle. fontcode_fontcode land: 0363.	(n_fonttab find: fontcode)>0[n]	"add entry to font dictionary"	fonttab length=16[user notify: 'too many fonts']	fonttab_fonttab, fontcode. fonttab length]\gb36B145b2B3i30I80b15Binit	[super init. fontcode_1. fonttab_Vector new: 0. color_1 "default black".	destbase_mem066. destraster_user screenrect width/32*2.	self setx: 0; sety: 0]\gb6B59i13Istrikepattern | s tint i	[s_Set new string: 16. for i from: 127 to: 200 do [s next_i].	user screenrect clear: white.	self fontindex: 0 style: DefaultFontSet; selectfont: 0; setspacex: 100;		setx: 2000; sety: 20000; setcolor: 5; showstr: s]"ScreenPress init strikepattern."\gb14Btestpattern | s tint	[s_'Folks, this is called Drop Shadowing'.	user screenrect clear: white.	self fontindex: 48 style: DefaultFontSet; selectfont: 0; setspacex: 100;		setx: 2000; sety: 20000; setcolor: 2; showstr: s;		setx: 2070; sety: 20070; setcolor: 5; showstr: s.	for tint to: 9 do		[self setx: 1000+(tint*2000); sety: 25000; setcolor: tint; showrectwidth: 900 height: 900]]"ScreenPress init testpattern."\gb12Btestpattern2 | s tint	[s_'Folks, this is called Drop Shadowing'.	user screenrect clear: ltgray.	self fontindex: 48 style: DefaultFontSet; selectfont: 0; setspacex: 100;		setx: 2000; sety: 20000; setcolor: 6; showstr: s.	for tint to: 9 do		[self setx: 1000+(tint*2000); sety: 25000; setcolor: tint; showrectwidth: 900 height: 900]]"ScreenPress init testpattern2."\gb13Bx [x]\gb2By [y]\gb2BSetting State\gbf5 selectfont: newfont | n	[newfont_newfont+1. newfont=fontindex[]	fontindex_newfont. fontcode_fonttabfontindex.	n_(fontcode lshift: 4)+1. font_style font: n.	widths_(WidthTable new named: (style fontfamily: n)		pointsize: (style fontsize: n) face: (fontcode/2 land: 1)+(fontcode*2 land: 2)) lookup.	sourceraster_font raster]\gb20B3b2Bsetcolor: c	[color_(1 0 32126 23130 21845 25500 27795 4740)c]			"black white ltgray gray red green blue yellow"\gb13Bsetspacex: spwidth\gbsetx: x\gbsety: y\gbshowrectwidth: w height: h | ty	[ty_27940-y-h. function_034 "store gray block to bank 1".	desty_ty inPts. destx_x inPts. width_w inPts max: 1. height_h inPts max: 1.	self callBLT]\gb27B35i26Ishowstr: str	[self showstr: str first: 1 last: str length]\gb14Bshowstr: str first: fi last: li | xtab ch wid t bold yslices yslice xskew savxskew xsave tone chi	[xtab_font xtable. xsave_x. sourcebase_font glyphs lock. bold_(fontcode land: 1)0.	t_font height. [fontcode\4<2[savxskew_0. yslices_t inVector]		savxskew_font ascent/4. yslices_Vector new: t+3/4. yslices all_4; last_t-1\4+1]. 	for tone to: 2 do	"erase/paint loop"		[tone-color=2[] function_(023 "erase dest" 031 "or in under mask")tone.		desty_(27940-y) inPts-font ascent. sourcey_0. xskew_savxskew.		for yslice from: yslices do	"italic (sliceup) loop"			[height_yslice. x_xsave.			for chi from: fi to: li do		"character loop"				[ch_strchi. [ch=040[wid_spwidth] wid_widths widthof: ch.					t_x lshift: 5. destx_((x-(t+t+t)) lshift: 5)+xskew.					sourcex_(t_xtab(ch+1)). width_xtab(ch+2)-t. self callBLT. "char print"					bold[destx_destx+1. self callBLT]]. "embolden"				x_x+wid].			desty_desty+yslice. sourcey_sourcey+yslice. xskew_xskew-1]]. 	font glyphs unlock]\gb32B320i16I37i10I7i16I106i21I64i14I190i10I45i8I\gSystemOrganization classify: ScreenPress under: 'NewText'.\g"ScreenPressFile"l15000z20000\gbf5 Class new title: 'ScreenPressFile'	subclassof: PressFile	fields: 'x y'	declare: '';	asFollows\gbf5 I augment class PressFile for text related functions, and also keep track of the last setx and sety, thus resembling ScreenPress\giAccess\gbf5 pressfile: name [super of: (dp0 file: name)]\gb16Bsetcolor: c	[super hue: (0 0 0 0 0 80 140 40)c;	saturation: (0 0 0 0 255 255 255 255)c;	brightness: (0 255 100 150 255 255 255 255)c]\gb13Bsetx: x	[super setx: x]\gb9Bsety: y	[super sety: y]\gb9Bshowstr: str 	[self showstr: str first: 1 last: str length]\gb15Bshowstr: str first: fi last: li | w ch chi spwidth	[super append: (str(fi to: li)); showchars: li-fi+1. spwidth_estate2.	w_fontdefs(estate1+1). for chi from: fi to: li do		[ch_strchi. x_x+[ch=040[spwidth]w widthof: ch]]]\gb32B18b2Btestpattern | s tint i	[s_'Folks, this is called Drop Shadowing'.	user screenrect clear: white.	self fontindex: 51 style: DefaultFontSet; selectfont: 0; setspacex: 100.	for i to: 10 do		[self setx: 2000; sety: 2000*i; setcolor: 4; showstr: s;		setx: 2000+i; sety: 2010*i; setcolor: 5; showstr: s]] "|P. P_ScreenPressFile new pressfile: 'shadow.press'. P testpattern; close."\gb12Bx [x]\gb2By [y]\gb2B\gSystemOrganization classify: ScreenPressFile under: 'NewText'.\g"Text"l15000z20000\gbf5 Class new title: 'Text'	subclassof: Object	fields: '	para				"the text"				color				"0..7 denoting a color"				lines				"vector of CharLines"				lastline			"index 1lastlinelines length of last visible line"				fontset			"the 16 fonts used"				linespercol		"# of lines per column"				columns		"# of columns --all subsequent values are in Micas"				origin			"the upper-lefthand corner of the text"				tabs				"vector of monotonically increasing offsets"				lineheight		"baseline to baseline; bodyheight+leading"				bodyheight		"char height of body text"				ascent			"dist above baseline for body text"				descent			"dist beneath baseline (pos)"				minsp			"default interword space"				maxsp			"max interword space"				linemeasure	"default line measure"				columnspace	"inter column spacing " '	declare: 'attributes curface chartype curwidths ';	asFollows\gbf5 I window text taken from para onto a screen or page, defined in region frame, using fonts and line measures from style. lines maintains line break and line measure info.\giInit/Access\gbf5 attributes [attributes viewee: self]\gb11B1b24BattributesInit "Text classInit. Text new attributesInit."	|	unitviewer integerviewer colorviewer		columnsmenu linesmenu spacingmenu	[	unitviewer_UnitViewer default units:			(('micas',1) inVector, ('pts',35.3), ('picas',423.3), ('cm',899.75), ('in',2540.0)).		integerviewer_[AttributeViewer new			toString:		asString;			fromString	[attributeValue_attributeText asStream integerScan asInteger] ].		colorviewer_[AttributeViewer new			menu: [ActionMenu new				stringFromVector:					('black','white','light gray','gray','red','green','blue','yellow'); init;				action_(0,1,2,3,4,5,6,7)] ].		linesmenu_AttributeMenu new.			linesmenu title: 'total number';				extract: totlines; assign: nil; viewer: integerviewer copy.			linesmenu title: 'per column';				extract: linespercol; assign: nil; viewer: integerviewer copy.			linesmenu title: 'default measure';				extract: linemeasure; assign: nil; viewer: unitviewer copy.		columnsmenu_AttributeMenu new.			columnsmenu title: 'number';				extract: columns; assign: nil; viewer: integerviewer copy.			columnsmenu title: 'spacing';				extract: columnspace; assign: nil; viewer: unitviewer copy.		spacingmenu_AttributeMenu new.			spacingmenu title: 'body height';				extract: bodyheight; assign: nil; viewer: unitviewer copy.			spacingmenu title: 'leading';				extract: linelead; assign: 'linelead:'; viewer: unitviewer copy.			spacingmenu title: 'min interword';				extract: minsp; assign: nil; viewer: unitviewer copy.			spacingmenu title: 'max interword';				extract: maxsp; assign: nil; viewer: unitviewer copy.		attributes_AttributeMenu new.			attributes title: 'Color';				extract: color; assign: 'color:'; viewer: colorviewer.			attributes title: 'Columns';				extract: itself; assign: nil; viewer: columnsmenu.			attributes title: 'Lines';				extract: itself; assign: nil; viewer: linesmenu.			attributes title: 'Spacing';				extract: itself; assign: nil; viewer: spacingmenu  ]\gb15Bbodyheight [bodyheight]\gb11B1b11BcharInit "Text classInit. Text new charInit."	[	chartype_String new: 256.		chartype all_4.		"Normal Char"		chartype011_0.	"Tab"		chartype015_1.	"<CR>"		chartype040_2.	"Space"		chartype020_3.	"Misc. Spacing"		chartype055_5.	"Hyphen"		curface_false  ]\gb9B85i13I20i4I44i7I19i15I19i8IclassInit "Text classInit."	[	self attributesInit; charInit  ]\gb10Bcolor [color]\gb6B1b6Bcolor: color\gbcolumns [columns]\gb8B1b8Bcolumnspace [columnspace]\gb12B1b12Bframe	[(origin x)(origin y-descent-2) extent:		(linemeasure+columnspace*columns-columnspace)(linespercol*lineheight)]\gb7B1b113Bframe: frame para: para fontset: fontset columns: columns | i	[origin_frame origin copy.	bodyheight_(fontset font: 1) height inMicas. lineheight_bodyheight+71.	tabs_lineheight inVector. minsp_bodyheight/5. maxsp_bodyheight.	ascent_465. descent_92. columnspace_400.	linemeasure_frame width-(columns-1*columnspace)/columns.	linespercol_frame height/lineheight.	lines_Vector new: self totlines. color_0. "black"	for i to: self totlines do		[linesi_CharLine new. linesi measure: linemeasure; inset: 0] ]\gb58B351i5Ilastline [lastline]\gb9B1b9Blastshown [(lineslastline) stopi]\gb10B1b23Blinelead [lineheight-bodyheight]\gb9B1b22Blinelead: linelead [lineheight_bodyheight+linelead]\gb19Blinemeasure [linemeasure]\gb12B1b12Blines [lines]\gb6B1b6Blinespercol [linespercol]\gb12B1b12Bmaxsp [maxsp]\gb6B1b6Bminsp [minsp]\gb6B1b6Borigin [origin]\gb7B1b7Borigin: origin\gbpara [para]\gb5B1b5Bptframe: f para: p	[self frame: f inMicas para: p fontset: DefaultFontSet columns: 1]\gb20B66bptframe: f para: p columns: columns	[self frame: f inMicas para: p fontset: DefaultFontSet columns: columns]\gb37Btest"|P T f i.P_('This is an easy little test, which tries to fit as much text as it can into a large oval. As you can see, it is quite nice.  Sorry that the text is rather trite, but this is needed to test out the code. Of course, any shape will do, but those with simple math defs. are best, on the whole.') asParagraph. P allFont: 0. P alignment_1. T_Text new ptframe: Rectangle new usersize para: P columns: 2.user screenrect clear: white. T outline. T showall. while user anybug do	[(T rectofline: (T lineofpt: user mp inMicas)) inPts comp]"\gb5Btotlines [linespercol*columns]\gb9B1b20BCopy Fitting\gbf5 copyfitall [self copyfitall: 1]\gb11Bcopyfitall: firsti [(lines1) starti: firsti. self copyfitfrom: 1 to: lines length]\gb19Bcopyfitfrom: startline to: stopline | maxlength chari i curline	[maxlength_para length. chari_(linesstartline) starti.	for i from: startline to: stopline do		[chari_chari+[chartype(para textchari)>3[0] 1].		(curline_linesi) starti: chari. self fitline: curline.		(chari_curline stopi+1)>maxlength[lastline_i. nil] ].	lastline_lines length]\gb36B286b4Bfitline: line| em width bwidth spaces bspaces chari bchari rs ri rlen body oldbody lasti ch	[em_bodyheight. width_bwidth_spaces_bspaces_0.	chari_bchari_line starti. lasti_para length. body_4.	rs_para runfind: line starti. ri_rs1. rlen_(para runsri)-(rs2)+1.	self widthtable: para runs(ri+1).	until ((widthline measure or chari>lasti) or (body=1)) do		[[body=5[bwidth_width. bspaces_spaces. bchari_chari]]. "was hyphen"		[rlen=0[ri_ri+2. rlen_para runsri. self widthtable: (para runs(ri+1))]]. "new run"		ch_para textchari. oldbody_body. body_chartypech.		[body<4[[oldbody>3[bwidth_width. bspaces_spaces. bchari_chari]]. "sp tab cr white"			body=2[width_width+minsp. spaces_spaces+1]; =0[width_width+em|em]]].		[body>2[width_width+(curwidths widthof: ch)]]. "white text hyphen"		chari_chari+1. rlen_rlen-1].	chari>lasti or spaces=0[line stopi: chari-1 spaces: spaces width: width]		line stopi: bchari-1 spaces: bspaces width: bwidth]\gb14B410i10I81i7I126i15I127i17Ishrinktofit | i	[linemeasure_0.	for i to: lastline do [linemeasure_linemeasure max: (linesi) width].	for i to: lastline do [(linesi) measure: linemeasure].	self copyfitall]	\gb12Bwidthtable: face | i	[facecurface		[curface_face. i_(face lshift: 4)+1.		curwidths_(WidthTable new named: (fontset fontfamily: i)		pointsize: (fontset fontsize: i)		face: (face/2 land: 1)+(face*2 land: 2)) lookup. curwidths]]\gb17B205b10BLayout Info\gbf5 xend: linei 	[(self xstart: linei)+((lineslinei) measure)]\gb14B1b45Bxstart: linei	[origin x+(lineslinei) inset+(linei-1/linespercol*(linemeasure+columnspace))]\gb15B1b77Bystart: linei 	[origin y+(linespercol-(linei-1\linespercol+1)*lineheight)]\gb16B1b58BDisplaying\gbf5 displaylines: firsti to: lasti press: p | linei line curi newcuri runs runi run x1 y1 x2	[p setcolor: color+1.	for linei from: firsti to: lasti do		[line_lineslinei. curi_line starti. curinil[nil]		p	sety: (self ystart: linei);			setx: (self xstart: linei)+[para alignment=2[line white/2]; =3[line white]0];			setspacex: ((minsp+[para alignment=1[line pad]0]) min: maxsp).		runs_(para run: line starti to: line stopi).		for runi from: (1 to: runs length by: 2) do			[p	selectfont: ((p fontindex: (run_runs(runi+1)) style: fontset)-1). x1_p x.			p showstr: para text first: curi last: (newcuri_runsruni+curi-1). curi_newcuri+1.			[(run land: 12)0[x2_p x. y1_self ystart: linei. p setx: x1]].			[(run land: 4)0[p sety: ascent/4+y1; showrectwidth: x2-x1 height: 20]].			[(run land: 8)0[p sety: y1-descent; showrectwidth: x2-x1 height: 20]].			[(run land: 12)0[p setx: x2; sety: y1]]]]]\gb40Boutline	[self frame inPts boxcomp]\gb9Bpresson: press	[self displaylines: 1 to: lines length press: press]\gb16Bshowall [self presson: (ScreenPress init)]\gb8Bunshowall [self frame inPts clear: white]\gb10Bunshowlines: startline to: stopline | i	[for i from: startline to: stopline do [(self rectofline: i) inPts clear: white] ]\gb36BLine Selection\gbf5 lastusedline	[self lineofchar: para text length]\gb14Blineofchar: chari | i	[chari=0[1]. for i to: lastline do		[(linesi) startinil or ((linesi) starti-1>chari)[i-1]].	self lastline]"lineofchar: chari | lo mid hi	[chari=1[1] hi_self totlines+1.  lo_1.	while lo<hi do		[(lines(mid_lo+hi/2)) starti<chari[hi_mid] lo_mid+1].	hi-1]	0resultlength"\gb18B15b2B83b4B5b14B1b20B23b2B106b5B2i15Ilineofpt: pt | x y row col	[x_pt x-origin x. y_pt y-origin y.	col_(x/(linemeasure+columnspace) min: columns-1) max: 0. 	row_(linespercol-1-(y/lineheight) min: linespercol-1) max: 0.	(col*linespercol+row+1) min: lastline]\gb13B173b38Brectofline: linei	[Rectangle new origin: ((self xstart: linei)((self ystart: linei)-descent))		extent: (lineslinei) measure(ascent+descent)]\gb19B1b125Bwidthsofline: linei | line em firsti lasti m chi pad width rs rlen ch	[line_lineslinei. em_bodyheight. firsti_line starti. lasti_line stopi.		m_Vector new: (lasti-firsti+2). width_self xstart: linei.	pad_(minsp+[para alignment=1[line pad]0]) min: maxsp.	width_width+[para alignment=2[line white/2]; =3[line white]0].	m1_width. rs_(para run: firsti to: lasti) asStream. rlen_0.	for chi from: firsti to: lasti do "chari>lasti needed?"		[[rlen=0[rlen_rs next. self widthtable: rs next]]. "new run"		ch_para textchi.		[(chartypech)			=2[width_width+pad]; "space"			=1[];	"cr"			=0[width_width+em|em].	"tab"			width_width+(curwidths widthof: ch)]. "else: white, text or hyphen"		m(chi-firsti+2)_width. rlen_rlen-1]. m]\gb20B49b2B354i19I57i7I65i5I13i2I30i3I44i27I42b2B\gSystemOrganization classify: Text under: 'NewText'.\gText classInit\g"TextEditor"l15000z20000\gbf5 Class new title: 'TextEditor'	subclassof: Object	fields: 'text currect curline curmeasure c1line c1index c1offset c2line c2index c2offset line index offset attributes'	declare: 'alignmenu fontmenu cutbuffer CrossCursor cursor editmenu lookmenu ';	asFollows\gbf5 I edit the para in a textbox. I also change other TextBox fields\giInit/Access\gbf5 classInit "TextEditor classInit."	[	self cursorInit; menuInit; editInit  ]\gb10BcursorInit "TextEditor classInit. TextEditor new cursorInit."	[	CrossCursor_Cursor new fromtext: '0000000000000000000000001000000000000000100000000000000010000000000000001000000000000000100000000000000010000000000000001000000001111111111111110000000010000000000000001000000000000000100000000000000010000000000000001000000000000000100000000000000010000000' offset: 88  ]\gb11Bedit: text | frame pt	[c1index_c2index_(text lines1) starti-1. self pointofindicies; selectall.	frame_text frame inPts. attributes_false.	while true do		[while user nobug do [self updateCursor. user kbck[self kbd] ].		user redbug			[self attributesAt: (pt_user mp)				[self attributesEdit]				frame has: pt					[self redbug]					self selectall; unshowAttributes. nil]		user yellowbug[self yellowbug] ] ]\gb11B371b4BeditInit "TextEditor classInit. TextEditor new editInit."	|	i arrow	[	cutbuffer_''.	 	arrow_String new: 12.		for i to: 6 do [arrow word: i_((4 14 31 4 4 4)i) lshift: 11].		cursor_Form new. cursor extent: (166); bits: arrow  ]\gb9BmenuInit "TextEditor classInit. TextEditor new menuInit."	|	v i	[	v_Vector new: 0.		for i from: DefaultFontSet fonts do			[v_v,((i family copy: 1 to: (i family length min: 4))+i pointsize asString)].		editmenu_MenuSet new default init.			editmenu add: [(ActionMenu new) string:'copypastecutfontlookalignattributes'; init].			editmenu add: [(ActionMenu new) stringFromVector: v; init].			editmenu add: [(ActionMenu new) string:'clearbolditalicunderscorestrikeout'; init].			editmenu add: [(ActionMenu new) string:'left flushjustifycenterright flush'; init].			editmenu firstmenu_1.			editmenu menu: 1 line: 4 tomenu: 2.			editmenu menu: 1 line: 5 tomenu: 3.			editmenu menu: 1 line: 6 tomenu: 4  ]\gb9Btest | P T "TextEditor new test."	[P_('This is an easy little test, which tries to fit as much text as it can into a large oval. As you can see, it is quite nice. Sorry that the text is rather trite, but this is needed to test out the code. Of course, any shape will do, but those with simple math defs. are best, on the whole. Note too, that the border may in fact be a curved line, as is the case here, and not simply a set of straight edges. Sorry that the text is rather silly, but this is needed to test out the code. Of course, any shape will do, but those with simple math defs. are best, on the whole. Note too, that the border may in fact be a curved line, as is the case here, and not simply a set of straight edges. Well now, I hope you liked our little demo.') asParagraph.	P allFont: 0. P alignment_1. user screenrect clear: white.	T_Text new ptframe: Rectangle new usersize para: P columns: 2."	T_Text new ptframe: (27133 rect: 471200) para: P columns: 2.  "	T copyfitall; showall; outline. self edit: T]\gb5BSelection/Keyboard\gbf5 charpoint | pt charline i newline oldindex	[oldindex_index. [pt_user mp inMicas. [(currect has: pt)[]		curline_text lineofpt: pt. currect_text rectofline: curline.		curmeasure_text widthsofline: curline].	charline_(text lines)curline. line_curline.	pt x(curmeasure1)[index_charline starti-1. offset_curmeasure1];		(curmeasure last)[index_charline stopi. offset_curmeasure last].	i_curmeasure findSorted: pt x.	[(curmeasure(i+1)-pt x)>(pt x-(curmeasurei))[i_i-1]].	index_charline starti+i-1. offset_curmeasure(i+1)]. oldindexindex]\gb10B527b15Bdoubleclick | min thismax nextmax lbody rbody	[min_(text linesc1line) starti-1. thismax_(text linesc1line) stopi.	[c1line=text lines length[nextmax_text para length]		nextmax_(text lines(c1line+1)) starti-1].	[c1index=min[c2index_nextmax]	"line select or rangle select"		until (c1index=min or text parac1index=040) do [c1index_c1index-1].		until (c2index=thismax or text para(c2index+1)=040) do [c2index_c2index+1]].	self pointofindicies]\gb12B33b2B202i28Ikbd | s	[s_Set new string: 16. while user kbck do [s next_user kbdnext].	self replacewith: s select: false]\gb4B3b2Bpointofindicies | i	[c1line_text lineofchar: c1index. curmeasure_text widthsofline: c1line.	i_c1index-(text linesc1line) starti+2.	[i>curmeasure length[c1offset_curmeasure last] c1offset_curmeasurei].	c2line_curline_text lineofchar: c2index. curmeasure_text widthsofline: c2line.	i_c2index-(text linesc2line) starti+2.	[i>curmeasure length[c2offset_curmeasure last] c2offset_curmeasurei].	currect_text rectofline: c2line]\gb16B3b2Bredbug	[self selectall. "deselect".	c1index=c2index and: self charpoint=false[self doubleclick; selectall] "side-effect"	c2line_c1line_line. c2index_c1index_index. c2offset_c1offset_offset.	self select. while user redbug do		[self charpoint[self select. c1index_index. c1offset_offset. c1line_line].		c2index=index[self showcursor; showcursor]]	c2index=index[self showcursor]]\gb8B18i8I77i11Iselect | l1 l2 c1 c2 o1 o2 r i	[[index<c1index		[l2_line. l1_c1line. c2_index. c1_c1index. o2_offset. o1_c1offset]		l1_line. l2_c1line. c1_index. c2_c1index. o1_offset. o2_c1offset].	r_[l2=curline[currect copy] text rectofline: l2]. r origin x_o2.	l1=l2[r corner x_o1. r pointize comp]	r pointize comp. for i from: l2+1 to: l1-1 do [(text rectofline: i) pointize comp].	r_text rectofline: l1. r corner x_o1. r pointize comp]	\gb7B23b2Bselectall	[c2index=c1index[self showcursor] line_c2line. index_c2index. offset_c2offset.	self select. c2line_line. c2index_index. c2offset_offset]\gb11Bselection [text para copy: (c1index min: c2index)+1 to: (c1index max: c2index)]\gb10B1b68Bshowcursor	[cursor displayat: (((text widthsofline: c2line)(c2index-(text linesc2line) starti+2))-71		(text ystart: c2line)) inPts effect: xoring clippedBy: nil]\gb12BMenu/Actions\gbf5 align: i	[text unshowall. text para alignment_i-1. text showall. self selectall]\gb10Bfont: i	[self replacewith: (self selection maskrunsunder: 0360 to: (i-1*16))	select: true]\gb9Blook: i	[self replacewith: (self selection maskrunsunder: (15 1 2 8 4)i to: (0 1 2 8 4)i)		select: true]\gb9Breplacewith: scrap select: sflag | c1 c2 l1 l2 last i	[c1_(c1index min: c2index)+1. c2_c1index max: c2index.	l1_ c1line min: c2line. l2_c1line max: c2line.	self selectall.	text para replace: c1 to: c2 by: scrap.	text copyfitfrom: l1 to: text totlines.	"optimize later"	last_text lastline.	text unshowlines: l1 to: text totlines.	text displaylines: l1 to: last press: (ScreenPress init).	c1index_c1-1+scrap length. [sflag[c2index_c1-1] c2index_c1index].	self pointofindicies; selectall]\gb33B20b2B203i14Iyellowbug | v menu item	[(v_editmenu bug)false[ ]	menu_editmenu find: v1. item_v2.	menu		=1	"main"				[item				=1	"copy"			[cutbuffer_self selection];				=2	"paste"			[self replacewith: cutbuffer select: true];				=3	"cut"				[cutbuffer_self selection. self replacewith: '' select: true];				=7	"attributes"	[self flipAttributes] ];		=2	"font"					[self font: item];		=3	"look"					[self look: item];		=4	"align"				[self align: item] ]\gb10B13b2B76i6I18i6I39i7I55i5I75i12I32i7I30i7I30i8IAttributes\gbf5 attributes [text attributes]\gb11B1b16BattributesAt: pt [attributes[attributes has: pt] false]\gb17B13b19B2b6BattributesEdit | f	[NormalCursor show. self selectall. f_text frame inPts.	[attributes Bug		[attributes unshow.		f clear: white. text copyfitall: ((text lines1) starti); showall.		attributes reshow] ].	self selectall]\gb15B3b2BflipAttributes [attributes[self unshowAttributes] self showAttributes]\gb15BshowAttributes | pt	[CrossCursor show. user waitbug. pt_user mp. NormalCursor show.	attributes_text attributes. attributes showat: (pt-(attributes frame extent/2))]\gb15BunshowAttributes [attributes[attributes unshow. attributes_false] ]\gb17BCursor Control\gbf5 updateCursor [self attributesAt: user mp[CrossCursor show] NormalCursor show]\gb13B\gSystemOrganization classify: TextEditor under: 'NewText'.\gTextEditor classInit\g