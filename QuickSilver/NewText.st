'From Smalltalk 5.5k XM November 24 on 4 October 1990 at 11:42:27 pm.'\g"CharLine"l15000z20000\gbf5 Class new title: 'CharLine'	subclassof: Object	fields: '	starti "index of first character"				stopi		"index of last character"				spaces 	"# of ascii spaces in line"				inset		"relative inset from normal line start"				width	"line width, assuming some space width"				measure	" max allowed line width" '	declare: '';	asFollows\gbf5 A CharLine specifies the parameters of a measured line of text.  The text, and its default spacing and alignment, etc. is contained in the TextBox (and the latters stylesheet)\giInit/Access\gbf5 inset [⇑inset]\gb6Binset: inset\gbspaces [⇑spaces]\gb7Bstarti [⇑starti]\gb7Bstarti: starti\gbstopi [⇑stopi]\gb6Bstopi: stopi spaces: spaces width: width\gbwidth [⇑width]\gb6BMeasure info\gbf5 measure [⇑measure]\gb8Bmeasure: measure\gbpad	[⇑measure-width/(spaces max: 1)]\gb5B1b30Bwhite	[⇑measure-width]\gb7B\gSystemOrganization classify: ↪CharLine under: 'NewText'.\g"Font"l15000z20000\gbf5 Class new title: 'Font'	subclassof: Object	fields: 'family pointsize minascii maxascii maxwidth length ascent descent xoffset raster glyphs xtable'	declare: '';	asFollows\gbf5 This class models the strike format for fonts.\giInitialization\gbf5 fromStrike: name | strike i split	"Build instance from strike file."	[name←name asUppercase.	split←name length-1. [(name◦split) isdigit⇒[split←split-1]].	family←name copy: 1 to: split.	pointsize←(name copy: split+1 to: name length) asInteger.	strike ← (dp0 oldFile: name + '.strike.').	strike nextword.	"skip header"	minascii ← strike nextword. maxascii ← strike nextword.	maxwidth ← strike nextword. length ← strike nextword.	ascent ← strike nextword. descent ← strike nextword.	xoffset ← strike nextword.	"If (horrors!) we should ever kern."	raster ← strike nextword. glyphs ← strike next: self byteraster * self height.	xtable ← (Vector new: maxascii + 3) all← 0.	for⦂ i from: (minascii + 1 to: maxascii + 3) do⦂ [xtable◦i ← strike nextword]]\gb17B17i34I241i13I195i36IAccess to Parts\gbf5 ascent [⇑ascent]\gb7Bbyteraster [⇑raster * 2]\gb11BcharForm: ascii ["should return a Form copied out of glyphs"]\gb16B1i43Idescent [⇑descent]\gb8Bfamily [⇑family]\gb7Bglyphs [⇑glyphs]\gb7Bheight [⇑ascent + descent]  "height of font"\gb7B19b2Bi1b6Bmaxascii [⇑maxascii]\gb9Bmaxwidth [⇑maxwidth]\gb9Bminascii [⇑minascii]\gb9Bpointsize [⇑pointsize]\gb10Braster [⇑raster]\gb7Bspacewidth | w	[w ← self widthof: 040.	w = 0 ⇒ [⇑4] ⇑w]\gb16Bwidthof: glyph [⇑(xtable◦(glyph + 2)) - (xtable◦(glyph + 1))]\gb15Bxtable [⇑xtable]\gb7B\gSystemOrganization classify: ↪Font under: 'NewText'.\g"FontSet"l15000z20000\gbf5 Class new title: 'FontSet'	subclassof: Object	fields: 'fonts'	declare: '';	asFollows\gbf5 Structure for holding a set of fonts.\giInit/Access\gbf5 font: n	[n>fonts length or⦂ n<1⇒[user notify: 'font index out of range'] ⇑fonts◦n]\gb9B65b8Bfontfamily: f 	[⇑(self font: f) family]\gb16B1b22Bfonts [⇑fonts]\gb6Bfontsize: f 	[⇑(self font: f) pointsize]\gb14B1b25BfromVector: v | n 	[v length>16⇒[user notify: 'font vector too long']	fonts←Vector new: v length.	for⦂ n to: v length do⦂ [fonts◦n←Font new fromStrike: v◦n]]"DefaultFontSet←FontSet new fromVector: ('timesroman12', 'helvetica10', 'helvetica12', 'oldenglish18')."\gb14B4b2B\gSystemOrganization classify: ↪FontSet under: 'NewText'.\g"ScreenPress"l15000z20000\gbf5 Class new title: 'ScreenPress'	subclassof: BitBlt	fields: '	x "position in micas"				y "position in micas"				spwidth "mica value for a space"				fontcode "ffff00ib: font number/bold/italic for current font"				font "the current strike Font"				widths "the current width table"				fonttab	"a vector (16) of fontcodes"				fontindex "so that fonttab◦fontindex=fontcode"				style "the current style (1 per press file)" '	declare: '';	asFollows\gbf5 I imitate a PressFile object, routing my output to the display. I currently understand text and rules (matching Spruce). The mica to point conversion factor, 2540/72 (~35.3), we approximate in tight loops by P=[M-(3M/32)]/32, because 29/1024=35.3 to 0.1%\giInit/Access\gbf5 fontindex: fontcode style: newstyle | n	[newstyle≠style and⦂ style≠nil⇒[user notify: 'invalid style']	style←newstyle. fontcode←fontcode land: 0363.	(n←fonttab find: fontcode)>0⇒[⇑n]	"add entry to font dictionary"	fonttab length=16⇒[user notify: 'too many fonts']	fonttab←fonttab, fontcode. ⇑fonttab length]\gb36B145b2B3i30I80b15Binit	[super init. fontcode←¬1. fonttab←Vector new: 0. color←¬1 "default black".	destbase←mem◦066. destraster←user screenrect width/32*2.	self setx: 0; sety: 0]\gb6B59i13Istrikepattern | s tint i	[s←Set new string: 16. for⦂ i from: 127 to: 200 do⦂ [s next←i].	user screenrect clear: white.	self fontindex: 0 style: DefaultFontSet; selectfont: 0; setspacex: 100;		setx: 2000; sety: 20000; setcolor: 5; showstr: s]"ScreenPress init strikepattern."\gb14Btestpattern | s tint	[s←'Folks, this is called Drop Shadowing'.	user screenrect clear: white.	self fontindex: 48 style: DefaultFontSet; selectfont: 0; setspacex: 100;		setx: 2000; sety: 20000; setcolor: 2; showstr: s;		setx: 2070; sety: 20070; setcolor: 5; showstr: s.	for⦂ tint to: 9 do⦂		[self setx: 1000+(tint*2000); sety: 25000; setcolor: tint; showrectwidth: 900 height: 900]]"ScreenPress init testpattern."\gb12Btestpattern2 | s tint	[s←'Folks, this is called Drop Shadowing'.	user screenrect clear: ltgray.	self fontindex: 48 style: DefaultFontSet; selectfont: 0; setspacex: 100;		setx: 2000; sety: 20000; setcolor: 6; showstr: s.	for⦂ tint to: 9 do⦂		[self setx: 1000+(tint*2000); sety: 25000; setcolor: tint; showrectwidth: 900 height: 900]]"ScreenPress init testpattern2."\gb13Bx [⇑x]\gb2By [⇑y]\gb2BSetting State\gbf5 selectfont: newfont | n	[newfont←newfont+1. newfont=fontindex⇒[]	fontindex←newfont. fontcode←fonttab◦fontindex.	n←(fontcode lshift: ¬4)+1. font←style font: n.	widths←(WidthTable new named: (style fontfamily: n)		pointsize: (style fontsize: n) face: (fontcode/2 land: 1)+(fontcode*2 land: 2)) lookup.	sourceraster←font raster]\gb20B3b2Bsetcolor: c	[color←↪(¬1 0 ¬32126 23130 21845 25500 27795 4740)◦c]			"black white ltgray gray red green blue yellow"\gb13Bsetspacex: spwidth\gbsetx: x\gbsety: y\gbshowrectwidth: w height: h | ty	[ty←27940-y-h. function←034 "store gray block to bank 1".	desty←ty inPts. destx←x inPts. width←w inPts max: 1. height←h inPts max: 1.	self callBLT]\gb27B35i26Ishowstr: str	[self showstr: str first: 1 last: str length]\gb14Bshowstr: str first: fi last: li | xtab ch wid t bold yslices yslice xskew savxskew xsave tone chi	[xtab←font xtable. xsave←x. sourcebase←font glyphs lock. bold←(fontcode land: 1)≠0.	t←font height. [fontcode\4<2⇒[savxskew←0. yslices←t inVector]		savxskew←font ascent/4. yslices←Vector new: t+3/4. yslices all←4; last←t-1\4+1]. 	for⦂ tone to: 2 do⦂	"erase/paint loop"		[tone-color=2⇒[] function←↪(023 "erase dest" 031 "or in under mask")◦tone.		desty←(27940-y) inPts-font ascent. sourcey←0. xskew←savxskew.		for⦂ yslice from: yslices do⦂	"italic (sliceup) loop"			[height←yslice. x←xsave.			for⦂ chi from: fi to: li do⦂		"character loop"				[ch←str◦chi. [ch=040⇒[wid←spwidth] wid←widths widthof: ch.					t←x lshift: ¬5. destx←((x-(t+t+t)) lshift: ¬5)+xskew.					sourcex←(t←xtab◦(ch+1)). width←xtab◦(ch+2)-t. self callBLT. "char print"					bold⇒[destx←destx+1. self callBLT]]. "embolden"				x←x+wid].			desty←desty+yslice. sourcey←sourcey+yslice. xskew←xskew-1]]. 	font glyphs unlock]\gb32B320i16I37i10I7i16I106i21I64i14I190i10I45i8I\gSystemOrganization classify: ↪ScreenPress under: 'NewText'.\g"ScreenPressFile"l15000z20000\gbf5 Class new title: 'ScreenPressFile'	subclassof: PressFile	fields: 'x y'	declare: '';	asFollows\gbf5 I augment class PressFile for text related functions, and also keep track of the last setx and sety, thus resembling ScreenPress\giAccess\gbf5 pressfile: name [⇑super of: (dp0 file: name)]\gb16Bsetcolor: c	[super hue: ↪(0 0 0 0 0 80 140 40)◦c;	saturation: ↪(0 0 0 0 255 255 255 255)◦c;	brightness: ↪(0 255 100 150 255 255 255 255)◦c]\gb13Bsetx: x	[super setx: x]\gb9Bsety: y	[super sety: y]\gb9Bshowstr: str 	[self showstr: str first: 1 last: str length]\gb15Bshowstr: str first: fi last: li | w ch chi spwidth	[super append: (str◦(fi to: li)); showchars: li-fi+1. spwidth←estate◦2.	w←fontdefs◦(estate◦1+1). for⦂ chi from: fi to: li do⦂		[ch←str◦chi. x←x+[ch=040⇒[spwidth]w widthof: ch]]]\gb32B18b2Btestpattern | s tint i	[s←'Folks, this is called Drop Shadowing'.	user screenrect clear: white.	self fontindex: 51 style: DefaultFontSet; selectfont: 0; setspacex: 100.	for⦂ i to: 10 do⦂		[self setx: 2000; sety: 2000*i; setcolor: 4; showstr: s;		setx: 2000+i; sety: 2010*i; setcolor: 5; showstr: s]] "|P. P←ScreenPressFile new pressfile: 'shadow.press'. P testpattern; close."\gb12Bx [⇑x]\gb2By [⇑y]\gb2B\gSystemOrganization classify: ↪ScreenPressFile under: 'NewText'.\g"Text"l15000z20000\gbf5 Class new title: 'Text'	subclassof: Object	fields: '	para				"the text"				color				"0..7 denoting a color"				lines				"vector of CharLines"				lastline			"index 1≤lastline≤lines length of last visible line"				fontset			"the ≤16 fonts used"				linespercol		"# of lines per column"				columns		"# of columns --all subsequent values are in Micas"				origin			"the upper-lefthand corner of the text"				tabs				"vector of monotonically increasing offsets"				lineheight		"baseline to baseline; bodyheight+leading"				bodyheight		"char height of body text"				ascent			"dist above baseline for body text"				descent			"dist beneath baseline (pos)"				minsp			"default interword space"				maxsp			"max interword space"				linemeasure	"default line measure"				columnspace	"inter column spacing " '	declare: 'attributes curface chartype curwidths ';	asFollows\gbf5 I window text taken from para onto a screen or page, defined in region frame, using fonts and line measures from style. lines maintains line break and line measure info.\giInit/Access\gbf5 attributes [⇑attributes viewee: self]\gb11B1b24BattributesInit "Text classInit. Text new attributesInit."	|	unitviewer integerviewer colorviewer		columnsmenu linesmenu spacingmenu	[	unitviewer←UnitViewer default units:			(('micas',1) inVector, ('pts',35.3), ('picas',423.3), ('cm',899.75), ('in',2540.0)).		integerviewer←[AttributeViewer new			toString:		↪asString;			fromString⦂	[attributeValue←attributeText asStream integerScan asInteger] ].		colorviewer←[AttributeViewer new			menu: [ActionMenu new				stringFromVector:					('black','white','light gray','gray','red','green','blue','yellow'); init;				action←(0,1,2,3,4,5,6,7)] ].		linesmenu←AttributeMenu new.			linesmenu title: 'total number';				extract: ↪totlines; assign: nil; viewer: integerviewer copy.			linesmenu title: 'per column';				extract: ↪linespercol; assign: nil; viewer: integerviewer copy.			linesmenu title: 'default measure';				extract: ↪linemeasure; assign: nil; viewer: unitviewer copy.		columnsmenu←AttributeMenu new.			columnsmenu title: 'number';				extract: ↪columns; assign: nil; viewer: integerviewer copy.			columnsmenu title: 'spacing';				extract: ↪columnspace; assign: nil; viewer: unitviewer copy.		spacingmenu←AttributeMenu new.			spacingmenu title: 'body height';				extract: ↪bodyheight; assign: nil; viewer: unitviewer copy.			spacingmenu title: 'leading';				extract: ↪linelead; assign: 'linelead:'; viewer: unitviewer copy.			spacingmenu title: 'min interword';				extract: ↪minsp; assign: nil; viewer: unitviewer copy.			spacingmenu title: 'max interword';				extract: ↪maxsp; assign: nil; viewer: unitviewer copy.		attributes←AttributeMenu new.			attributes title: 'Color';				extract: ↪color; assign: 'color:'; viewer: colorviewer.			attributes title: 'Columns⇒';				extract: ↪itself; assign: nil; viewer: columnsmenu.			attributes title: 'Lines⇒';				extract: ↪itself; assign: nil; viewer: linesmenu.			attributes title: 'Spacing⇒';				extract: ↪itself; assign: nil; viewer: spacingmenu  ]\gb15Bbodyheight [⇑bodyheight]\gb11B1b11BcharInit "Text classInit. Text new charInit."	[	chartype←String new: 256.		chartype all←4.		"Normal Char"		chartype◦011←0.	"Tab"		chartype◦015←1.	"<CR>"		chartype◦040←2.	"Space"		chartype◦020←3.	"Misc. Spacing"		chartype◦055←5.	"Hyphen"		curface←false  ]\gb9B85i13I20i4I44i7I19i15I19i8IclassInit "Text classInit."	[	self attributesInit; charInit  ]\gb10Bcolor [⇑color]\gb6B1b6Bcolor: color\gbcolumns [⇑columns]\gb8B1b8Bcolumnspace [⇑columnspace]\gb12B1b12Bframe	[⇑(origin x)⌾(origin y-descent-2) extent:		(linemeasure+columnspace*columns-columnspace)⌾(linespercol*lineheight)]\gb7B1b113Bframe: frame para: para fontset: fontset columns: columns | i	[origin←frame origin copy.	bodyheight←(fontset font: 1) height inMicas. lineheight←bodyheight+71.	tabs←lineheight inVector. minsp←bodyheight/5. maxsp←bodyheight.	ascent←465. descent←92. columnspace←400.	linemeasure←frame width-(columns-1*columnspace)/columns.	linespercol←frame height/lineheight.	lines←Vector new: self totlines. color←0. "black"	for⦂ i to: self totlines do⦂		[lines◦i←CharLine new. lines◦i measure: linemeasure; inset: 0] ]\gb58B351i5Ilastline [⇑lastline]\gb9B1b9Blastshown [⇑(lines◦lastline) stopi]\gb10B1b23Blinelead [⇑lineheight-bodyheight]\gb9B1b22Blinelead: linelead [lineheight←bodyheight+linelead]\gb19Blinemeasure [⇑linemeasure]\gb12B1b12Blines [⇑lines]\gb6B1b6Blinespercol [⇑linespercol]\gb12B1b12Bmaxsp [⇑maxsp]\gb6B1b6Bminsp [⇑minsp]\gb6B1b6Borigin [⇑origin]\gb7B1b7Borigin: origin\gbpara [⇑para]\gb5B1b5Bptframe: f para: p	[self frame: f inMicas para: p fontset: DefaultFontSet columns: 1]\gb20B66bptframe: f para: p columns: columns	[self frame: f inMicas para: p fontset: DefaultFontSet columns: columns]\gb37Btest"|P T f i.P←('This is an easy little test, which tries to fit as much text as it can into a large oval. As you can see, it is quite nice.  Sorry that the text is rather trite, but this is needed to test out the code. Of course, any shape will do, but those with simple math defs. are best, on the whole.') asParagraph. P allFont: 0. P alignment←1. T←Text new ptframe: Rectangle new usersize para: P columns: 2.user screenrect clear: white. T outline. T showall. while⦂ user anybug do⦂	[(T rectofline: (T lineofpt: user mp inMicas)) inPts comp]"\gb5Btotlines [⇑linespercol*columns]\gb9B1b20BCopy Fitting\gbf5 copyfitall [self copyfitall: 1]\gb11Bcopyfitall: firsti [(lines◦1) starti: firsti. self copyfitfrom: 1 to: lines length]\gb19Bcopyfitfrom: startline to: stopline | maxlength chari i curline	[maxlength←para length. chari←(lines◦startline) starti.	for⦂ i from: startline to: stopline do⦂		[chari←chari+[chartype◦(para text◦chari)>3⇒[0] 1].		(curline←lines◦i) starti: chari. self fitline: curline.		(chari←curline stopi+1)>maxlength⇒[lastline←i. ⇑nil] ].	lastline←lines length]\gb36B286b4Bfitline: line| em width bwidth spaces bspaces chari bchari rs ri rlen body oldbody lasti ch	[em←bodyheight. width←bwidth←spaces←bspaces←0.	chari←bchari←line starti. lasti←para length. body←4.	rs←para runfind: line starti. ri←rs◦1. rlen←(para runs◦ri)-(rs◦2)+1.	self widthtable: para runs◦(ri+1).	until⦂ ((width≥line measure or⦂ chari>lasti) or⦂ (body=1)) do⦂		[[body=5⇒[bwidth←width. bspaces←spaces. bchari←chari]]. "was hyphen"		[rlen=0⇒[ri←ri+2. rlen←para runs◦ri. self widthtable: (para runs◦(ri+1))]]. "new run"		ch←para text◦chari. oldbody←body. body←chartype◦ch.		[body<4⇒[[oldbody>3⇒[bwidth←width. bspaces←spaces. bchari←chari]]. "sp tab cr white"			body=2⇒[width←width+minsp. spaces←spaces+1]; =0⇒[width←width+em|em]]].		[body>2⇒[width←width+(curwidths widthof: ch)]]. "white text hyphen"		chari←chari+1. rlen←rlen-1].	chari>lasti or⦂ spaces=0⇒[line stopi: chari-1 spaces: spaces width: width]		line stopi: bchari-1 spaces: bspaces width: bwidth]\gb14B410i10I81i7I126i15I127i17Ishrinktofit | i	[linemeasure←0.	for⦂ i to: lastline do⦂ [linemeasure←linemeasure max: (lines◦i) width].	for⦂ i to: lastline do⦂ [(lines◦i) measure: linemeasure].	self copyfitall]	\gb12Bwidthtable: face | i	[face≠curface⇒		[curface←face. i←(face lshift: ¬4)+1.		curwidths←(WidthTable new named: (fontset fontfamily: i)		pointsize: (fontset fontsize: i)		face: (face/2 land: 1)+(face*2 land: 2)) lookup. ⇑curwidths]]\gb17B205b10BLayout Info\gbf5 xend: linei 	[⇑(self xstart: linei)+((lines◦linei) measure)]\gb14B1b45Bxstart: linei	[⇑origin x+(lines◦linei) inset+(linei-1/linespercol*(linemeasure+columnspace))]\gb15B1b77Bystart: linei 	[⇑origin y+(linespercol-(linei-1\linespercol+1)*lineheight)]\gb16B1b58BDisplaying\gbf5 displaylines: firsti to: lasti press: p | linei line curi newcuri runs runi run x1 y1 x2	[p setcolor: color+1.	for⦂ linei from: firsti to: lasti do⦂		[line←lines◦linei. curi←line starti. curi≡nil⇒[⇑nil]		p	sety: (self ystart: linei);			setx: (self xstart: linei)+[para alignment=2⇒[line white/2]; =3⇒[line white]0];			setspacex: ((minsp+[para alignment=1⇒[line pad]0]) min: maxsp).		runs←(para run: line starti to: line stopi).		for⦂ runi from: (1 to: runs length by: 2) do⦂			[p	selectfont: ((p fontindex: (run←runs◦(runi+1)) style: fontset)-1). x1←p x.			p showstr: para text first: curi last: (newcuri←runs◦runi+curi-1). curi←newcuri+1.			[(run land: 12)≠0⇒[x2←p x. y1←self ystart: linei. p setx: x1]].			[(run land: 4)≠0⇒[p sety: ascent/4+y1; showrectwidth: x2-x1 height: 20]].			[(run land: 8)≠0⇒[p sety: y1-descent; showrectwidth: x2-x1 height: 20]].			[(run land: 12)≠0⇒[p setx: x2; sety: y1]]]]]\gb40Boutline	[self frame inPts boxcomp]\gb9Bpresson: press	[self displaylines: 1 to: lines length press: press]\gb16Bshowall [self presson: (ScreenPress init)]\gb8Bunshowall [self frame inPts clear: white]\gb10Bunshowlines: startline to: stopline | i	[for⦂ i from: startline to: stopline do⦂ [(self rectofline: i) inPts clear: white] ]\gb36BLine Selection\gbf5 lastusedline	[⇑self lineofchar: para text length]\gb14Blineofchar: chari | i	[chari=0⇒[⇑1]. for⦂ i to: lastline do⦂		[(lines◦i) starti≡nil or⦂ ((lines◦i) starti-1>chari)⇒[⇑i-1]].	⇑self lastline]"lineofchar: chari | lo mid hi	[chari=1⇒[⇑1] hi←self totlines+1.  lo←1.	while⦂ lo<hi do⦂		[(lines◦(mid←lo+hi/2)) starti<chari⇒[hi←mid] lo←mid+1].	⇑hi-1]	0≤result≤length"\gb18B15b2B83b4B5b14B1b20B23b2B106b5B2i15Ilineofpt: pt | x y row col	[x←pt x-origin x. y←pt y-origin y.	col←(x/(linemeasure+columnspace) min: columns-1) max: 0. 	row←(linespercol-1-(y/lineheight) min: linespercol-1) max: 0.	⇑(col*linespercol+row+1) min: lastline]\gb13B173b38Brectofline: linei	[⇑Rectangle new origin: ((self xstart: linei)⌾((self ystart: linei)-descent))		extent: (lines◦linei) measure⌾(ascent+descent)]\gb19B1b125Bwidthsofline: linei | line em firsti lasti m chi pad width rs rlen ch	[line←lines◦linei. em←bodyheight. firsti←line starti. lasti←line stopi.		m←Vector new: (lasti-firsti+2). width←self xstart: linei.	pad←(minsp+[para alignment=1⇒[line pad]0]) min: maxsp.	width←width+[para alignment=2⇒[line white/2]; =3⇒[line white]0].	m◦1←width. rs←(para run: firsti to: lasti) asStream. rlen←0.	for⦂ chi from: firsti to: lasti do⦂ "chari>lasti needed?"		[[rlen=0⇒[rlen←rs next. self widthtable: rs next]]. "new run"		ch←para text◦chi.		[(chartype◦ch)			=2⇒[width←width+pad]; "space"			=1⇒[];	"cr"			=0⇒[width←width+em|em].	"tab"			width←width+(curwidths widthof: ch)]. "else: white, text or hyphen"		m◦(chi-firsti+2)←width. rlen←rlen-1]. ⇑m]\gb20B49b2B354i19I57i7I65i5I13i2I30i3I44i27I42b2B\gSystemOrganization classify: ↪Text under: 'NewText'.\gText classInit\g"TextEditor"l15000z20000\gbf5 Class new title: 'TextEditor'	subclassof: Object	fields: 'text currect curline curmeasure c1line c1index c1offset c2line c2index c2offset line index offset attributes'	declare: 'alignmenu fontmenu cutbuffer CrossCursor cursor editmenu lookmenu ';	asFollows\gbf5 I edit the para in a textbox. I also change other TextBox fields\giInit/Access\gbf5 classInit "TextEditor classInit."	[	self cursorInit; menuInit; editInit  ]\gb10BcursorInit "TextEditor classInit. TextEditor new cursorInit."	[	CrossCursor←Cursor new fromtext: '0000000000000000000000001000000000000000100000000000000010000000000000001000000000000000100000000000000010000000000000001000000001111111111111110000000010000000000000001000000000000000100000000000000010000000000000001000000000000000100000000000000010000000' offset: 8⌾8  ]\gb11Bedit: text | frame pt	[c1index←c2index←(text lines◦1) starti-1. self pointofindicies; selectall.	frame←text frame inPts. attributes←false.	while⦂ true do⦂		[while⦂ user nobug do⦂ [self updateCursor. user kbck⇒[self kbd] ].		user redbug⇒			[self attributesAt: (pt←user mp)⇒				[self attributesEdit]				frame has: pt⇒					[self redbug]					self selectall; unshowAttributes. ⇑nil]		user yellowbug⇒[self yellowbug] ] ]\gb11B371b4BeditInit "TextEditor classInit. TextEditor new editInit."	|	i arrow	[	cutbuffer←''.	 	arrow←String new: 12.		for⦂ i to: 6 do⦂ [arrow word: i←(↪(4 14 31 4 4 4)◦i) lshift: 11].		cursor←Form new. cursor extent: (16⌾6); bits: arrow  ]\gb9BmenuInit "TextEditor classInit. TextEditor new menuInit."	|	v i	[	v←Vector new: 0.		for⦂ i from: DefaultFontSet fonts do⦂			[v←v,((i family copy: 1 to: (i family length min: 4))+i pointsize asString)].		editmenu←MenuSet new default init.			editmenu add: [(ActionMenu new) string:'copypastecutfont⇒look⇒align⇒attributes'; init].			editmenu add: [(ActionMenu new) stringFromVector: v; init].			editmenu add: [(ActionMenu new) string:'clearbolditalicunderscorestrikeout'; init].			editmenu add: [(ActionMenu new) string:'left flushjustifycenterright flush'; init].			editmenu firstmenu←1.			editmenu menu: 1 line: 4 tomenu: 2.			editmenu menu: 1 line: 5 tomenu: 3.			editmenu menu: 1 line: 6 tomenu: 4  ]\gb9Btest | P T "TextEditor new test."	[P←('This is an easy little test, which tries to fit as much text as it can into a large oval. As you can see, it is quite nice. Sorry that the text is rather trite, but this is needed to test out the code. Of course, any shape will do, but those with simple math defs. are best, on the whole. Note too, that the border may in fact be a curved line, as is the case here, and not simply a set of straight edges. Sorry that the text is rather silly, but this is needed to test out the code. Of course, any shape will do, but those with simple math defs. are best, on the whole. Note too, that the border may in fact be a curved line, as is the case here, and not simply a set of straight edges. Well now, I hope you liked our little demo.') asParagraph.	P allFont: 0. P alignment←1. user screenrect clear: white.	T←Text new ptframe: Rectangle new usersize para: P columns: 2."	T←Text new ptframe: (271⌾33 rect: 471⌾200) para: P columns: 2.  "	T copyfitall; showall; outline. self edit: T]\gb5BSelection/Keyboard\gbf5 charpoint | pt charline i newline oldindex	[oldindex←index. [pt←user mp inMicas. [(currect has: pt)⇒[]		curline←text lineofpt: pt. currect←text rectofline: curline.		curmeasure←text widthsofline: curline].	charline←(text lines)◦curline. line←curline.	pt x≤(curmeasure◦1)⇒[index←charline starti-1. offset←curmeasure◦1];		≥(curmeasure last)⇒[index←charline stopi. offset←curmeasure last].	i←curmeasure findSorted: pt x.	[(curmeasure◦(i+1)-pt x)>(pt x-(curmeasure◦i))⇒[i←i-1]].	index←charline starti+i-1. offset←curmeasure◦(i+1)]. ⇑oldindex≠index]\gb10B527b15Bdoubleclick | min thismax nextmax lbody rbody	[min←(text lines◦c1line) starti-1. thismax←(text lines◦c1line) stopi.	[c1line=text lines length⇒[nextmax←text para length]		nextmax←(text lines◦(c1line+1)) starti-1].	[c1index=min⇒[c2index←nextmax]	"line select or rangle select"		until⦂ (c1index=min or⦂ text para◦c1index=040) do⦂ [c1index←c1index-1].		until⦂ (c2index=thismax or⦂ text para◦(c2index+1)=040) do⦂ [c2index←c2index+1]].	self pointofindicies]\gb12B33b2B202i28Ikbd | s	[s←Set new string: 16. while⦂ user kbck do⦂ [s next←user kbdnext].	self replacewith: s select: false]\gb4B3b2Bpointofindicies | i	[c1line←text lineofchar: c1index. curmeasure←text widthsofline: c1line.	i←c1index-(text lines◦c1line) starti+2.	[i>curmeasure length⇒[c1offset←curmeasure last] c1offset←curmeasure◦i].	c2line←curline←text lineofchar: c2index. curmeasure←text widthsofline: c2line.	i←c2index-(text lines◦c2line) starti+2.	[i>curmeasure length⇒[c2offset←curmeasure last] c2offset←curmeasure◦i].	currect←text rectofline: c2line]\gb16B3b2Bredbug	[self selectall. "deselect".	c1index=c2index and: self charpoint=false⇒[self doubleclick; selectall] "side-effect"	c2line←c1line←line. c2index←c1index←index. c2offset←c1offset←offset.	self select. while⦂ user redbug do⦂		[self charpoint⇒[self select. c1index←index. c1offset←offset. c1line←line].		c2index=index⇒[self showcursor; showcursor]]	c2index=index⇒[self showcursor]]\gb8B18i8I77i11Iselect | l1 l2 c1 c2 o1 o2 r i	[[index<c1index⇒		[l2←line. l1←c1line. c2←index. c1←c1index. o2←offset. o1←c1offset]		l1←line. l2←c1line. c1←index. c2←c1index. o1←offset. o2←c1offset].	r←[l2=curline⇒[currect copy] text rectofline: l2]. r origin x←o2.	l1=l2⇒[r corner x←o1. r pointize comp]	r pointize comp. for⦂ i from: l2+1 to: l1-1 do⦂ [(text rectofline: i) pointize comp].	r←text rectofline: l1. r corner x←o1. r pointize comp]	\gb7B23b2Bselectall	[c2index=c1index⇒[self showcursor] line←c2line. index←c2index. offset←c2offset.	self select. c2line←line. c2index←index. c2offset←offset]\gb11Bselection [⇑text para copy: (c1index min: c2index)+1 to: (c1index max: c2index)]\gb10B1b68Bshowcursor	[cursor displayat: (((text widthsofline: c2line)◦(c2index-(text lines◦c2line) starti+2))-71⌾		(text ystart: c2line)) inPts effect: xoring clippedBy: nil]\gb12BMenu/Actions\gbf5 align: i	[text unshowall. text para alignment←i-1. text showall. self selectall]\gb10Bfont: i	[self replacewith: (self selection maskrunsunder: 0360 to: (i-1*16))	select: true]\gb9Blook: i	[self replacewith: (self selection maskrunsunder: ↪(15 1 2 8 4)◦i to: ↪(0 1 2 8 4)◦i)		select: true]\gb9Breplacewith: scrap select: sflag | c1 c2 l1 l2 last i	[c1←(c1index min: c2index)+1. c2←c1index max: c2index.	l1← c1line min: c2line. l2←c1line max: c2line.	self selectall.	text para replace: c1 to: c2 by: scrap.	text copyfitfrom: l1 to: text totlines.	"optimize later"	last←text lastline.	text unshowlines: l1 to: text totlines.	text displaylines: l1 to: last press: (ScreenPress init).	c1index←c1-1+scrap length. [sflag⇒[c2index←c1-1] c2index←c1index].	self pointofindicies; selectall]\gb33B20b2B203i14Iyellowbug | v menu item	[(v←editmenu bug)≡false⇒[ ]	menu←editmenu find: v◦1. item←v◦2.	menu		=1⇒	"main"				[item				=1⇒	"copy"			[cutbuffer←self selection];				=2⇒	"paste"			[self replacewith: cutbuffer select: true];				=3⇒	"cut"				[cutbuffer←self selection. self replacewith: '' select: true];				=7⇒	"attributes"	[self flipAttributes] ];		=2⇒	"font⇒"					[self font: item];		=3⇒	"look⇒"					[self look: item];		=4⇒	"align⇒"				[self align: item] ]\gb10B13b2B76i6I18i6I39i7I55i5I75i12I32i7I30i7I30i8IAttributes\gbf5 attributes [⇑text attributes]\gb11B1b16BattributesAt: pt [attributes⇒[⇑attributes has: pt] ⇑false]\gb17B13b19B2b6BattributesEdit | f	[NormalCursor show. self selectall. f←text frame inPts.	[attributes Bug⇒		[attributes unshow.		f clear: white. text copyfitall: ((text lines◦1) starti); showall.		attributes reshow] ].	self selectall]\gb15B3b2BflipAttributes [attributes⇒[self unshowAttributes] self showAttributes]\gb15BshowAttributes | pt	[CrossCursor show. user waitbug. pt←user mp. NormalCursor show.	attributes←text attributes. attributes showat: (pt-(attributes frame extent/2))]\gb15BunshowAttributes [attributes⇒[attributes unshow. attributes←false] ]\gb17BCursor Control\gbf5 updateCursor [self attributesAt: user mp⇒[CrossCursor show] NormalCursor show]\gb13B\gSystemOrganization classify: ↪TextEditor under: 'NewText'.\gTextEditor classInit\g