<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>bootstrap.st</title>
	<link rel="stylesheet" type="text/css" href="../font.css"/>
  </head>
  <body>
    <div class="line center">
<span class="small">↪</span><span class="medium bold"><br><br>The<br>New<br>Improved<br>SMALLTALK<br>System<br>Definition<br></span><span class="small">June 12, 1977</span></div>
<div class="line left">
<span class="small bold"><br><br>This is the new SYSDEFS</span></div>
<div style="width: 405pt; margin-left: 121pt; margin-top: 0pt; text-align: justify">
<span class="small italic">This is &lt;INGALLS&gt;bootstrap.st.  The read routine, compiler and file system(draft) appear in a separate file called bootstrap2.st.  The user interface(draft) is in userface.st.  The objects which are initially needed get created in the file launch.ft.  A complete simulator exists in simulate.ft, and old-system defs of the new classes are in genclass.ft</span><span class="small">↪</span></div>
<div class="line left">
</div>
<div class="line center">
<span class="small"><br></span><span class="small">↪</span><span class="medium bold">RAW MATERIALS</span><span class="small">↪</span></div>
<div class="line left">
<span class="small"><br></span><span class="medium bold">Class new title: &rsquo;Object&rsquo;;<br></span><span class="tab"></span><span class="medium bold">subclassof: nil;<br></span><span class="tab"></span><span class="medium bold">abstract<br></span><span class="small">↪</span><span class="small italic">Object is the superclass of all classes.  It is an abstract class, meaning that it has no instance state, and its main function is to provide a foundation message protocol for its subclasses.  Three instances of this class are defined, namely: nil, true, and false.</span><span class="small">↪</span><span class="small"><br><br></span><span class="small">↪</span><span class="small italic">primitives</span><span class="small">↪</span><span class="small"><br></span><span class="small">Object understands: &rsquo;</span><span class="small underline">≡</span><span class="small"> x [] primitive: 4&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">test for identical pointers</span><span class="small">↪<br></span><span class="tab"></span><span class="small">↪</span><span class="small italic">Font will be edited so this looks like </span><span class="small">W</span><span class="small italic">, meaning eq</span><span class="small">↪</span><span class="small"><br></span><span class="small">Object understands: &rsquo;</span><span class="small underline">hash</span><span class="small"> [] primitive: 46&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">pointer as an Integer</span><span class="small">↪<br>Object understands: &rsquo;</span><span class="small underline">asOop</span><span class="small"> [] primitive: 46&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">Dont override this</span><span class="small">↪<br>Object understands: &rsquo;</span><span class="small underline">refct</span><span class="small"> [] primitive: 45&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">current reference count</span><span class="small">↪<br>Object understands: &rsquo;</span><span class="small underline">class</span><span class="small"> [] primitive: 27&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">class of this object</span><span class="small">↪<br>Object understands: &rsquo;</span><span class="small underline">instfield:</span><span class="small"> n [] primitive: 38&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">subscript any objct</span><span class="small">↪<br>Object understands: &rsquo;</span><span class="small underline">instfield:</span><span class="small"> n </span><span class="small underline">&larr;</span><span class="small"> val [] primitive: 39&rsquo;<br><br>↪</span><span class="small italic">boolean connectives</span><span class="small">↪<br>Object understands: &rsquo;</span><span class="small underline">or:</span><span class="small"> x [self?[!true] !x]&rsquo;<br>Object understands: &rsquo;</span><span class="small underline">and:</span><span class="small"> x [self?[!x] !false]&rsquo;<br>Object understands: &rsquo;</span><span class="small underline">xor:</span><span class="small"> x [x?[!self≡false] !self]&rsquo;<br>Object understands: &rsquo;</span><span class="small underline">eqv:</span><span class="small"> x [x?[!self] !self≡false]&rsquo;<br><br>↪</span><span class="small italic">following don&rsquo;t evaluate their arg unless necessary.<br>They are built for comfort, not for speed.</span><span class="small">↪<br>Object understands: &rsquo;</span><span class="small underline">or⦂</span><span class="small"> x [self?[!true] !x eval]&rsquo;<br>Object understands: &rsquo;</span><span class="small underline">and⦂</span><span class="small"> x [self?[!x eval] !false]&rsquo;<br><br>↪</span><span class="small italic">default protocol</span><span class="small">↪<br>Object understands: &rsquo;</span><span class="small underline">printon:</span><span class="small"> strm<br></span><span class="tab"></span><span class="small">[self≡nil? [strm append: &rsquo;&rsquo;nil&rsquo;&rsquo;]<br></span><span class="tab"></span><span class="small">self≡false? [strm append: &rsquo;&rsquo;false&rsquo;&rsquo;]<br></span><span class="tab"></span><span class="small">self≡true? [strm append: &rsquo;&rsquo;true&rsquo;&rsquo;]<br></span><span class="tab"></span><span class="small">self class print: self on: strm]&rsquo;<br>Object understands: &rsquo;</span><span class="small underline">asString</span><span class="small"> | strm<br></span><span class="tab"></span><span class="small">[strm &larr; Stream default.<br></span><span class="tab"></span><span class="small">self printon: strm. !strm contents]&rsquo;<br>Object understands: &rsquo;</span><span class="small underline">print</span><span class="small"><br></span><span class="tab"></span><span class="small">[user show: self asString]&rsquo;<br>Object understands: &rsquo;</span><span class="small underline">=</span><span class="small"> x [!self≡x]&rsquo;<br>Object understands: &rsquo;</span><span class="small underline">≠</span><span class="small"> x [!self=x≡false]&rsquo;<br>Object understands: &rsquo;</span><span class="small underline">is:</span><span class="small"> x [!self class≡x]&rsquo;<br>Object understands: &rsquo;</span><span class="small underline">,</span><span class="small"> x | v<br></span><span class="tab"></span><span class="small">[v &larr; Vector new: 2.<br></span><span class="tab"></span><span class="small">v◦1 &larr; self. v◦2 &larr; x.  !v]&rsquo;<br>Object understands: &rsquo;startup</span><span class="tab"></span><span class="tab"></span><span class="small">↪loopless scheduling↪<br></span><span class="tab"></span><span class="small">[self firsttime?<br></span><span class="tab"></span><span class="tab"></span><span class="small">[while⦂ self eachtime do⦂ [].<br></span><span class="tab"></span><span class="tab"></span><span class="small">!self lasttime]<br></span><span class="tab"></span><span class="small">!false]&rsquo;<br>Object understands: &rsquo;</span><span class="small underline">canunderstand:</span><span class="small"> selector<br></span><span class="tab"></span><span class="small">[!self class canunderstand: selector]&rsquo;<br>Object understands: &rsquo;</span><span class="small underline">copy</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">create new copy of self</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[!self class copy: self]&rsquo;<br>Object understands: &rsquo;</span><span class="small underline">recopy</span><span class="tab"></span><span class="small">↪</span><span class="small italic">recursively copy whole structure</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[!self class recopy: self]&rsquo;<br>Object understands: &rsquo;</span><span class="small underline">error</span><span class="small"><br></span><span class="tab"></span><span class="small">[user notify: &rsquo;&rsquo;Message not understood.&rsquo;&rsquo;]&rsquo;<br>Object understands: &rsquo;ⓢ code<br></span><span class="tab"></span><span class="small">[self class understands: &rsquo;&rsquo;doit [![&rsquo;&rsquo; + code + &rsquo;&rsquo;]]&rsquo;&rsquo;.<br></span><span class="tab"></span><span class="small">!self doit]&rsquo;<br></span></div>
<div class="line center">
</div>
<div class="line center">
<span class="small"><br></span><span class="small">↪</span><span class="medium bold">FUNDAMENTAL ORGANIZATION</span><span class="small">↪</span></div>
<div class="line left">
<span class="small"><br></span><span class="medium bold">Class new title: &rsquo;Class&rsquo;;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;title</span><span class="tab"></span><span class="small">↪</span><span class="small italic">&lt;String&gt; for identification, printing</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="medium bold">myinstvars </span><span class="small">↪</span><span class="small italic">&lt;String&gt; partnames for compiling, printing (includes comments)</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="medium bold">instsize </span><span class="small">↪</span><span class="small italic">&lt;Integer&gt; for storage management</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="medium bold">messagedict </span><span class="small">↪</span><span class="small italic">&lt;MessageDict&gt; for communication, compiling</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="medium bold">monitors </span><span class="small">↪</span><span class="small italic">&lt;Dictionary/nil&gt; compiler checks here</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="medium bold">superclass </span><span class="small">↪</span><span class="small italic">&lt;Class&gt; for execution of inherited behavior</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="medium bold">environment </span><span class="small">↪</span><span class="small italic">&lt;Vector of SymbolTables&gt; for external references</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="medium bold">fieldtype&rsquo;; </span><span class="small">↪</span><span class="small italic">&lt;Integer&gt; encodes field size, if bits</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="medium bold">veryspecial: 1<br></span><span class="small"><br></span><span class="small">↪</span><span class="small italic">order of messages, just to make things simpler:<br></span><span class="tab"></span><span class="small underline">title</span><span class="small"> insystem subclassof </span><span class="small underline">fields/abstract</span><span class="small"> (</span><span class="small underline">required</span><span class="small">)<br></span><span class="tab"></span><span class="small">sharing bytesize veryspecial (any order)</span><span class="small">↪</span><span class="small"><br></span><span class="small">Class understands: &rsquo;</span><span class="small underline">title:</span><span class="small"> title<br></span><span class="tab"></span><span class="small">[self title: title insystem: Smalltalk]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">title:</span><span class="small"> title </span><span class="small underline">insystem:</span><span class="small"> system<br></span><span class="tab"></span><span class="small">[system define: title unique as: self.<br></span><span class="tab"></span><span class="small">superclass &larr; Object]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">subclassof:</span><span class="small"> superclass&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">abstract</span><span class="small"><br></span><span class="tab"></span><span class="small">[self fields: nullString]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">fields:</span><span class="small"> myinstvars</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">list of instance variables</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[fieldtype &larr; 16.<br></span><span class="tab"></span><span class="small">instsize &larr; self instvars length.<br></span><span class="tab"></span><span class="small">instsize&gt;16?<br></span><span class="tab"></span><span class="tab"></span><span class="small">[user notify: &rsquo;&rsquo;too many instance variables&rsquo;&rsquo;]<br></span><span class="tab"></span><span class="small">messagedict &larr; MessageDict default.<br></span><span class="tab"></span><span class="small">environment &larr; Vector new: 1. environment◦1 &larr; Smalltalk]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">instvars</span><span class="small"><br></span><span class="tab"></span><span class="small">[superclass≡nil ? [!myinstvars asVector]<br></span><span class="tab"></span><span class="small">!superclass instvars concat: myinstvars asVector]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">understands:</span><span class="small"> code</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">install method</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[user displayoffwhile⦂ [Compiler new compile: code in: self]]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">canunderstand:</span><span class="small"> selector<br></span><span class="tab"></span><span class="small">[!messagedict has: selector]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">derstands:</span><span class="small"> selector<br></span><span class="tab"></span><span class="small">[messagedict &larr; messagedict delete: selector]&rsquo;<br>Class understands: </span><span class="small underline">&rsquo;install:</span><span class="small"> name </span><span class="small underline">method:</span><span class="small"> method </span><span class="small underline">literals:</span><span class="small"> literals<br></span><span class="tab"></span><span class="tab"></span><span class="small underline">code:</span><span class="small"> code </span><span class="small underline">backpointers:</span><span class="small"> backpointers<br></span><span class="tab"></span><span class="small">[</span><span class="tab"></span><span class="small">[messagedict has: name? [CodeKeeper next&larr; messagedict literals: name]].<br></span><span class="tab"></span><span class="small">messagedict &larr; messagedict insert: name method: method<br></span><span class="tab"></span><span class="tab"></span><span class="small">literals: literals code: code backpointers: backpointers]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">code:</span><span class="small"> selector<br></span><span class="tab"></span><span class="small">[!messagedict code: selector]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">new</span><span class="small"> [] primitive: 28&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">creation of instances</span><span class="small">↪<br>Class understands: &rsquo;</span><span class="small underline">printon:</span><span class="small"> strm<br></span><span class="tab"></span><span class="small">[strm append: title]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">allinstances</span><span class="small"> [] primitive: 60&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">enumeration</span><span class="small">↪<br></span><span class="tab"></span><span class="small">↪</span><span class="small italic">If Ted cant do it, nobody can...</span><span class="small">↪<br>Class understands: &rsquo;</span><span class="small underline">bytesize:</span><span class="small"> n</span><span class="tab"></span><span class="small">↪</span><span class="small italic">non-pointer declaration</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[fieldtype &larr; 32+ [n=8? [8] 16]]&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">vanilla or chocolate only</span><span class="small">↪</span><span class="small"><br></span><span class="small">Class understands: &rsquo;</span><span class="small underline">veryspecial:</span><span class="small"> n</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">for ClassClasses</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[instsize &larr; instsize+n]&rsquo;</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">secret freelist fields</span><span class="small">↪<br>Class understands: &rsquo;</span><span class="small underline">superclass</span><span class="small"> [!superclass]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">environment</span><span class="small"> [!environment]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">print:</span><span class="small"> inst </span><span class="small underline">on:</span><span class="small"> strm | ivars i<br></span><span class="tab"></span><span class="small">[ivars &larr; myinstvars asVector.<br></span><span class="tab"></span><span class="small">strm append: &rsquo;&rsquo;(&rsquo;&rsquo;; append: title; append: &rsquo;&rsquo; new &rsquo;&rsquo;.<br></span><span class="tab"></span><span class="small">for⦂ i to: instsize do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[strm append: ivars◦i; append: &rsquo;&rsquo;: &rsquo;&rsquo;;<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">print: </span><span class="small">(</span><span class="small">inst instfield: i</span><span class="small">)</span><span class="small">; space]<br></span><span class="tab"></span><span class="small">strm append: &rsquo;&rsquo;)&rsquo;&rsquo;]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">init</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic underline">init</span><span class="small italic"> and </span><span class="small italic underline">default</span><span class="small italic"> get propagated to instances</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[!self new init]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">default</span><span class="small"><br></span><span class="tab"></span><span class="small">[!self new default]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">copy:</span><span class="small"> inst | t i<br></span><span class="tab"></span><span class="small">[t &larr; self new.<br></span><span class="tab"></span><span class="small">for⦂ i to: instsize do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[t instfield: i &larr; inst instfield: i]<br></span><span class="tab"></span><span class="small">!t]&rsquo;<br>Class understands: &rsquo;</span><span class="small underline">recopy:</span><span class="small"> inst | t i<br></span><span class="tab"></span><span class="small">[t &larr; self new.<br></span><span class="tab"></span><span class="small">for⦂ i to: instsize do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[t instfield: i &larr; </span><span class="small">(</span><span class="small">inst instfield: i</span><span class="small">) recopy</span><span class="small">]<br></span><span class="tab"></span><span class="small">!t]&rsquo;<br>Class understands: &rsquo;ed: selector | c s<br></span><span class="tab"></span><span class="small">[c&larr; self code: selector. user clearshow: c.<br></span><span class="tab"></span><span class="small">while⦂ (s&larr; user request: &rsquo;&rsquo;substitute: &rsquo;&rsquo;) do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[c &larr; c subst: s for: (user request: &rsquo;&rsquo;for: &rsquo;&rsquo;).<br></span><span class="tab"></span><span class="tab"></span><span class="small">user clearshow: c]<br></span><span class="tab"></span><span class="small">self understands: c]&rsquo;<br></span><span class="small"><br></span><span class="small bold"><br></span><span class="medium bold">Class new title: &rsquo;VariableLengthClass&rsquo;;<br></span><span class="tab"></span><span class="medium bold">subclassof: Class;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;&rsquo;;<br></span><span class="tab"></span><span class="medium bold">veryspecial: 20<br></span><span class="small">VariableLengthClass understands: &rsquo;</span><span class="small underline">new:</span><span class="small"> length<br></span><span class="tab"></span><span class="small">[length ≥ 020000 ?[length print. user notify: &rsquo;&rsquo; is too large&rsquo;&rsquo;]<br></span><span class="tab"></span><span class="small">length &lt; 0 ?[length print. user notify: &rsquo;&rsquo; is too small&rsquo;&rsquo;]<br></span><span class="tab"></span><span class="small">!self new: length asInteger] primitive: 29&rsquo;<br>VariableLengthClass understands: &rsquo;</span><span class="small underline">new</span><span class="small"><br></span><span class="tab"></span><span class="small">[user notify: &rsquo;&rsquo;use new: &lt;Integer=length&gt; here.&rsquo;&rsquo;]&rsquo;<br>VariableLengthClass understands: &rsquo;</span><span class="small underline">copy:</span><span class="small"> inst | t i<br></span><span class="tab"></span><span class="small">[t &larr; self new: inst length.<br></span><span class="tab"></span><span class="small">for⦂ i to: inst length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[t◦i &larr; inst◦i]<br></span><span class="tab"></span><span class="small">!t]&rsquo;<br>VariableLengthClass understands: &rsquo;</span><span class="small underline">recopy:</span><span class="small"> inst | t i<br></span><span class="tab"></span><span class="small">[t &larr; self new: inst length.<br></span><span class="tab"></span><span class="small">for⦂ i to: inst length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[t◦i &larr; (inst◦i</span><span class="small">) recopy</span><span class="small">]<br></span><span class="tab"></span><span class="small">!t]&rsquo;<br></span><span class="small"><br></span><span class="small bold"><br></span><span class="medium bold">Class new title: &rsquo;Context&rsquo;;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;sender </span><span class="small">↪</span><span class="small italic">&lt;Context&gt; from which this message was sent</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">receiver </span><span class="small">↪</span><span class="small italic">&lt;Object&gt; to which this message was sent</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">mclass </span><span class="small">↪</span><span class="small italic">&lt;Class&gt; in which a method was found</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">method </span><span class="small">↪</span><span class="small italic">&lt;String&gt;, the encoded method</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">tempframe </span><span class="small">↪</span><span class="small italic">&lt;Vector&gt; to hold temporaries and a stack</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">pc </span><span class="small">↪</span><span class="small italic">&lt;Integer&gt; marks progress of execution in method</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">stackptr </span><span class="small">↪</span><span class="small italic">&lt;Integer&gt; offset of stack top in tempframe</span><span class="small">↪</span><span class="medium bold">&rsquo;<br></span><span class="small">Context understands: &rsquo;</span><span class="small underline">eval</span><span class="small"> [] primitive: 30&rsquo;<br>Context understands: &rsquo;</span><span class="small underline">sender:</span><span class="small"> sender </span><span class="small underline">receiver:</span><span class="small"> receiver </span><span class="small underline">mclass:</span><span class="small"> mclass<br></span><span class="tab"></span><span class="tab"></span><span class="small underline">method:</span><span class="small"> method </span><span class="small underline">tempframe:</span><span class="small"> tempframe </span><span class="small underline">pc:</span><span class="small"> pc </span><span class="small underline">stackptr:</span><span class="small"> stackptr&rsquo;<br>Context understands: &rsquo;</span><span class="small underline">remoteCopy</span><span class="small"><br></span><span class="tab"></span><span class="small">[!Context new sender: sender receiver: receiver mclass: mclass<br></span><span class="tab"></span><span class="tab"></span><span class="small">method: method tempframe: tempframe pc: pc+2 stackptr: stackptr]&rsquo;<br>Context understands: &rsquo;</span><span class="small underline">sender</span><span class="small"> [!sender]&rsquo;<br>Context understands: &rsquo;</span><span class="small underline">sender&larr;</span><span class="small"> sender []&rsquo;<br>Context understands: &rsquo;</span><span class="small underline">printon:</span><span class="small"> strm<br></span><span class="tab"></span><span class="small">[receiver class printon: strm. sender≡nil? []<br></span><span class="tab"></span><span class="tab"></span><span class="small">strm append: &rsquo;&rsquo;◦&rsquo;&rsquo;; print: sender thisop]&rsquo;<br>Context understands: &rsquo;</span><span class="small underline">trace</span><span class="small"> | strm a<br></span><span class="tab"></span><span class="small">[strm &larr; Stream default. self printon: strm.<br></span><span class="tab"></span><span class="small">a &larr; sender. until⦂ a≡nil do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[strm cr. a printon: strm. a &larr; a sender]<br></span><span class="tab"></span><span class="small">!strm contents]&rsquo;<br>Context understands: &rsquo;</span><span class="small underline">thisop</span><span class="small"> | a<br></span><span class="tab"></span><span class="small">[a &larr; method◦pc.<br></span><span class="tab"></span><span class="small">a≥0320? [!self litof: a-0320]<br></span><span class="tab"></span><span class="small">a≥0260? [!self specialops◦(1+a-0260)]<br></span><span class="tab"></span><span class="small">!"something]&rsquo;<br>Context understands: &rsquo;</span><span class="small underline">litof:</span><span class="small"> a<br></span><span class="tab"></span><span class="small">[!(method word: a+4) asObject]&rsquo;<br>Context understands: &rsquo;</span><span class="small underline">specialops</span><span class="small"><br></span><span class="tab"></span><span class="small">[!"(+ - &lt; &gt; ≤ ≥ = ≠<br></span><span class="tab"></span><span class="tab"></span><span class="small">* / \ | min: max: land: lor:<br></span><span class="tab"></span><span class="tab"></span><span class="small">◦ '&#771;&rsquo;◦&larr;&rsquo;&rsquo; atomize) next '&#771;&rsquo;next&larr;&rsquo;&rsquo; atomize) length ≡ nil nil<br></span><span class="tab"></span><span class="tab"></span><span class="small">class and: or: new new: to: oneToMeAsStream asStream)]&rsquo;<br>Context understands: &rsquo;</span><span class="small underline">debug</span><span class="small"> | t<br></span><span class="tab"></span><span class="small">[user cr. self print.<br></span><span class="tab"></span><span class="small">while⦂ [t &larr; user request: &rsquo;&rsquo;<br>*&rsquo;&rsquo;] do⦂ [user show: (selfⓢt) asString]]&rsquo;<br></span></div>
<div class="line center">
<span class="small"><br></span><span class="small">↪</span><span class="medium bold">NUMBERS</span><span class="small">↪</span></div>
<div class="line left">
<span class="medium bold">Class new title: &rsquo;Number&rsquo;;<br></span><span class="tab"></span><span class="medium bold">abstract</span><span class="small"></span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">Numbers in general</span><span class="small">↪</span><span class="small"><br></span><span class="small">Number understands: &rsquo;</span><span class="small underline">min:</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[self&gt;arg?[!arg]]&rsquo;<br>Number understands: &rsquo;</span><span class="small underline">max:</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[self&lt;arg?[!arg]]&rsquo;<br>Number understands: &rsquo;</span><span class="small underline">@</span><span class="small"> y<br></span><span class="tab"></span><span class="small">[!Point new x: self y: y]&rsquo;<br>Number understands: &rsquo;</span><span class="small underline">to:</span><span class="small"> x<br></span><span class="tab"></span><span class="small">[!Interval new from: self to: x by: 1]&rsquo;<br>Number understands: &rsquo;</span><span class="small underline">to:</span><span class="small"> x </span><span class="small underline">by:</span><span class="small"> y<br></span><span class="tab"></span><span class="small">[!Interval new from: self to: x by: y]&rsquo;<br>Number understands: &rsquo;</span><span class="small underline">subscripts:</span><span class="small"> a<br></span><span class="tab"></span><span class="small">[!a◦self asInteger]&rsquo;<br>Number understands: &rsquo;</span><span class="small underline">subscripts:</span><span class="small"> a </span><span class="small underline">&larr;</span><span class="small"> val<br></span><span class="tab"></span><span class="small">[!a◦self asInteger &larr; val]&rsquo;<br></span><span class="small"><br><br></span><span class="medium bold">Class new title: &rsquo;Integer&rsquo;;</span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">16-bit integers</span><span class="small">↪</span><span class="small"><br></span><span class="tab"></span><span class="medium bold">subclassof: Number;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;&rsquo;;<br></span><span class="tab"></span><span class="medium bold">bytesize: 16;<br></span><span class="tab"></span><span class="medium bold">veryspecial: 1</span><span class="tab"></span><span class="small">↪</span><span class="small italic">instance state not currently accessible</span><span class="small">↪</span><span class="medium bold"><br></span><span class="small">Integer understands: &rsquo;</span><span class="small underline">+</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self + arg asInteger] primitive: 6&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">-</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self - arg asInteger] primitive: 7&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">*</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self * arg asInteger] primitive: 21&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">/</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self / arg asInteger] primitive: 22&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">&lt;</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self &lt; arg asInteger] primitive: 8&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">=</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self = arg asInteger] primitive: 9&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">&gt;</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self &gt; arg asInteger] primitive: 10&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">≤</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self ≤ arg asInteger] primitive: 11&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">≠</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self ≠ arg asInteger] primitive: 12&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">≥</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self ≥ arg asInteger] primitive: 13&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">lshift:</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self lshift: arg asInteger] primitive: 25&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">land:</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self land: arg asInteger] primitive: 23&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">lor:</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self lor: arg asInteger] primitive: 24&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">xor:</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self xor: arg asInteger] primitive: 35&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">field:</span><span class="small"> fld<br></span><span class="tab"></span><span class="small">[!self field: fld asInteger] primitive: 36&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">field:</span><span class="small"> fld &larr; val<br></span><span class="tab"></span><span class="small">[!self field: fld asInteger &larr; val asInteger] primitive: 37&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">\</span><span class="small"> arg</span><span class="tab"></span><span class="small">↪mod↪<br></span><span class="tab"></span><span class="small">[!self \ arg asInteger] primitive: 26&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">|</span><span class="small"> arg</span><span class="tab"></span><span class="small">↪truncate↪<br></span><span class="tab"></span><span class="small">[!self/arg*arg]&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">printon:</span><span class="small"> strm<br></span><span class="tab"></span><span class="small">[self&lt;0?[strm append: &rsquo;&rsquo;¬&rsquo;&rsquo;. (0-self) absprinton: strm]<br></span><span class="tab"></span><span class="small">self absprinton: strm]&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">absprinton:</span><span class="small"> strm | rem<br></span><span class="tab"></span><span class="small">[rem &larr; self\10.<br></span><span class="tab"></span><span class="small">[self&gt;9? [self/10 absprinton: strm]].<br></span><span class="tab"></span><span class="small">strm next &larr; rem+060]&rsquo;<br>Integer understands: </span><span class="small">&rsquo;</span><span class="small underline">asInteger</span><span class="small"> [!self]&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">asFloat</span><span class="small"> [] primitive: 34&rsquo;<br>Integer understands: </span><span class="small">&rsquo;</span><span class="small underline">oneToMeAsStream</span><span class="tab"></span><span class="tab"></span><span class="small">↪used by for-loops↪<br></span><span class="tab"></span><span class="small">[!Stream new of: (Interval new from: 1 to: self by: 1)]&rsquo;<br>Integer understands: </span><span class="small">&rsquo;</span><span class="small underline">copy</span><span class="small"> [!self]&rsquo;<br>Integer understands: </span><span class="small">&rsquo;</span><span class="small underline">recopy</span><span class="small"> [!self]&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">isletter</span><span class="small"><br></span><span class="tab"></span><span class="small">[self ≥ 0141?</span><span class="tab"></span><span class="small">↪ a ↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">[!self ≤ 0172]</span><span class="tab"></span><span class="small">↪ z ↪<br></span><span class="tab"></span><span class="small">self ≥ 0101?</span><span class="tab"></span><span class="small">↪ A ↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">[!self ≤ 0132]</span><span class="tab"></span><span class="small">↪ Z ↪<br></span><span class="tab"></span><span class="small">!false]&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">isdigit </span><span class="small"><br></span><span class="tab"></span><span class="small">[self ≥ 060?</span><span class="tab"></span><span class="small">↪ 0 ↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">[!self ≤ 071]</span><span class="tab"></span><span class="small">↪ 9 ↪<br></span><span class="tab"></span><span class="small">!false]&rsquo;<br><br>↪Following two must be failures from Array subscripting: ↪<br>Integer understands: &rsquo;</span><span class="small underline">subscripts:</span><span class="small"> a<br></span><span class="tab"></span><span class="small">[user notify: &rsquo;&rsquo;Subscript out of bounds: &rsquo;&rsquo; + self asString]&rsquo;<br>Integer understands: &rsquo;</span><span class="small underline">subscripts:</span><span class="small"> a </span><span class="small underline">&larr;</span><span class="small"> val<br></span><span class="tab"></span><span class="small">[user notify: &rsquo;&rsquo;Subscript out of bounds: &rsquo;&rsquo; + self asString]&rsquo;<br><br>Integer understands: &rsquo;</span><span class="small underline">purge</span><span class="small"> [] primitive: 44&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">write this oop to disk</span><span class="small">↪<br></span><span class="tab"></span><span class="small">↪Warning: The Surgeon General has determined that the following message<br></span><span class="tab"></span><span class="small">may be hazardous to the health of your system.↪<br>Integer understands: &rsquo;</span><span class="small underline">asObject</span><span class="small"> [] primitive: 81&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">makes a pointer</span><span class="small">↪<br></span><span class="small"><br><br></span><span class="medium bold">Class new title: &rsquo;Float&rsquo;</span><span class="small">;</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">Floating-Point</span><span class="small">↪</span><span class="small"><br></span><span class="tab"></span><span class="medium bold">subclassof: Number;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;&rsquo;;<br></span><span class="tab"></span><span class="medium bold">bytesize: 16;<br></span><span class="tab"></span><span class="medium bold">veryspecial: 3</span><span class="tab"></span><span class="small">↪</span><span class="small italic">instance state not currently accessible</span><span class="small">↪</span><span class="medium bold"><br></span><span class="small">Float understands: &rsquo;</span><span class="small underline">+</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self+arg asFloat] primitive: 67&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">-</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self-arg asFloat] primitive: 68&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">*</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self*arg asFloat] primitive: 69&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">/</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self/arg asFloat] primitive: 70&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">&lt;</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self&lt;arg asFloat] primitive: 71&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">=</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self=arg asFloat] primitive: 72&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">≤</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self≤arg asFloat] primitive: 73&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">&gt;</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self&gt;arg asFloat] primitive: 74&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">≥</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self≥arg asFloat] primitive: 75&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">≠</span><span class="small"> arg<br></span><span class="tab"></span><span class="small">[!self≠arg asFloat] primitive: 76&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">fpart</span><span class="small"> [] primitive: 77&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">ipart</span><span class="small"><br></span><span class="tab"></span><span class="small">[!self-self fpart]&rsquo;</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">NOTE this isnt an Integer</span><span class="small">↪</span><span class="small"><br></span><span class="small">Float understands: &rsquo;</span><span class="small underline">asInteger</span><span class="small"> [] primitive: 78&rsquo;</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">this IS an Integer</span><span class="small">↪</span><span class="small"><br></span><span class="small">Float understands: &rsquo;</span><span class="small underline">sqrt</span><span class="small"> [] primitive: 79&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">ipow:</span><span class="small"> x</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">fixed powers in log n steps</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[x=0? [!1.0]<br></span><span class="tab"></span><span class="small">x=1? [!self]<br></span><span class="tab"></span><span class="small">x&gt;1? [!((self*self) ipow: x/2)*(self ipow: x\2)]<br></span><span class="tab"></span><span class="small">!1.0/(self ipow: 0-x)]&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">epart:</span><span class="small"> base | x</span><span class="tab"></span><span class="small">↪</span><span class="small italic">gives floor log.base self</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[self&lt;base? [!0]</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">self assumed positive</span><span class="small">↪<br></span><span class="tab"></span><span class="small">self&lt;(base*base)? [!1]<br></span><span class="tab"></span><span class="small">x &larr; 2*(self epart: base*base).</span><span class="tab"></span><span class="small">↪</span><span class="small italic">binary recursion like ipow</span><span class="small">↪<br></span><span class="tab"></span><span class="small">!x + ((self/(base ipow: x)) epart: base)]&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">printon:</span><span class="small"> strm<br></span><span class="tab"></span><span class="small">[self&lt;0.0? [strm append: &rsquo;&rsquo;¬&rsquo;&rsquo;. (0.0-self) absprinton: strm]<br></span><span class="tab"></span><span class="small">self absprinton: strm]&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">absprinton:</span><span class="small"> strm | x y q i fuzz<br></span><span class="tab"></span><span class="small">[fuzz &larr; 5.0e¬9.</span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">fuzz tracks significance</span><span class="small">↪<br></span><span class="tab"></span><span class="small">y &larr; [self&lt;1.0? [0-(10.0/self epart: 10.0)] self epart: 10.0].<br></span><span class="tab"></span><span class="small">x &larr; self/(10.0 ipow: y)+fuzz.</span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">normalize x</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[x≥10.0? [y &larr; y+1. x &larr; x/10.0]].</span><span class="tab"></span><span class="small">↪</span><span class="small italic">y = exponent</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[y&lt;6 and: y&gt;¬4?<br></span><span class="tab"></span><span class="tab"></span><span class="small">[q &larr; 0.</span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">decimal notation</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">y&lt;0? [strm append: &rsquo;&rsquo;0.0000&rsquo;&rsquo;◦(1 to: 1-y)]<br></span><span class="tab"></span><span class="tab"></span><span class="small">fuzz &larr; fuzz * 10.0 ipow: y].<br></span><span class="tab"></span><span class="small">q &larr; y. y &larr; 0].</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">scientific notation</span><span class="small">↪<br></span><span class="tab"></span><span class="small">for⦂ i to: 9 do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[strm next &larr; 060+x ipart.<br></span><span class="tab"></span><span class="tab"></span><span class="small">x &larr; 10.0 * x fpart.<br></span><span class="tab"></span><span class="tab"></span><span class="small">0&gt;(y &larr; y-1)?<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[x&lt;(fuzz &larr; fuzz*10.0)?[↪done - fix↪]<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">y=¬1? [strm append: &rsquo;&rsquo;.&rsquo;&rsquo;]]]<br></span><span class="tab"></span><span class="small">[y=¬1?[strm append: &rsquo;&rsquo;.0&rsquo;&rsquo;]].<br></span><span class="tab"></span><span class="small">q≠0?[strm append: &rsquo;&rsquo;e&rsquo;&rsquo;; print: q]]&rsquo;<br>Float understands: &rsquo;</span><span class="small underline">asFloat</span><span class="small">&rsquo;</span><span class="small"><br></span><span class="small">Float understands: </span><span class="small">&rsquo;</span><span class="small underline">copy</span><span class="small"> [!self]&rsquo;<br>Float understands: </span><span class="small">&rsquo;</span><span class="small underline">recopy</span><span class="small"> [!self]&rsquo;<br></span></div>
<div class="line center">
<span class="small"><br></span><span class="small">↪</span><span class="medium bold">ARRAYS</span><span class="small">↪</span></div>
<div class="line left">
<span class="medium bold">Class new title: &rsquo;Array&rsquo;;<br></span><span class="tab"></span><span class="medium bold">abstract</span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">arrays in general</span><span class="small">↪</span><span class="small bold"><br></span><span class="small">Array understands: &rsquo;</span><span class="small underline">length</span><span class="small"> [] primitive: 16&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">◦</span><span class="small"> x<br></span><span class="tab"></span><span class="small">[!x subscripts: self] primitive: 38&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">◦</span><span class="small"> x </span><span class="small underline">&larr;</span><span class="small"> val<br></span><span class="tab"></span><span class="small">[!x subscripts: self &larr; val] primitive: 39&rsquo;<br>↪</span><span class="small italic">Note that subscripting by an integer is primitive.  A subscript of another class will be called with the message subscripts: array, in the hopes that it knows how to behave as a subscript.</span><span class="small">↪</span><span class="small italic"><br></span><span class="small">Array understands: &rsquo;</span><span class="small underline">subscripts:</span><span class="small"> x</span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">↪subarrays↪<br></span><span class="tab"></span><span class="small">[!Substring new data: x map: self]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">subscripts:</span><span class="small"> x </span><span class="small underline">&larr;</span><span class="small"> val</span><span class="tab"></span><span class="tab"></span><span class="small">↪subrange replacement↪<br></span><span class="tab"></span><span class="small">[self length≠val length?<br></span><span class="tab"></span><span class="tab"></span><span class="small">[user notify: &rsquo;&rsquo;lengths not commensurate&rsquo;&rsquo;]<br></span><span class="tab"></span><span class="small">val copyto: (Substring new data: x map: self).<br></span><span class="tab"></span><span class="small">!val]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">all &larr;</span><span class="small"> val | i<br></span><span class="tab"></span><span class="small">[for⦂ i to: self length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[self◦i &larr; val]]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">=</span><span class="small"> arg | x<br></span><span class="tab"></span><span class="small">[self length ≠ arg length? [!false]<br></span><span class="tab"></span><span class="small">for⦂ x to: self length do⦂ <br></span><span class="tab"></span><span class="tab"></span><span class="small">[(self◦x) = (arg◦x)? [] !false]<br></span><span class="tab"></span><span class="small">!true]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">find:</span><span class="small"> x | i<br></span><span class="tab"></span><span class="small">[for⦂ i to: self length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[self◦i=x? [!i]].<br></span><span class="tab"></span><span class="small">!0]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">findnon:</span><span class="small"> x | i<br></span><span class="tab"></span><span class="small">[for⦂ i to: self length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[self◦i≠x? [!i]].<br></span><span class="tab"></span><span class="small">!0]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">has:</span><span class="small"> x<br></span><span class="tab"></span><span class="small">[!0≠(self find: x)]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">reverse</span><span class="tab"></span><span class="small"><br></span><span class="tab"></span><span class="small">[!Substring new data: self map: (self length to: 1 by: ¬1)]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">concat:</span><span class="small"> arg | x<br></span><span class="tab"></span><span class="small">[x &larr; self species new: self length + arg length.<br></span><span class="tab"></span><span class="small">x◦(1 to: self length) &larr; self.<br></span><span class="tab"></span><span class="small">x◦(self length+1 to: x length) &larr; arg.  !x]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">copy</span><span class="small"><br></span><span class="tab"></span><span class="small">[!self copyto: (self species new: self length)]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">copyto:</span><span class="small"> t | i s<br></span><span class="tab"></span><span class="small">[s &larr; t asStream.<br></span><span class="tab"></span><span class="small">for⦂ i from: self do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[s next&larr; i]<br></span><span class="tab"></span><span class="small">!t]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">replace:</span><span class="small"> a </span><span class="small underline">to:</span><span class="small"> b </span><span class="small underline">by:</span><span class="small"> s | x<br></span><span class="tab"></span><span class="small">[x &larr; self species new: self length+s length -(1+b-a).<br></span><span class="tab"></span><span class="small">x◦(1 to: a-1) &larr; self◦(1 to: a-1).  t&larr;a+s length-1.<br></span><span class="tab"></span><span class="small">x◦(a to: t) &larr; s.<br></span><span class="tab"></span><span class="small">x◦(t+1 to: x length) &larr; self◦(b+1 to: self length).<br></span><span class="tab"></span><span class="small">!x]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">growby:</span><span class="small"> n<br></span><span class="tab"></span><span class="small">[!self copyto: (self species new: self length+n)]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">grow</span><span class="small"><br></span><span class="tab"></span><span class="small">[!self copyto: (self species new: (4 max: self length*2))]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">last</span><span class="small"><br></span><span class="tab"></span><span class="small">[!self◦self length]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">last &larr;</span><span class="small"> val<br></span><span class="tab"></span><span class="small">[!self◦self length &larr; val]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">species</span><span class="small"><br></span><span class="tab"></span><span class="small">[!Vector]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">read<br></span><span class="tab"></span><span class="small">[!self new asStream read]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">asStream</span><span class="small"><br></span><span class="tab"></span><span class="small">[!Stream new of: self]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">isIntervalBy1</span><span class="small"><br></span><span class="tab"></span><span class="small">[!false]&rsquo;<br>Array understands: &rsquo;</span><span class="small underline">swap:</span><span class="small"> i </span><span class="small underline">with:</span><span class="small"> j | t<br></span><span class="tab"></span><span class="small">[t &larr; self◦i. self◦i &larr; self◦j. self◦j &larr; t]&rsquo;</span></div>
<div class="line left">
<span class="small bold"><br><br></span><span class="medium bold">VariableLengthClass new title: &rsquo;Vector&rsquo;;</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small">Array</span><span class="small italic"> of objects</span><span class="small">↪</span><span class="small bold"><br></span><span class="tab"></span><span class="medium bold">subclassof: Array<br></span><span class="small">Vector understands: &rsquo;</span><span class="small underline">,</span><span class="small"> x | v<br></span><span class="tab"></span><span class="small">[v &larr; self growby: 1.</span><span class="tab"></span><span class="small">↪</span><span class="small italic">use a stream if youre in a hurry</span><span class="small">↪<br></span><span class="tab"></span><span class="small">v last &larr; x. !v]&rsquo;<br>Vector understands: &rsquo;</span><span class="small underline">printon:</span><span class="small"> strm | i<br></span><span class="tab"></span><span class="small">[strm append: &rsquo;&rsquo;(&rsquo;&rsquo;.<br></span><span class="tab"></span><span class="small">for⦂ i to: self length-1 do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[strm print: self◦i; append: &rsquo;&rsquo;, &rsquo;&rsquo;].<br></span><span class="tab"></span><span class="small">strm print: self last; append: &rsquo;&rsquo;)&rsquo;&rsquo; ]&rsquo;<br></span><span class="small"><br><br></span><span class="medium bold">VariableLengthClass new title: &rsquo;String&rsquo;;</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">Array of 8-bit bytes</span><span class="small">↪</span><span class="small bold"><br></span><span class="tab"></span><span class="medium bold">subclassof: Array;<br></span><span class="tab"></span><span class="medium bold">bytesize: 8<br></span><span class="small">String understands: &rsquo;</span><span class="small underline">word:</span><span class="small"> x</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">read word in String</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[!self◦(2*x) + (self◦(2*x-1) lshift: 8)]&rsquo;<br>String understands: &rsquo;</span><span class="small underline">word:</span><span class="small"> x </span><span class="small underline">&larr;</span><span class="small"> y</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">write word in String</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[self◦(2*x) &larr; y land: 0377.<br></span><span class="tab"></span><span class="small">self◦(2*x-1) &larr; y lshift: ¬8. !y]&rsquo;<br>String understands: &rsquo;</span><span class="small underline">printon:</span><span class="small"> strm | x</span><span class="tab"></span><span class="small">↪</span><span class="small italic">print inside string quotes</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[strm next&larr; 047.<br></span><span class="tab"></span><span class="small">for⦂ x from: self do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[strm next&larr; x.<br></span><span class="tab"></span><span class="tab"></span><span class="small">x=047?[strm next&larr; x]]</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">imbedded quotes get doubled</span><span class="small">↪<br></span><span class="tab"></span><span class="small">strm next&larr; 047]&rsquo;<br>String understands: &rsquo;</span><span class="small underline">species</span><span class="small"><br></span><span class="tab"></span><span class="small">[!String]&rsquo;<br>String understands: &rsquo;</span><span class="small underline">asVector</span><span class="small"><br></span><span class="tab"></span><span class="small">[!self asStream asVector]&rsquo;<br>String understands: &rsquo;</span><span class="small underline">asParagraph</span><span class="small"><br></span><span class="tab"></span><span class="small">[!Paragraph new text: self alignment: 0]&rsquo;<br>String understands: &rsquo;</span><span class="small underline">recopy</span><span class="small"><br></span><span class="tab"></span><span class="small">[!self copy]&rsquo;<br>String understands: &rsquo;</span><span class="small underline">subst:</span><span class="small"> repl </span><span class="small underline">for:</span><span class="small"> key | key1 i nskip result<br></span><span class="tab"></span><span class="small">[nskip &larr; 0. key1 &larr; key◦1. result &larr; Stream default.<br></span><span class="tab"></span><span class="small">for⦂ i to: self length do⦂</span><span class="tab"></span><span class="tab"></span><span class="small">↪ </span><span class="small italic">the Boyer Slow string replacement</span><span class="small"> ↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">[nskip&gt;0? [nskip &larr; nskip-1]<br></span><span class="tab"></span><span class="tab"></span><span class="small">self◦i = key1?<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[self◦(i to: (self length min: i+key length-1)) = key?<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[result append: repl. nskip &larr; key length-1]<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">result next&larr; self◦i]<br></span><span class="tab"></span><span class="tab"></span><span class="small">result next&larr; self◦i]<br></span><span class="tab"></span><span class="small">!result contents]&rsquo;<br>String understands: &rsquo;</span><span class="small underline">unique</span><span class="small"> | u</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">copy and intern</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[u &larr; UniqueString new: self length.<br></span><span class="tab"></span><span class="small">!u of: self]&rsquo;<br>String understands: &rsquo;</span><span class="small underline">hash</span><span class="small"> | x h</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">not great, but compatible with FT atom hashing</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[h &larr; 13131.<br></span><span class="tab"></span><span class="small">for⦂ x from: self do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[h &larr; x * h.<br></span><span class="tab"></span><span class="tab"></span><span class="small">h &larr; (h lshift: ¬1)+(h lshift: 15)]<br></span><span class="tab"></span><span class="small">!h]&rsquo;<br></span><span class="small"><br><br></span><span class="medium bold">VariableLengthClass new title: &rsquo;UniqueString&rsquo;;</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">allows fast compare (eq) for tables</span><span class="small">↪</span><span class="small bold"><br></span><span class="tab"></span><span class="medium bold">subclassof: String;<br></span><span class="tab"></span><span class="medium bold">bytesize: 8</span><span class="small"></span><span class="medium bold"><br></span><span class="small">UniqueString understands: &rsquo;</span><span class="small underline">of:</span><span class="small"> s | i a v <br></span><span class="tab"></span><span class="small">[a &larr; self intern: s hash: (i&larr;s hash)? [!a]<br></span><span class="tab"></span><span class="small">i &larr; 1+(i lshift: ¬8).<br></span><span class="tab"></span><span class="small">v &larr; USTable◦i.<br></span><span class="tab"></span><span class="small">USTable◦i &larr; Vector new: 2*v length.</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">grow that hash bucket</span><span class="small">↪<br></span><span class="tab"></span><span class="small">for⦂ a from: v do⦂</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">copy all its contents</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">[a≡nil? []<br></span><span class="tab"></span><span class="tab"></span><span class="small">self intern: a hash: a stringhash]<br></span><span class="tab"></span><span class="small">!self of: s]&rsquo;</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">and try again... </span><span class="small">↪<br>UniqueString understands: &rsquo;</span><span class="small underline">intern:</span><span class="small"> s </span><span class="small underline">hash:</span><span class="small"> h| i j v n<br></span><span class="tab"></span><span class="small">[v &larr; USTable◦(1+(h lshift: ¬8)).<br></span><span class="tab"></span><span class="small">for⦂ i to: v length do⦂</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">interning compatible with FT atoms - change it soon</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">[h &larr; h\v length+1.<br></span><span class="tab"></span><span class="tab"></span><span class="small">v◦h≡nil?</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">empty slot</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[s is: UniqueString? [!v◦h &larr; s]</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">(when growing)</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">n&larr; 0.  for⦂ j from: v do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[j≡nil? [n &larr; n+1]]</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">count # empty slots</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">4*n &lt; v length?[!false]</span><span class="tab"></span><span class="small">↪</span><span class="small italic">grow if not 1/4</span><span class="small"> ↪<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">for⦂ j to: s length do⦂</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">copy string</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[super◦j &larr; s◦j]</span><span class="tab"></span><span class="small">↪</span><span class="small italic">where there-s a will there-s a way</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">!v◦h &larr; self]</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">and install self as the atom</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">s=(v◦h)?[!v◦h]]<br></span><span class="tab"></span><span class="small">user notify: &rsquo;&rsquo;USTable jammed (UniqueString)&rsquo;&rsquo;]&rsquo;<br>UniqueString understands: &rsquo;</span><span class="small underline">stringhash</span><span class="small"><br></span><span class="tab"></span><span class="small">[!super hash]&rsquo;<br>UniqueString understands: &rsquo;</span><span class="small underline">◦</span><span class="small">x </span><span class="small underline">&larr;</span><span class="small"> val<br></span><span class="tab"></span><span class="small">[user notify: &rsquo;&rsquo;UniqueStrings are not for writing into&rsquo;&rsquo;]&rsquo;<br>UniqueString understands: &rsquo;</span><span class="small underline">printon:</span><span class="small"> strm<br></span><span class="tab"></span><span class="small">[strm append: self]&rsquo;<br>UniqueString understands: &rsquo;</span><span class="small underline">isinfix</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">one-char non-alpha</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[self length≠1? [!false]  !(self◦1) isletter≡false]&rsquo;<br>UniqueString understands: &rsquo;</span><span class="small underline">iskeyword</span><span class="small"> | x</span><span class="tab"></span><span class="small">↪</span><span class="small italic">ends with open or closed colon</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[self length≤1? [!false]<br></span><span class="tab"></span><span class="small">x &larr; self◦self length.<br></span><span class="tab"></span><span class="small">x=072?[!true] !x=03]&rsquo;<br>UniqueString understands: &rsquo;</span><span class="small underline">isuneval</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">ends with open colon</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[!self◦self length=03]&rsquo;<br>UniqueString understands: &rsquo;</span><span class="small underline">=</span><span class="small"> x [!self≡x]&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">pointer compare</span><span class="small">↪<br>UniqueString understands: &rsquo;</span><span class="small underline">hash</span><span class="small"> [] primitive: 46&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">just the object pointer</span><span class="small">↪<br>UniqueString understands: &rsquo;</span><span class="small underline">unique</span><span class="small">&rsquo;<br></span><span class="small"><br><br></span><span class="medium bold">Class new title: &rsquo;Substring&rsquo;;</span><span class="tab"></span><span class="tab"></span><span class="small">↪Substring</span><span class="small italic">s and permutations</span><span class="small">↪</span><span class="small bold"><br></span><span class="tab"></span><span class="medium bold">subclassof: Array;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;data map</span><span class="small">&rsquo;</span><span class="medium bold"><br></span><span class="small">Substring understands: &rsquo;</span><span class="small underline">data:</span><span class="small"> data </span><span class="small underline">map:</span><span class="small"> map&rsquo;<br>Substring understands: &rsquo;</span><span class="small underline">◦</span><span class="small"> x<br></span><span class="tab"></span><span class="small">[!data◦(map◦x)]&rsquo;<br>Substring understands: &rsquo;</span><span class="small underline">◦</span><span class="small"> x </span><span class="small underline">&larr;</span><span class="small"> val<br></span><span class="tab"></span><span class="small">[!data◦(map◦x) &larr; val]&rsquo;<br>Substring understands: &rsquo;</span><span class="small underline">length</span><span class="small"><br></span><span class="tab"></span><span class="small">[!map length]&rsquo;<br>Substring understands: &rsquo;</span><span class="small underline">species</span><span class="small"><br></span><span class="tab"></span><span class="small">[!data species]&rsquo;<br>Substring understands: &rsquo;</span><span class="small underline">asStream</span><span class="small"><br></span><span class="tab"></span><span class="small">[map isIntervalBy1?</span><span class="tab"></span><span class="small">↪</span><span class="small italic">direct stream for simple substrings</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">[!Stream new of: data from: map start to: map stop]<br></span><span class="tab"></span><span class="small">!Stream new of: self from: 1 to: map length]&rsquo;<br></span><span class="small"><br><br></span><span class="medium bold">Class new title: &rsquo;Interval&rsquo;;</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">Intervals - Integer or Float</span><span class="small">↪</span><span class="small bold"><br></span><span class="tab"></span><span class="medium bold">subclassof: Array;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;start stop step length</span><span class="small">&rsquo;</span><span class="medium bold"><br></span><span class="small">Interval understands: &rsquo;</span><span class="small underline">from:</span><span class="small"> start </span><span class="small underline">to:</span><span class="small"> stop </span><span class="small underline">by:</span><span class="small"> step<br></span><span class="tab"></span><span class="small">[length &larr; 1+(stop-start/step)]&rsquo;<br>Interval understands: &rsquo;</span><span class="small underline">◦</span><span class="small"> x<br></span><span class="tab"></span><span class="small">[x&lt;1? [!nil]<br></span><span class="tab"></span><span class="small">x&gt;length? [!nil]<br></span><span class="tab"></span><span class="small">!start+(x-1*step)]&rsquo;<br>Interval understands: &rsquo;</span><span class="small underline">◦</span><span class="small"> x </span><span class="small underline">&larr;</span><span class="small"> val<br></span><span class="tab"></span><span class="small">[user notify: &rsquo;&rsquo;Intervals are not for writing into&rsquo;&rsquo;]&rsquo;<br>Interval understands: &rsquo;</span><span class="small underline">length</span><span class="small"> [!length]&rsquo;<br>Interval understands: &rsquo;</span><span class="small underline">isIntervalBy1</span><span class="small"><br></span><span class="tab"></span><span class="small">[!step=1]&rsquo;</span></div>
<div class="line left">
<span class="small">Interval understands: &rsquo;</span><span class="small underline">start</span><span class="small"> [!start]&rsquo;<br>Interval understands: &rsquo;</span><span class="small underline">stop</span><span class="small"> [!stop]&rsquo;<br></span><span class="small"><br><br></span><span class="medium bold">Class new title: &rsquo;CoreLocs&rsquo;;</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">Proceed at your own risk...</span><span class="small">↪</span><span class="small bold"><br></span><span class="tab"></span><span class="medium bold">subclassof: Array;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;base length</span><span class="small">&rsquo;</span><span class="medium bold"><br></span><span class="small">CoreLocs understands: &rsquo;</span><span class="small underline">base:</span><span class="small"> base </span><span class="small underline">length:</span><span class="small"> length&rsquo;</span></div>
<div class="line left">
<span class="small">CoreLocs understands: &rsquo;</span><span class="small underline">◦</span><span class="small"> x [] primitive: 42&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">contents of memory location x</span><span class="small">↪</span></div>
<div class="line left">
<span class="small">CoreLocs understands: &rsquo;</span><span class="small underline">◦</span><span class="small"> x </span><span class="small underline">&larr; val</span><span class="small"> [] primitive: 43&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">stores into memory location x</span><span class="small">↪</span></div>
<div class="line left">
<span class="small">CoreLocs understands: &rsquo;</span><span class="small underline">length</span><span class="small"> [!length]&rsquo;</span></div>
<div class="line left">
</div>
<div class="line center">
<span class="small"><br></span><span class="small">↪</span><span class="medium bold">STREAMS</span><span class="small">↪</span></div>
<div class="line left">
<span class="medium bold">Class new title: &rsquo;Stream&rsquo;;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;array position limit</span><span class="small">&rsquo;</span><span class="medium bold"><br></span><span class="small">Stream understands: &rsquo;</span><span class="small underline">of:</span><span class="small"> array<br></span><span class="tab"></span><span class="small">[position &larr; 0. limit &larr; array length]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">of:</span><span class="small"> array </span><span class="small underline">from:</span><span class="small"> position </span><span class="small underline">to:</span><span class="small"> limit<br></span><span class="tab"></span><span class="small">[position &larr; position-1]&rsquo;<br>Stream understands: &rsquo;default<br></span><span class="tab"></span><span class="small">[self of: (String new: 8)]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">next</span><span class="tab"></span><span class="small">↪</span><span class="small italic">simple result</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[self myend? [!self pastend]<br></span><span class="tab"></span><span class="small">!array◦(position &larr; position+1)] primitive: 17&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">next &larr;</span><span class="small"> x</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">simple arg</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[self myend? [!self pastend &larr; x]<br></span><span class="tab"></span><span class="small">!array◦(position &larr; position+1) &larr; x] primitive: 18&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">append:</span><span class="small"> x | i</span><span class="tab"></span><span class="small">↪</span><span class="small italic">Array arg</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[for⦂ i from: x do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[self next &larr; i].<br></span><span class="tab"></span><span class="small">!x]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">myend</span><span class="small"><br></span><span class="tab"></span><span class="small">[!position≥limit]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">pastend</span><span class="small"><br></span><span class="tab"></span><span class="small">[!false]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">pastend &larr;</span><span class="small"> x<br></span><span class="tab"></span><span class="small">[array &larr; array grow. limit &larr; array length.<br></span><span class="tab"></span><span class="small">!self next &larr; x]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">into:</span><span class="small"> x | i</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">Array result</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[for⦂ i to: x length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[x◦i &larr; self next].<br></span><span class="tab"></span><span class="small">!x]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">contents</span><span class="small"><br></span><span class="tab"></span><span class="small">[!(array◦(1 to: position)) copy]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">skip:</span><span class="small"> x<br></span><span class="tab"></span><span class="small">[position &larr; position+x]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">reset</span><span class="small"><br></span><span class="tab"></span><span class="small">[position &larr; 0]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">end</span><span class="small"><br></span><span class="tab"></span><span class="small">[!position≥limit]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">position</span><span class="small"><br></span><span class="tab"></span><span class="small">[!position]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">loc</span><span class="tab"></span><span class="small">↪</span><span class="small italic">synonym for compiler</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[!position]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">empty</span><span class="small"><br></span><span class="tab"></span><span class="small">[!position=0]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">peek</span><span class="small"> | x<br></span><span class="tab"></span><span class="small">[x&larr; self next? [position &larr; position-1.  !x]</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">peek at next element</span><span class="small">↪<br></span><span class="tab"></span><span class="small">!false]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">%</span><span class="small"> x | y<br></span><span class="tab"></span><span class="small">[y&larr; self next?</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">peek for matching element</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">[x=y? [!y]</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">gobble it if found</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">position &larr; position-1. !false]<br></span><span class="tab"></span><span class="small">!false]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">pop</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">use it as a LIFO</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[position&lt;1? [!false]<br></span><span class="tab"></span><span class="small">position &larr; position-1. !array◦</span><span class="small">(</span><span class="small">position+1</span><span class="small">)</span><span class="small">]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">pop:</span><span class="small"> n | t<br></span><span class="tab"></span><span class="small">[position&lt;n? [!false]<br></span><span class="tab"></span><span class="small">t &larr; self last: n.<br></span><span class="tab"></span><span class="small">position &larr; position-n. !t]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">last</span><span class="small"><br></span><span class="tab"></span><span class="small">[!array◦position]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">last:</span><span class="small"> n<br></span><span class="tab"></span><span class="small">[!(array◦(position-n+1 to: position)) copy]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">dequeue</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">use it as a FIFO</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[!self dequeue: 1]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">dequeue</span><span class="small underline">:</span><span class="small"> n | t<br></span><span class="tab"></span><span class="small">[position&lt;n? [!false]<br></span><span class="tab"></span><span class="small">t &larr; (array◦(1 to: n)) copy.<br></span><span class="tab"></span><span class="small">array◦(1 to: position-n) &larr; array◦(n+1 to: position).<br></span><span class="tab"></span><span class="small">position &larr; position-n. !t]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">upto:</span><span class="small"> x | y s<br></span><span class="tab"></span><span class="small">[s &larr; Stream default.<br></span><span class="tab"></span><span class="small">until⦂ [x = (y &larr; self next)] do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[s next &larr; y].<br></span><span class="tab"></span><span class="small">self skip: ¬1.  !s contents]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">◦</span><span class="small"> x </span><span class="small underline">&larr;</span><span class="small"> val<br></span><span class="tab"></span><span class="small">[!array◦x &larr; val]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">◦</span><span class="small"> x<br></span><span class="tab"></span><span class="small">[!array◦x]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">space</span><span class="small"><br></span><span class="tab"></span><span class="small">[self next &larr; 040]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">tab</span><span class="small"><br></span><span class="tab"></span><span class="small">[self next &larr; 011]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">cr</span><span class="small"><br></span><span class="tab"></span><span class="small">[self next &larr; 015]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">print:</span><span class="small"> obj<br></span><span class="tab"></span><span class="small">[obj printon: self]&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">asStream</span><span class="small">&rsquo;<br>Stream understands: &rsquo;</span><span class="small underline">asVector</span><span class="small"><br></span><span class="tab"></span><span class="small">[!(Reader new of: self) read]&rsquo;<br></span></div>
<div class="line center">
<span class="small"><br></span><span class="small">↪</span><span class="medium bold">GRAPHICAL OBJECTS</span><span class="small">↪</span></div>
<div class="line left">
<span class="medium bold">Class new title: &rsquo;Point&rsquo;;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;x y</span><span class="small">&rsquo;</span><span class="medium bold"><br></span><span class="small">Point understands: &rsquo;</span><span class="small underline">x:</span><span class="small"> x </span><span class="small underline">y:</span><span class="small"> y&rsquo;<br>Point understands: &rsquo;</span><span class="small underline">x &larr;</span><span class="small"> x&rsquo;<br>Point understands: &rsquo;</span><span class="small underline">x</span><span class="tab"></span><span class="small"> [!x]&rsquo;<br>Point understands: &rsquo;</span><span class="small underline">y &larr;</span><span class="small"> y&rsquo;<br>Point understands: &rsquo;</span><span class="small underline">y</span><span class="small"> [!y]&rsquo;<br>Point understands: &rsquo;</span><span class="small underline">=</span><span class="small"> pt<br></span><span class="tab"></span><span class="small">[!x=pt x and: y=pt y]&rsquo;<br>Point understands: &rsquo;</span><span class="small underline">&lt;</span><span class="small"> pt<br></span><span class="tab"></span><span class="small">[!x&lt;pt x and: y&lt;pt y]&rsquo;<br>Point understands: &rsquo;</span><span class="small underline">≤</span><span class="small"> pt<br></span><span class="tab"></span><span class="small">[!x≤pt x and: y≤pt y]&rsquo;<br>Point understands: &rsquo;</span><span class="small underline">+</span><span class="small"> pt<br></span><span class="tab"></span><span class="small">[!Point new x: x+pt x y: y+pt y]&rsquo;<br>Point understands: &rsquo;</span><span class="small underline">-</span><span class="small"> pt<br></span><span class="tab"></span><span class="small">[!Point new x: x-pt x y: y-pt y]&rsquo;<br>Point understands: &rsquo;</span><span class="small underline">*</span><span class="small"> scale<br></span><span class="tab"></span><span class="small">[!Point new x: x*scale y: y*scale]&rsquo;<br>Point understands: &rsquo;</span><span class="small underline">/</span><span class="small"> scale<br></span><span class="tab"></span><span class="small">[!Point new x: x/scale y: y/scale]&rsquo;<br>Point understands: &rsquo;</span><span class="small underline">|</span><span class="small"> grid<br></span><span class="tab"></span><span class="small">[!Point new x: x|grid y: y|grid]&rsquo;<br>Point understands: &rsquo;</span><span class="small underline">max:</span><span class="small"> t<br></span><span class="tab"></span><span class="small">[!Point new x: (x max: t x) y: (y max: t y)]&rsquo;<br>Point understands: &rsquo;</span><span class="small underline">min:</span><span class="small"> t<br></span><span class="tab"></span><span class="small">[!Point new x: (x min: t x) y: (y min: t y)]&rsquo;<br>Point understands: &rsquo;</span><span class="small underline">rect:</span><span class="small"> p</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">infix creation of rectangles</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[!Rectangle new origin: self corner: p]&rsquo;<br></span><span class="small"><br><br></span><span class="small">Smalltalk insertall: "(black white gray ltgray dkgray backround <br></span><span class="tab"></span><span class="tab"></span><span class="small">storing oring xoring erasing)<br></span><span class="tab"></span><span class="small">with: "(0177777  0  055132  0101202  076575 055132  <br></span><span class="tab"></span><span class="tab"></span><span class="small">0 1 2 3).<br></span><span class="medium bold">Class new title: &rsquo;Rectangle&rsquo;;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;origin corner</span><span class="small">&rsquo;</span><span class="medium bold"><br></span><span class="small">Rectangle understands: &rsquo;</span><span class="small underline">origin:</span><span class="small"> origin </span><span class="small underline">corner:</span><span class="small"> corner&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">origin</span><span class="small"> [!origin]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">origin &larr;</span><span class="small"> origin&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">corner</span><span class="small"> [!corner]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">corner &larr;</span><span class="small"> corner&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">extent</span><span class="small"><br></span><span class="tab"></span><span class="small">[!corner-origin]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">extent &larr;</span><span class="small"> extent<br></span><span class="tab"></span><span class="small">[corner &larr; origin+extent. !extent]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">has:</span><span class="small"> pt<br></span><span class="tab"></span><span class="small">[!origin≤pt and: pt&lt;corner]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">width</span><span class="small"><br></span><span class="tab"></span><span class="small">[!corner x - origin x]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">height</span><span class="small"><br></span><span class="tab"></span><span class="small">[!corner y - origin y]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">blt:</span><span class="small"> dest </span><span class="small underline">mode:</span><span class="small"> mode [] primitive: 47&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">bltcomp:</span><span class="small"> dest </span><span class="small underline">mode:</span><span class="small"> mode [] primitive: 48&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">brush:</span><span class="small"> dest </span><span class="small underline">mode:</span><span class="small"> mode </span><span class="small underline">color:</span><span class="small"> color [] primitive: 49&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">color:</span><span class="small"> color </span><span class="small underline">mode:</span><span class="small"> mode [] primitive: 50&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">clear:</span><span class="small"> color<br></span><span class="tab"></span><span class="small">[self color: color mode: storing]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">clear</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">default is backround</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[self color: backround mode: storing]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">comp</span><span class="small"><br></span><span class="tab"></span><span class="small">[self color: black mode: xoring]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">dragto:</span><span class="small"> dest | b<br></span><span class="tab"></span><span class="small">[self blt: dest mode: storing.</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">copy to new destination</span><span class="small">↪<br></span><span class="tab"></span><span class="small">b &larr; corner+dest-origin.</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">and clear non-intersecting source</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[(origin max: dest) ≤ (corner min: b)?<br></span><span class="tab"></span><span class="tab"></span><span class="small">[[dest x&gt;origin x?<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[</span><span class="small">(</span><span class="small">origin rect: dest x@corner y</span><span class="small">)</span><span class="small"> clear]<br></span><span class="tab"></span><span class="tab"></span><span class="small">dest x&lt;origin x?<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[</span><span class="small">(</span><span class="small">b x@origin y rect: corner</span><span class="small">)</span><span class="small"> clear]].<br></span><span class="tab"></span><span class="tab"></span><span class="small">[dest y&gt;origin y?<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[(origin rect: corner x@dest y</span><span class="small">)</span><span class="small"> clear]<br></span><span class="tab"></span><span class="tab"></span><span class="small">dest y&lt;origin y?<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">[</span><span class="small">(</span><span class="small">origin x@b y rect: corner</span><span class="small">)</span><span class="small"> clear]] ]<br></span><span class="tab"></span><span class="small">self clear]<br></span><span class="tab"></span><span class="small">origin &larr; dest. corner &larr; b]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">inset:</span><span class="small"> p1 </span><span class="small underline">and:</span><span class="small"> p2<br></span><span class="tab"></span><span class="small">[!origin+p1 rect: corner-p2]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">inset:</span><span class="small"> p1<br></span><span class="tab"></span><span class="small">[!origin+p1 rect: corner-p1]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">moveto:</span><span class="small"> pt<br></span><span class="tab"></span><span class="small">[corner &larr; corner+pt-origin. origin&larr;pt]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">moveby:</span><span class="small"> pt<br></span><span class="tab"></span><span class="small">[origin &larr; origin+pt. corner &larr; corner+pt]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">growto:</span><span class="small"> corner &rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">center</span><span class="small"><br></span><span class="tab"></span><span class="small">[!origin+corner/2]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">outline:</span><span class="small"> thick | t<br></span><span class="tab"></span><span class="small">[t &larr; (¬1@¬1)*thick.<br></span><span class="tab"></span><span class="small">(self inset: t) clear: black.  self clear: white]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">outline</span><span class="small"> </span><span class="tab"></span><span class="small">↪</span><span class="small italic">default border is two thick</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[self outline: 2]&rsquo;</span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">one thick is two thin</span><span class="small">↪<br>Rectangle understands: &rsquo;</span><span class="small underline">bitsIntoString</span><span class="small"> | extent str<br></span><span class="tab"></span><span class="small">[extent &larr; corner-origin.<br></span><span class="tab"></span><span class="small">str &larr; String new: 2 * extent y * (extent x+15/16).<br></span><span class="tab"></span><span class="small">!self  bitsIntoString: str]&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">bitsIntoString:</span><span class="small"> str [] primitive: 51&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">bitsFromString:</span><span class="small"> str [] primitive: 52&rsquo;<br>Rectangle understands: &rsquo;</span><span class="small underline">fromuser</span><span class="small"><br></span><span class="tab"></span><span class="small">[↪redbugcursor showwhile⦂ [↪<br></span><span class="tab"></span><span class="small">while⦂ user anybug do⦂ [].<br></span><span class="tab"></span><span class="small">until⦂ user anybug do⦂ [origin &larr; user mp].<br></span><span class="tab"></span><span class="small">while⦂ user anybug do⦂ [corner &larr; user mp. self comp. self comp].<br></span><span class="tab"></span><span class="small">↪]↪ ]&rsquo;<br></span><span class="small"><br></span><span class="medium bold">Class new title: &rsquo;Turtle&rsquo;;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;pen ink width dir x xf y yf frame</span><span class="small">&rsquo;</span><span class="medium bold"><br></span><span class="small">Turtle understands: &rsquo;</span><span class="small underline">init</span><span class="small"><br></span><span class="tab"></span><span class="small">[ink &larr; ¬3. pen &larr; width &larr; 1. dir &larr; 270.<br></span><span class="tab"></span><span class="small">frame &larr; user screenrect.<br></span><span class="tab"></span><span class="small">self place: frame center]&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">go:</span><span class="small"> length [] primitive: 53&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">goto:</span><span class="small"> pt [] primitive: 54&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">turn:</span><span class="small"> angle<br></span><span class="tab"></span><span class="small">[dir &larr; dir+angle \ 360] primitive: 55&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">put:</span><span class="small"> char </span><span class="small underline">font:</span><span class="small"> font [] primitive: 56&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">show:</span><span class="small"> str </span><span class="small underline">font:</span><span class="small"> font | x<br></span><span class="tab"></span><span class="small">[for⦂ x from: str do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[self put: x font: font]]&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">place:</span><span class="small"> pt<br></span><span class="tab"></span><span class="small">[x &larr; pt x. y &larr; pt y. xf &larr; yf &larr; 0]&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">width:</span><span class="small"> width&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">pen:</span><span class="small"> pen&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">ink:</span><span class="small"> ink&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">up</span><span class="small"><br></span><span class="tab"></span><span class="small">[dir &larr; 270]&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">pendn</span><span class="small"><br></span><span class="tab"></span><span class="small">[pen &larr; 1]&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">penup</span><span class="small"><br></span><span class="tab"></span><span class="small">[pen &larr; 0]&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">black</span><span class="small"><br></span><span class="tab"></span><span class="small">[ink &larr; ¬3]&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">white</span><span class="small"><br></span><span class="tab"></span><span class="small">[ink &larr; ¬1]&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">xor</span><span class="small"><br></span><span class="tab"></span><span class="small">[ink &larr; ¬2]&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">home</span><span class="tab"></span><span class="tab"></span><span class="small"><br></span><span class="tab"></span><span class="small">[self place: frame center. dir &larr; 270]&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">erase</span><span class="small"><br></span><span class="tab"></span><span class="small">[frame clear: 0]&rsquo;<br>Turtle understands: &rsquo;</span><span class="small underline">frame:</span><span class="small"> frame&rsquo;<br></span></div>
<div class="line center">
<span class="small"><br></span><span class="small">↪</span><span class="medium bold">TEXT DISPLAY</span><span class="small">↪</span></div>
<div class="line left">
<span class="medium bold">Class new title: &rsquo;Textframe&rsquo;;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;frame para style reply1 reply2 window</span><span class="small">&rsquo;</span><span class="medium bold"><br></span><span class="small">Textframe understands: &rsquo;</span><span class="small underline">para:</span><span class="small"> para </span><span class="small underline">frame:</span><span class="small"> frame<br></span><span class="tab"></span><span class="small">[window &larr; frame.<br></span><span class="tab"></span><span class="small">reply1 &larr; reply1 &larr; 0.<br></span><span class="tab"></span><span class="small">style &larr; DefaultTextStyle]&rsquo;<br>Textframe understands: &rsquo;</span><span class="small underline">show</span><span class="small"> [] primitive: 57&rsquo;<br>Textframe understands: &rsquo;</span><span class="small underline">show:</span><span class="small"> para<br></span><span class="tab"></span><span class="small">[para &larr; para asParagraph. self show]&rsquo;<br>Textframe understands: &rsquo;</span><span class="small underline">charofpt:</span><span class="small"> pt [] primitive: 58&rsquo;<br>Textframe understands: &rsquo;</span><span class="small underline">charnearpt:</span><span class="small"> pt [] primitive: 58&rsquo;</span><span class="tab"></span><span class="small">↪synonym↪<br>Textframe understands: &rsquo;</span><span class="small underline">selectchar:</span><span class="small"> char<br></span><span class="tab"></span><span class="small">[self selectchar: char asInteger] primitive: 59&rsquo;<br>Textframe understands: &rsquo;</span><span class="small underline">ptofchar:</span><span class="small"> char<br></span><span class="tab"></span><span class="small">[self selectchar: char. !reply1]&rsquo;<br>Textframe understands: &rsquo;</span><span class="small underline">rectofchar:</span><span class="small"> char<br></span><span class="tab"></span><span class="small">[self selectchar: char. !reply1 rect: reply2]&rsquo;<br>Textframe understands: &rsquo;</span><span class="small underline">comp</span><span class="small"><br></span><span class="tab"></span><span class="small">[window comp]&rsquo;<br>Textframe understands: &rsquo;</span><span class="small underline">lineheight</span><span class="small"><br></span><span class="tab"></span><span class="small">[!style lineheight]&rsquo;<br>Textframe understands: &rsquo;</span><span class="small underline">scrolln:</span><span class="small"> n<br></span><span class="tab"></span><span class="small">[!self charofpt: frame origin+(0 @ (n+1*style lineheight))]&rsquo;<br>Textframe understands: &rsquo;</span><span class="small underline">lastshown</span><span class="small"><br></span><span class="tab"></span><span class="small">[!reply1]&rsquo;<br>Textframe understands: &rsquo;</span><span class="small underline">window</span><span class="small"> [!window]&rsquo;<br>Textframe understands: &rsquo;</span><span class="small underline">put:</span><span class="small"> para </span><span class="small underline">at:</span><span class="small"> pt<br></span><span class="tab"></span><span class="small">[self put: para at: pt centered: false]&rsquo;<br>Textframe understands: &rsquo;</span><span class="small underline">put:</span><span class="small"> para </span><span class="small underline">centered:</span><span class="small"> pt<br></span><span class="tab"></span><span class="small">[self put: para at: pt centered: true]&rsquo;<br>Textframe understands: &rsquo;</span><span class="small underline">put:</span><span class="small"> para </span><span class="small underline">at:</span><span class="small"> pt </span><span class="small underline">centered:</span><span class="small"> center<br></span><span class="tab"></span><span class="small">[para &larr; para asParagraph.<br></span><span class="tab"></span><span class="small">window&larr; frame&larr; pt rect: 1000◦1000.<br></span><span class="tab"></span><span class="small">self ptofchar: para length+1.</span><span class="tab"></span><span class="small">↪</span><span class="small italic">find corner of text</span><span class="small">↪<br></span><span class="tab"></span><span class="small">window growto: reply2.<br></span><span class="tab"></span><span class="small">[center? [window moveby: pt-window center]].</span><span class="tab"></span><span class="small">↪</span><span class="small italic">center it</span><span class="small">↪<br></span><span class="tab"></span><span class="small">self show]&rsquo;<br>Textframe understands: &rsquo;</span><span class="small underline">printon:</span><span class="small"> strm<br></span><span class="tab"></span><span class="small">[strm append: &rsquo;&rsquo;a Textframe&rsquo;&rsquo;]&rsquo;<br></span><span class="small"><br><br></span><span class="medium bold">Class new title: &rsquo;Paragraph&rsquo;;<br></span><span class="tab"></span><span class="medium bold">subclassof: Array;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;text runs alignment</span><span class="small">&rsquo;</span><span class="medium bold"><br></span><span class="small">Paragraph understands: &rsquo;</span><span class="small underline">text:</span><span class="small"> text&rsquo;<br>Paragraph understands: &rsquo;</span><span class="small underline">text:</span><span class="small"> text </span><span class="small underline">runs:</span><span class="small"> runs&rsquo;<br>Paragraph understands: &rsquo;</span><span class="small underline">text:</span><span class="small"> text </span><span class="small underline">alignment:</span><span class="small"> alignment&rsquo;<br>Paragraph understands: &rsquo;</span><span class="small underline">text:</span><span class="small"> text </span><span class="small underline">runs:</span><span class="small"> runs </span><span class="small underline">alignment:</span><span class="small"> alignment&rsquo;<br>Paragraph understands: &rsquo;</span><span class="small underline">flushleft</span><span class="small"><br></span><span class="tab"></span><span class="small">[alignment &larr; 0]&rsquo;<br>Paragraph understands: &rsquo;</span><span class="small underline">justify</span><span class="small"><br></span><span class="tab"></span><span class="small">[alignment &larr; 1]&rsquo;<br>Paragraph understands: &rsquo;</span><span class="small underline">center</span><span class="small"><br></span><span class="tab"></span><span class="small">[alignment &larr; 2]&rsquo;<br>Paragraph understands: &rsquo;</span><span class="small underline">flushright</span><span class="small"><br></span><span class="tab"></span><span class="small">[alignment &larr; 4]&rsquo;<br>Paragraph understands: &rsquo;</span><span class="small underline">asParagraph</span><span class="small">&rsquo;<br>Paragraph understands: &rsquo;</span><span class="small underline">replace:</span><span class="small"> a </span><span class="small underline">to:</span><span class="small"> b </span><span class="small underline">by:</span><span class="small"> s</span><span class="tab"></span><span class="tab"></span><span class="small">↪no run support↪<br></span><span class="tab"></span><span class="small">[text &larr; text replace: a to: b by: s.<br></span><span class="tab"></span><span class="small">runs &larr; nil]&rsquo;<br>Paragraph understands: &rsquo;</span><span class="small underline">copy:</span><span class="small"> a </span><span class="small underline">to:</span><span class="small"> b</span><span class="tab"></span><span class="tab"></span><span class="small">↪no run support↪<br></span><span class="tab"></span><span class="small">[!(text◦(a to: b)) copy]&rsquo;<br>Paragraph understands: &rsquo;</span><span class="small underline">asVector</span><span class="small"> [!text asVector]&rsquo;<br>Paragraph understands: &rsquo;</span><span class="small underline">length</span><span class="small"><br></span><span class="tab"></span><span class="small">[!text length]&rsquo;<br>Paragraph understands: &rsquo;◦</span><span class="small underline">x</span><span class="small"><br></span><span class="tab"></span><span class="small">[!text◦x]&rsquo;<br><br></span><span class="small"><br>C</span><span class="medium bold">lass new title: &rsquo;TextStyle&rsquo;;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;fonts </span><span class="small italic">↪</span><span class="small">&lt;</span><span class="small italic">Vector of Strings or Integers&gt; which are the fonts.<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small italic">An integer entry has a vertical offset in the high 8 bits, a 1 in<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small italic">the 200-bit for descent, and another font number (zero-relative)<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small italic">in the bottom 4 bits↪</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small italic">t</span><span class="medium bold">abandspace </span><span class="small italic">↪</span><span class="small">&lt;</span><span class="small italic">Integer&gt; =256*tabwidth + spacewidth↪</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small italic">m</span><span class="medium bold">axascent </span><span class="small italic">↪</span><span class="small">&lt;</span><span class="small italic">Integer&gt; max ascent for this fontset↪</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small italic">m</span><span class="medium bold">axdescent </span><span class="small italic">↪</span><span class="small">&lt;</span><span class="small italic">Integer&gt; max descent for this fontset↪</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small italic">m</span><span class="medium bold">ode </span><span class="small italic">↪</span><span class="small">&lt;</span><span class="small italic">Integer&gt; =0 for normal, =4 for white-on-black↪</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small italic">f</span><span class="medium bold">ontnames </span><span class="small italic">↪</span><span class="small">&lt;</span><span class="small italic">Vector of Strings&gt; corresponding to the fonts↪</span><span class="small">&rsquo;</span><span class="small"><br></span><span class="medium bold">T</span><span class="small">extStyle understands: &rsquo;f</span><span class="small underline">onts </span><span class="small">[!fonts]&rsquo;<br>TextStyle understands: &rsquo;l</span><span class="small underline">ineheight<br></span><span class="tab"></span><span class="small">[!maxascent+maxdescent]&rsquo;<br>TextStyle understands: &rsquo;d</span><span class="small underline">efault<br></span><span class="tab"></span><span class="small">[self mode: 0; tab: 20; space: 5]&rsquo;<br>TextStyle understands: &rsquo;t</span><span class="small underline">ab: </span><span class="small">t<br></span><span class="tab"></span><span class="small">[tabandspace &larr; tabandspace field: leftbyte &larr; t]&rsquo;<br>TextStyle understands: &rsquo;s</span><span class="small underline">pace: </span><span class="small">t<br></span><span class="tab"></span><span class="small">[tabandspace &larr; tabandspace field: rightbyte &larr; t]&rsquo;<br>TextStyle understands: &rsquo;m</span><span class="small underline">ode: </span><span class="small">mode&rsquo;<br>TextStyle understands: &rsquo;s</span><span class="small underline">etfont: </span><span class="small">n n</span><span class="small underline">ame: </span><span class="small">str | name f</span><span class="tab"></span><span class="small">↪s</span><span class="small italic">hould update max-a/de-scent↪</span><span class="small"><br></span><span class="tab"></span><span class="small">[FontDict has: (</span><span class="small">n</span><span class="small">ame&larr; str unique)</span><span class="small">?</span><span class="small"> [fonts◦n &larr; FontDict◦name]<br></span><span class="tab"></span><span class="small">f &larr; File new old named: str + &rsquo;&rsquo;.strike&rsquo;&rsquo;.<br></span><span class="tab"></span><span class="small">f? [FontDict insert: name with: (fonts◦n &larr; f intostring)]<br></span><span class="tab"></span><span class="small">user notify: &rsquo;&rsquo;Font &rsquo;&rsquo; +</span><span class="small"> </span><span class="small">str +</span><span class="small"> </span><span class="small">&rsquo;&rsquo;.strike not on this disk&rsquo;&rsquo;]&rsquo;<br>TextStyle understands: &rsquo;s</span><span class="small underline">etoffsetfont: </span><span class="small">n f</span><span class="small underline">rom: </span><span class="small">m b</span><span class="small underline">y: </span><span class="small">d<br></span><span class="tab"></span><span class="small">[fonts◦n &larr; m + [d&lt;0? [0200] 0] + (</span><span class="small">d</span><span class="small"> lshift: 8)</span><span class="small">]</span><span class="small">&rsquo;<br><br></span><span class="small"><br>C</span><span class="medium bold">lass new title: &rsquo;Dispframe&rsquo;;<br></span><span class="tab"></span><span class="medium bold">subclassof: Stream;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;text&rsquo;</span><span class="small"><br></span><span class="medium bold">D</span><span class="small">ispframe understands: &rsquo;r</span><span class="small underline">ect: </span><span class="small">r<br></span><span class="tab"></span><span class="small">[text &larr; Textframe new para: nil frame: r.<br></span><span class="tab"></span><span class="small">self of: (</span><span class="small">S</span><span class="small">tring new: 16)</span><span class="small">.</span><span class="small"> self clear]&rsquo;<br>Dispframe understands: &rsquo;s</span><span class="small underline">how<br></span><span class="tab"></span><span class="small">[text show: self contents.<br></span><span class="tab"></span><span class="small">until⦂ text lastshown≥self position do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[self dequeue: (text scrolln: 2).<br></span><span class="tab"></span><span class="tab"></span><span class="small">text show: self contents]]&rsquo;<br>Dispframe understands: &rsquo;e</span><span class="small underline">v </span><span class="small">| t<br></span><span class="tab"></span><span class="small">[while⦂ [t &larr; self request: &rsquo;&rsquo;<br>&#64257;&rsquo;&rsquo;] do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[t≡nil? [self print: nil doit; show]</span><span class="tab"></span><span class="small">↪redo↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">self print: nil ⓢt; show]<br></span><span class="tab"></span><span class="small">!false]&rsquo;<br>Dispframe understands: &rsquo;r</span><span class="small underline">equest: </span><span class="small">s<br></span><span class="tab"></span><span class="small">[self append: s. !self read]&rsquo;<br>Dispframe understands: &rsquo;r</span><span class="small underline">ead </span><span class="small">| n t<br></span><span class="tab"></span><span class="small">[self show. n &larr; 0.<br></span><span class="tab"></span><span class="small">while⦂ true do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[t &larr; user kbd.<br></span><span class="tab"></span><span class="tab"></span><span class="small">t=4? [self skip: 0-n; append: &rsquo;&rsquo;done&rsquo;&rsquo;; show. !false]</span><span class="tab"></span><span class="small">↪c</span><span class="small italic">tl-d for done↪</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">t=8? [n=0?[self show]. self skip: ¬1. n &larr; n-1.<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">user kbck?[]. self show]</span><span class="tab"></span><span class="small">↪b</span><span class="small italic">ackspace↪</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">t=2? [self skip: ¬1-n. !nil]</span><span class="tab"></span><span class="small">↪r</span><span class="small italic">edo↪</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="small">t=30? [t &larr; self last: n.</span><span class="tab"></span><span class="small">↪d</span><span class="small italic">o-it↪</span><span class="small"><br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">self next &larr; 30; cr; show. !t]<br></span><span class="tab"></span><span class="tab"></span><span class="small">t=24?[self reset; append: &rsquo;&rsquo;&#64257;&rsquo;&rsquo;; show. n&larr;0]<br></span><span class="tab"></span><span class="tab"></span><span class="small">self next &larr; t. n &larr; n+1.<br></span><span class="tab"></span><span class="tab"></span><span class="small">user kbck? [] self show]]&rsquo;<br>Dispframe understands: &rsquo;c</span><span class="small underline">lear<br></span><span class="tab"></span><span class="small">[self reset. self show]&rsquo;<br>Dispframe understands: &rsquo;o</span><span class="small underline">utline<br></span><span class="tab"></span><span class="small">[text window outline]&rsquo;<br>Dispframe understands: &rsquo;m</span><span class="small underline">oveto: </span><span class="small">pt<br></span><span class="tab"></span><span class="small">[(text window inset: ¬2@¬2) dragto: pt-(¬2@¬2)]&rsquo;<br></span></div>
<div class="line center">
<span class="small"><br></span><span class="small">↪</span><span class="medium bold">SETS AND DICTIONARIES</span><span class="small">↪</span></div>
<div class="line left">
<span class="medium bold">Class new title: &rsquo;HashSet&rsquo;;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;objects&rsquo;<br></span><span class="small">HashSet understands: &rsquo;</span><span class="small underline">default</span><span class="small"><br></span><span class="tab"></span><span class="small">[self init: 4]&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">default initial size</span><span class="small">↪<br>HashSet understands: &rsquo;</span><span class="small underline">init</span><span class="small"><br></span><span class="tab"></span><span class="small">[self init: 4]&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">obsolete</span><span class="small">↪<br>HashSet understands: &rsquo;</span><span class="small underline">init:</span><span class="small"> size<br></span><span class="tab"></span><span class="small">[objects &larr; Vector new: (size max: 4)]&rsquo;<br>HashSet understands: &rsquo;</span><span class="small underline">insert:</span><span class="small"> obj | i<br></span><span class="tab"></span><span class="small">[self findorinsert: obj. !obj]&rsquo;<br>HashSet understands: &rsquo;</span><span class="small underline">has:</span><span class="small"> obj<br></span><span class="tab"></span><span class="small">[self find: obj? [!true] !false]&rsquo;<br>HashSet understands: &rsquo;</span><span class="small underline">findorinsert:</span><span class="small"> obj | i</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">insert if not found, </span><span class="small">↪<br></span><span class="tab"></span><span class="small">[i &larr; self findornil: obj? [objects◦i &larr; obj. !i]<br></span><span class="tab"></span><span class="small">self growto: objects length*2.</span><span class="tab"></span><span class="small">↪</span><span class="small italic">may cause table to grow</span><span class="small">↪<br></span><span class="tab"></span><span class="small">!self findorinsert: obj]&rsquo;<br>HashSet understands: &rsquo;</span><span class="small underline">find:</span><span class="small"> obj | i</span><span class="tab"></span><span class="small">↪</span><span class="small italic">!index if found, else false</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[i &larr; self findornil: obj?<br></span><span class="tab"></span><span class="tab"></span><span class="small">[objects◦i≡nil? [!false] !i]<br></span><span class="tab"></span><span class="small">!false]&rsquo;<br>HashSet understands: &rsquo;</span><span class="small underline">findornil:</span><span class="small"> obj | i loc</span><span class="tab"></span><span class="small">↪</span><span class="small italic">!index if found or if room, else false</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[loc &larr; obj hash\objects length+1.</span><span class="tab"></span><span class="small">↪</span><span class="small italic">does this match the ucode</span><span class="small">↪<br></span><span class="tab"></span><span class="small">objects◦loc ≡ nil? [!loc]<br></span><span class="tab"></span><span class="small">objects◦loc = obj? [!loc]</span><span class="tab"></span><span class="small">↪</span><span class="small italic">first probe cheap</span><span class="small">↪<br></span><span class="tab"></span><span class="small">for⦂ i to: (4 max: objects length / 4) do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[loc &larr; loc\objects length+1.</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">better delta later if necess</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">objects◦loc ≡ nil? [!loc]<br></span><span class="tab"></span><span class="tab"></span><span class="small">objects◦loc = obj? [!loc]]<br></span><span class="tab"></span><span class="small">!false]&rsquo;<br>HashSet understands: &rsquo;</span><span class="small underline">delete:</span><span class="small"> obj | i<br></span><span class="tab"></span><span class="small">[i &larr; self find: obj?<br></span><span class="tab"></span><span class="tab"></span><span class="small">[objects◦i &larr; nil.</span><span class="tab"></span><span class="small">↪</span><span class="small italic">delete, then rehash</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">!self growto: objects length]]&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">returns result of growto</span><span class="small">↪<br>HashSet understands: &rsquo;</span><span class="small underline">growto:</span><span class="small"> size | copy i<br></span><span class="tab"></span><span class="small">[copy &larr; self class new init: size.</span><span class="tab"></span><span class="small">↪</span><span class="small italic">create a copy</span><span class="small">↪<br></span><span class="tab"></span><span class="small">for⦂ i from: self do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[copy insert: i]</span><span class="tab"></span><span class="small">↪</span><span class="small italic">hash each entry into it</span><span class="small">↪<br></span><span class="tab"></span><span class="small">objects &larr; copy objects]&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">then take on all its state</span><span class="small">↪<br>HashSet understands: &rsquo;</span><span class="small underline">objects</span><span class="small"> [!objects]&rsquo;<br>HashSet understands: &rsquo;</span><span class="small underline">objects&larr;</span><span class="small"> objects&rsquo;<br>HashSet understands: &rsquo;</span><span class="small underline">contents</span><span class="small"> | obj strm<br></span><span class="tab"></span><span class="small">[strm &larr; (Vector new: objects length) asStream.<br></span><span class="tab"></span><span class="small">for⦂ obj from: objects do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[obj≡nil? [] strm next&larr; obj]<br></span><span class="tab"></span><span class="small">!strm contents]&rsquo;<br>HashSet understands: &rsquo;</span><span class="small underline">asStream</span><span class="small"><br></span><span class="tab"></span><span class="small">[!self contents asStream]&rsquo;<br>HashSet understands: &rsquo;</span><span class="small underline">notthere:</span><span class="small"> name<br></span><span class="tab"></span><span class="small">[user notify: name asString+&rsquo;&rsquo; not found.&rsquo;&rsquo;]&rsquo;<br></span><span class="small"><br><br></span><span class="medium bold">Class new title: &rsquo;Dictionary&rsquo;;<br></span><span class="tab"></span><span class="medium bold">subclassof: HashSet;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;values&rsquo;<br></span><span class="small">↪</span><span class="small italic">Dictionaries have the same lookup properties as Sets, except that they also associate a value with each object present.</span><span class="small">↪</span><span class="small italic"><br></span><span class="small">Dictionary understands: &rsquo;</span><span class="small underline">init:</span><span class="small"> size<br></span><span class="tab"></span><span class="small">[values &larr; Vector new: size. super init: size]&rsquo;<br>Dictionary understands: &rsquo;</span><span class="small underline">insert:</span><span class="small"> name </span><span class="small underline">with:</span><span class="small"> value<br></span><span class="tab"></span><span class="small">[self insert: name.  values◦(self find: name) &larr; value]&rsquo;<br>Dictionary understands: &rsquo;</span><span class="small underline">◦</span><span class="small"> name | x<br></span><span class="tab"></span><span class="small">[x &larr; self find: name? [!values◦x]<br></span><span class="tab"></span><span class="small">self notthere: name]&rsquo;<br>Dictionary understands: &rsquo;</span><span class="small underline">◦</span><span class="small"> name </span><span class="small underline">&larr;</span><span class="small"> value | x<br></span><span class="tab"></span><span class="small">[x &larr; self find: name? [!values◦x &larr; value]<br></span><span class="tab"></span><span class="small">self notthere: name]&rsquo;<br>Dictionary understands: &rsquo;</span><span class="small underline">lookup:</span><span class="small"> name | x<br></span><span class="tab"></span><span class="small">[x &larr; self find: name? [!values◦x] !false]&rsquo;<br>Dictionary understands: &rsquo;</span><span class="small underline">growto:</span><span class="small"> size | name copy<br></span><span class="tab"></span><span class="small">[copy &larr; self class new init: size.</span><span class="tab"></span><span class="small">↪create a copy of the new size↪<br></span><span class="tab"></span><span class="small">for⦂ name from: self do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[copy insert: name with: self◦name]</span><span class="tab"></span><span class="small">↪hash each entry into it↪<br></span><span class="tab"></span><span class="small">self copyfrom: copy]&rsquo;</span><span class="tab"></span><span class="small">↪then take on all its state↪<br>Dictionary understands: &rsquo;</span><span class="small underline">copyfrom:</span><span class="small"> dict<br></span><span class="tab"></span><span class="small">[self objects &larr; dict objects copy.<br></span><span class="tab"></span><span class="small">values &larr; dict values copy]&rsquo;<br>Dictionary understands: &rsquo;</span><span class="small underline">values</span><span class="small"> [!values]&rsquo;<br>Dictionary understands: &rsquo;</span><span class="small underline">clean</span><span class="small"> | name</span><span class="tab"></span><span class="small">↪</span><span class="small italic">release unreferenced entries</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[for⦂ name from: self do⦂</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">slick, huh</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">[(self◦name) refct = 1 ? [self delete: name]]]&rsquo;<br>Dictionary understands: &rsquo;</span><span class="small underline">insertall:</span><span class="small"> names </span><span class="small underline">with:</span><span class="small"> vals | i</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">insert many entries</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[for⦂ i to: names length do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[self insert: names◦i with: vals◦i]]&rsquo;<br>Dictionary understands: &rsquo;</span><span class="small underline">insertall:</span><span class="small"> names</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">default value is nil</span><span class="small">↪<br></span><span class="tab"></span><span class="small">[self insertall: names with: (Vector new: names length)]&rsquo;<br></span><span class="small"><br><br></span><span class="medium bold">Class new title: &rsquo;SymbolTable&rsquo;;<br></span><span class="tab"></span><span class="medium bold">subclassof: Dictionary;<br></span><span class="tab"></span><span class="medium bold">fields:&rsquo;&rsquo;<br></span><span class="small">↪</span><span class="small italic">SymbolTables have the same properties as Dictionaries, except that an indirect reference is interposed between the value entries and the actual values.  This allows compiled code to point directly at a reference which remains valid although the value changes.  Notice that the define message checks in Undefined for unresolved references which the compiler may have placed there previously.</span><span class="small">↪</span><span class="small italic"><br></span><span class="small">SymbolTable understands: &rsquo;</span><span class="small underline">insert:</span><span class="small"> name </span><span class="small underline">with:</span><span class="small"> x<br></span><span class="tab"></span><span class="small">[super insert: name with: </span><span class="small">(</span><span class="small">ObjectReference new value&larr; x</span><span class="small">)</span><span class="small">]&rsquo;<br>SymbolTable understands: &rsquo;</span><span class="small underline">◦</span><span class="small"> name<br></span><span class="tab"></span><span class="small">[!(super◦name) value]&rsquo;<br>SymbolTable understands: &rsquo;</span><span class="small underline">◦</span><span class="small"> name </span><span class="small underline">&larr;</span><span class="small"> x<br></span><span class="tab"></span><span class="small">[!(super◦name) value &larr; x]&rsquo;<br>SymbolTable understands: &rsquo;</span><span class="small underline">ref:</span><span class="small"> name<br></span><span class="tab"></span><span class="small">[!super◦name]&rsquo;<br>SymbolTable understands: &rsquo;</span><span class="small underline">define:</span><span class="small"> name </span><span class="small underline">as:</span><span class="small"> x<br></span><span class="tab"></span><span class="small">[self has: name? [self◦name &larr; x]<br></span><span class="tab"></span><span class="small">Undeclared has: name?<br></span><span class="tab"></span><span class="tab"></span><span class="small">[super insert: name with: (</span><span class="small">U</span><span class="small">ndeclared ref: name</span><span class="small">)</span><span class="small">.<br></span><span class="tab"></span><span class="tab"></span><span class="small">self◦name &larr; x.<br></span><span class="tab"></span><span class="tab"></span><span class="small">Undeclared delete: name]<br></span><span class="tab"></span><span class="small">self insert: name with: x]&rsquo;<br></span><span class="small"><br><br></span><span class="medium bold">Class new title: &rsquo;MessageDict&rsquo;;<br></span><span class="tab"></span><span class="medium bold">subclassof: HashSet;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;methods </span><span class="small">↪</span><span class="small italic">&lt;Vector of Strings&gt; which are the compiled methods for each message</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">literals </span><span class="small">↪</span><span class="small italic">&lt;Vector of Vectors&gt; which hold pointers to literals used in the methods</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">code </span><span class="small">↪</span><span class="small italic">&lt;Vector of Strings&gt; which are the source text for each message</span><span class="small">↪</span><span class="medium bold"><br></span><span class="tab"></span><span class="tab"></span><span class="medium bold">backpointers </span><span class="small">↪</span><span class="small italic">&lt;Vector of Vectors&gt; which are the tables of text location vs pc for each message</span><span class="small">↪</span><span class="medium bold">&rsquo;<br></span><span class="small">↪</span><span class="small italic">Note that insertion and deletion return the updated dictionary.  This is because Smalltalk may be executing out of the dictionary.  The final switch to the new dictionary is made in Class with one atomic assignment.</span><span class="small">↪<br>MessageDict understands: &rsquo;</span><span class="small underline">init:</span><span class="small"> size<br></span><span class="tab"></span><span class="small">[methods &larr; Vector new: size.  literals &larr; Vector new: size.<br></span><span class="tab"></span><span class="small">code &larr; Vector new: size.  </span><span class="tab"></span><span class="small">backpointers &larr; Vector new: size.<br></span><span class="tab"></span><span class="small">super init: size]&rsquo;<br>MessageDict understands: &rsquo;</span><span class="small underline">insert:</span><span class="small"> name </span><span class="small underline">method:</span><span class="small"> m </span><span class="small underline">literals:</span><span class="small"> l<br></span><span class="tab"></span><span class="tab"></span><span class="small underline">code:</span><span class="small"> c </span><span class="small underline">backpointers:</span><span class="small"> b | i copy<br></span><span class="tab"></span><span class="small">[i &larr; self findornil: name?</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">if name is already there</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">[methods◦i &larr; m. literals◦i &larr; l. code◦i &larr; c. backpointers◦i &larr; b.<br></span><span class="tab"></span><span class="tab"></span><span class="small">self objects◦i &larr; name]</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">then do it, and return self</span><span class="small">↪<br></span><span class="tab"></span><span class="small">copy &larr; self growto: methods length*2.</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">Otherwise, copy</span><span class="small">↪<br></span><span class="tab"></span><span class="small">copy insert: name method: m literals: l<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">code: c backpointers: b.</span><span class="tab"></span><span class="small">↪</span><span class="small italic">and insert</span><span class="small">↪<br></span><span class="tab"></span><span class="small">!copy]&rsquo;</span><span class="tab"></span><span class="tab"></span><span class="small">↪</span><span class="small italic">and return the new dict without altering old</span><span class="small">↪<br>MessageDict understands: &rsquo;</span><span class="small underline">method:</span><span class="small"> name<br></span><span class="tab"></span><span class="small">[!methods◦(self find: name)]&rsquo;<br>MessageDict understands: &rsquo;</span><span class="small underline">literals:</span><span class="small"> name<br></span><span class="tab"></span><span class="small">[!literals◦(self find: name)]&rsquo;<br>MessageDict understands: &rsquo;</span><span class="small underline">code:</span><span class="small"> name<br></span><span class="tab"></span><span class="small">[!code◦(self find: name)]&rsquo;<br>MessageDict understands: &rsquo;</span><span class="small underline">backpointers:</span><span class="small"> name<br></span><span class="tab"></span><span class="small">[!backpointers◦(self find: name)]&rsquo;<br>MessageDict understands: &rsquo;</span><span class="small underline">growto:</span><span class="small"> size | name copy i<br></span><span class="tab"></span><span class="small">[copy &larr; self class new init: size.</span><span class="tab"></span><span class="small">↪</span><span class="small italic">create a copy of the new size</span><span class="small">↪<br></span><span class="tab"></span><span class="small">for⦂ name from: self do⦂<br></span><span class="tab"></span><span class="tab"></span><span class="small">[i &larr; self find: name.</span><span class="tab"></span><span class="small">↪</span><span class="small italic">hash each entry into it</span><span class="small">↪<br></span><span class="tab"></span><span class="tab"></span><span class="small">copy insert: name method: methods◦i literals: literals◦i<br></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="small">code: code◦i backpointers: backpointers◦i]<br></span><span class="tab"></span><span class="small">!copy]&rsquo;</span><span class="tab"></span><span class="small">↪</span><span class="small italic">copy new parts</span><span class="small">↪<br><br></span></div>
<div class="line center">
<span class="small"><br></span><span class="small">↪</span><span class="medium bold">INDIRECT REFERENCES</span><span class="small">↪</span></div>
<div class="line left">
<span class="small"><br></span><span class="medium bold">Class new title: &rsquo;ObjectReference&rsquo;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;object&rsquo;<br></span><span class="small">ObjectReference understands: &rsquo;</span><span class="small underline">value</span><span class="small"> [!object]&rsquo;<br>ObjectReference understands: &rsquo;</span><span class="small underline">value &larr;</span><span class="small"> object&rsquo;<br>ObjectReference understands: &rsquo;</span><span class="small underline">printon:</span><span class="small"> strm<br></span><span class="tab"></span><span class="small">[strm append: &rsquo;&rsquo;-&gt;&rsquo;&rsquo;; space; print: object class]&rsquo;<br></span><span class="small"><br></span><span class="medium bold">Class new title: &rsquo;FieldReference&rsquo;<br></span><span class="tab"></span><span class="medium bold">fields: &rsquo;object offset&rsquo;<br></span><span class="small">FieldReference understands: &rsquo;</span><span class="small underline">value</span><span class="small"> [!object instfield: offset]&rsquo;<br>FieldReference understands: &rsquo;</span><span class="small underline">value &larr;</span><span class="small"> value<br></span><span class="tab"></span><span class="small">[!object instfield: offset &larr; value]&rsquo;<br></span></div>
<div class="line left">
</div>
  </body>
</html>
